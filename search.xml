<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode：最接近的三数之和</title>
    <url>/2021/07/06/algorithm/LeetCode%EF%BC%9A%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 </p>
</blockquote>
<span id="more"></span>

<h2 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h2><p>从一个数组中拿出三个数，使得这三个数的和与目标值的差值最小，这三个数具有唯一解的性质。<br>该题如果使用暴力破解法，时间复杂度为 O(n^3)，这是一个比较糟糕的破解方式。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找出每个数组元素的另外两个最优解，使得这三个元素之和与目标值的差值达到最小。</p>
<p>为了能够把握数组三个元素之和与目标值的大小，从而找到比当前三个元素更加合适的元素值，我们可以先对数组进行一次有序排序，这样就可以准确把握三个元素之和与目标值的大小关系。</p>
<p>如果三数之和比目标值小，我们可以尝试往数组的右边找更大的元素来找寻更优解。<br>如果三数之和比目标值大，我们可以尝试往数组的左边找更小的元素来找寻更优解。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先对数组进行一次有序排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> i, l, r, sum, n = nums.length;</span><br><span class="line">        <span class="comment">// 随便获取目标值和三位数的差绝对值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> Math.abs(target - result), temCha;</span><br><span class="line">        <span class="comment">// 循环的最后一位是 [n-3], 最后三位相加 [n-3] + [n-2] + [n-1]</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 在循环过程中，如果当前循环的值和前一位值相等，就可以不用循环，因为值都是一样的，结果也就是一样的</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前循环的下一位元素</span></span><br><span class="line">            l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 获取数组最后一位元素</span></span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> sum;</span><br><span class="line">                &#125;</span><br><span class="line">                temCha = Math.abs(target - sum);</span><br><span class="line">                <span class="comment">// 如果差值更小，将差值更小的和赋值给 result，并保存更小的差值</span></span><br><span class="line">                <span class="keyword">if</span> (temCha &lt; cha) &#123;</span><br><span class="line">                    result = sum;</span><br><span class="line">                    cha = temCha;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 因为是有序数组，如果值太小，则尝试增加左边的值</span></span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 因为是有序数组，如果值太小，则尝试减小右边的值</span></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><blockquote>
<p>解答成功:<br>执行耗时:4 ms,击败了97.88% 的Java用户<br>内存消耗:38 MB,击败了64.64% 的Java用户</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>LeetCode</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之快速排序</title>
    <url>/2021/04/17/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="什么是快速排序"><a href="#什么是快速排序" class="headerlink" title="什么是快速排序"></a>什么是快速排序</h1><p>和冒泡排序一样，快速排序也属于交换排序，通过元素直接的比较和交换位置来达到排序的目的。</p>
<span id="more"></span>
<p>快速排序的思想是：<strong>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数的一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。</strong></p>
<p>这种思想就叫做<strong>分治法</strong>。</p>
<h2 id="基准元素的选择"><a href="#基准元素的选择" class="headerlink" title="基准元素的选择"></a>基准元素的选择</h2><p>基准元素（pivot），在分治过程中，以基准元素为中心，要把其他元素移动到它的左右两边。</p>
<p>那么如何选择基准元素呢？</p>
<h3 id="选择数组的第一个元素"><a href="#选择数组的第一个元素" class="headerlink" title="选择数组的第一个元素"></a>选择数组的第一个元素</h3><p>这种方法是最简单，而且在绝大多数的情况都不会出现问题。但是如果有一个逆序的数列，期望排成顺序的数列，使用快速排序的时候，会出现一种最坏的情况。</p>
<p>由于这个数组原本是逆序的，在选择基准元素之后，由于确定的基准元素都是在数组的边界位置，永远都是比其他元素大，或者比其他元素小，这样一来，快速排序就会退化为一种 O(n^2) 级别的排序。</p>
<h3 id="随机选择一个元素"><a href="#随机选择一个元素" class="headerlink" title="随机选择一个元素"></a>随机选择一个元素</h3><p>为了解决上述情况可能出现的最坏情况，可以使用随机选择一个数组元素最为基准元素，并让选中的基准元素和数组的第一个元素进行位置交换即可。</p>
<p>当然，随机选择一个元素的方法可以尽量避免快速排序出现最坏的情况，但是仍然有可能会出现极端的情况。</p>
<p>所以快速排序的平均时间复杂度为 O(nlogn)，但最坏情况下的时间复杂度为 O(n^2)。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>选中基准元素之后，就可以进行数组的元素交换操作了，就是将比基准元素小的元素放在基准元素左边，比基准元素大的元素放在基准元素右边。</p>
<h3 id="双边循坏法"><a href="#双边循坏法" class="headerlink" title="双边循坏法"></a>双边循坏法</h3><p>1、选中基准元素（pivot），并将排序的数组最左边和最右边的元素索引设为 left 和 right。</p>
<p>2、从 right 指针开始向左索引，如果指针指向的元素大于等于基准元素，则继续向左边移动，如果元素比基准元素小，则 right 指针停止移动。</p>
<p>3、从 left 指针开始向右索引，如果指针指向的元素小于等于基准元素，则继续向右边移动，如果元素比基准元素大，则 left 指针停止移动。</p>
<p>4、交换 left 和 right 索引位置的元素。</p>
<p>5、从之前停止的 left 和 right 指针的位置，继续重复 2、3 步骤，直到 left 指针等于 right 指针，停止索引。</p>
<p>6、交换 left 和 pivot 指针的元素。</p>
<p>7、根据基准元素的位置，将数组一分为二，并继续从第一步开始执行，直到所有元素有序。</p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">            (arr) -&gt; &#123;</span><br><span class="line">                quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 7、根据基准元素的位置，将数组一分为二，并继续从第一步开始执行，直到所有元素有序。</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、选中基准元素（pivot），并将排序的数组最左边和最右边的元素索引设为 left 和 right。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[startIndex];</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> startIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> endIndex;</span><br><span class="line">    <span class="comment">// 5、从之前停止的 left 和 right 指针的位置，继续重复 2、3 步骤，直到 left 指针等于 right 指针，停止索引。</span></span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="comment">// 2、从 right 指针开始向左索引，如果指针指向的元素大于等于基准元素，则继续向左边移动，如果元素比基准元素小，则 right 指针停止移动。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3、从 left 指针开始向右索引，如果指针指向的元素小于等于基准元素，则继续向右边移动，如果元素比基准元素大，则 left 指针停止移动。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  4、交换 left 和 right 索引位置的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            SortUtils.swap(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6、交换 left 和 pivot 指针的元素。</span></span><br><span class="line">    SortUtils.swap(arr, startIndex, left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h3><p>1、选中基准元素（pivot），并将数组的第一个元素索引设为 mark，mark 指针代表小于基准元素的边界。</p>
<p>2、从基准元素的下一个位置开始遍历数组，如果遍历到的元素大于基准元素，则继续向后遍历。</p>
<p>3、如果遍历到的元素小于基准元素，将 mark 指针的位置向后移动一位，并交换 mark 指针指向的元素和当前遍历到的元素的位置。</p>
<p>4、遍历结束后，交换 pivot 和 mark 指针的位置。</p>
<p>5、根据基准元素的位置，将数组一分为二，并继续从第一步开始执行，直到所有元素有序。</p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">            (arr) -&gt; &#123;</span><br><span class="line">                quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 5、根据基准元素的位置，将数组一分为二，并继续从第一步开始执行，直到所有元素有序。</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、选中基准元素（pivot），并将数组的第一个元素索引设为 mark，mark 指针代表小于基准元素的边界。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[startIndex];</span><br><span class="line">    <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> startIndex;</span><br><span class="line">    <span class="comment">// 2、从基准元素的下一个位置开始遍历数组，如果遍历到的元素大于基准元素，则继续向后遍历。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex + <span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="comment">// 3、如果遍历到的元素小于基准元素，将 mark 指针的位置向后移动一位，并交换 mark 指针指向的元素和当前遍历到的元素的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            mark++;</span><br><span class="line">            SortUtils.swap(arr, mark, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、遍历结束后，交换 pivot 和 mark 指针的位置。</span></span><br><span class="line">    SortUtils.swap(arr, startIndex, mark);</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>递归的本质就是一个方法通过不同参数调用自身，在 Java 虚拟机的表现本质上就是将方法进行压栈，执行完成之后进行出栈操作。</p>
<p>所以快速排序的非递归实现可以使用一个栈来进行代替。</p>
<p>1、创建一个栈，将数组的开始索引和结束索引压入栈中。</p>
<p>2、取出栈顶的元素，通过数组的开始索引和结束索引，对该范围内的数组元素进行排序，获取基准元素。</p>
<p>3、根据基准元素的位置，将数组一分为二，并将切分的数组的开始索引和结束索引压入栈中。</p>
<p>4、轮询栈，只要栈内元素不为空，继续执行，否则停止程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">            (arr) -&gt; &#123;</span><br><span class="line">                quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、创建一个栈，将数组的开始索引和结束索引压入栈中。</span></span><br><span class="line">    Stack&lt;Map&lt;String, Integer&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;start&quot;</span>, startIndex);</span><br><span class="line">    map.put(<span class="string">&quot;end&quot;</span>, endIndex);</span><br><span class="line">    stack.push(map);</span><br><span class="line">    <span class="comment">// 4、轮询栈，只要栈内元素不为空，继续执行，否则停止程序。</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 2、取出栈顶的元素，通过数组的开始索引和结束索引，对该范围内的数组元素进行排序，获取基准元素。</span></span><br><span class="line">        Map&lt;String, Integer&gt; pop = stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pop.get(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> pop.get(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, start, end);</span><br><span class="line">        <span class="comment">// 3、根据基准元素的位置，将数组一分为二，并将切分的数组的开始索引和结束索引压入栈中。</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            leftParam.put(<span class="string">&quot;start&quot;</span>, start);</span><br><span class="line">            leftParam.put(<span class="string">&quot;end&quot;</span>, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            stack.push(leftParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; pivotIndex + <span class="number">1</span>) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            rightParam.put(<span class="string">&quot;start&quot;</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">            rightParam.put(<span class="string">&quot;end&quot;</span>, end);</span><br><span class="line">            stack.push(rightParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[startIndex];</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> startIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> endIndex;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            SortUtils.swap(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SortUtils.swap(arr, startIndex, left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之聊聊你所不知道的冒泡排序</title>
    <url>/2021/03/27/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E8%81%8A%E8%81%8A%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="什么是冒泡排序"><a href="#什么是冒泡排序" class="headerlink" title="什么是冒泡排序"></a>什么是冒泡排序</h1><p>冒泡排序是一种基础的交换排序，其思想是，把相邻的元素两两比较，当一个元素大于右侧相邻的元素时，交换它们的位置：当一个元素小于或等于右侧的元素时，位置不变。</p>
<span id="more"></span>

<p>冒泡排序是一种稳定排序，值相等的元素并不会打乱原有的顺序，由于该排序算法的每一轮都要遍历元素，总共遍历（元素数量 - 1）轮，所以平均时间复杂度是O(n^2)。</p>
<h1 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h1><p>在讲述冒泡排序之前，我们先来搭建一个简单的排序算法编写的环境，这个环境可以帮助我们更加方便地编写和测试排序算法。</p>
<h2 id="SortUtils"><a href="#SortUtils" class="headerlink" title="SortUtils"></a>SortUtils</h2><blockquote>
<p>一个排序算法的工具类，其中包含了排序算法编写和测试的一些基本操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成一个整形数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size   数组大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rangeL 数组左边范围（包含）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rangeR 数组右边范围（包含）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个整形数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generateRandomArray(<span class="type">int</span> size, <span class="type">int</span> rangeL, <span class="type">int</span> rangeR) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * (rangeR - rangeL + <span class="number">1</span>)) + rangeL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个近乎有序的整形数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size      数组大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> swapTimes 将有序数组打乱次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个近乎有序的整形数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generateAlmostOrderlyArray(<span class="type">int</span> size, <span class="type">int</span> swapTimes) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; swapTimes; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * size);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * size);</span><br><span class="line">            swap(arr, index1, index2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个数组是否有序，有序返回true，无序返回false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOrderly</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isOrderAsc(arr) || isOrderDesc(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个数组是否顺序有序，有序返回true，无序返回false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOrderAsc</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个数组是否倒序有序，有序返回true，无序返回false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOrderDesc</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝一个整形数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 整形数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新的整形数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyIntArray(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span>[] copyArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, copyArr, <span class="number">0</span>, arr.length);</span><br><span class="line">        <span class="keyword">return</span> copyArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中的两个索引的位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 整形数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   第一个索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j   第二个索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 整形数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sort函数式接口"><a href="#Sort函数式接口" class="headerlink" title="Sort函数式接口"></a>Sort函数式接口</h2><blockquote>
<p>一个基于 JDK8 Lambda 特性的函数式接口，所以该排序算法环境的搭建基于 JDK8+ 的版本。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SortRunner"><a href="#SortRunner" class="headerlink" title="SortRunner"></a>SortRunner</h2><blockquote>
<p>SortRunner 中有用于运行 Sort 函数式接口的方法，可以在该类的方法下编写一些特定的操作，用于辅助排序算法编写和测试。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行排序算法的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr  一个数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sort Sort函数式接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span>[] arr, Sort sort)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;数组排序前：&quot;</span>);</span><br><span class="line">        SortUtils.printArray(arr);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        sort.sort(arr);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (SortUtils.isOrderly(arr)) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;数组排序后：&quot;</span>);</span><br><span class="line">            SortUtils.printArray(arr);</span><br><span class="line">            System.out.println(<span class="string">&quot;数组排序所需时间为：&quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组排序失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="普通冒泡排序"><a href="#普通冒泡排序" class="headerlink" title="普通冒泡排序"></a>普通冒泡排序</h2><p>普通的冒泡排序是把相邻的元素两两比较，直到所有元素都比较结束为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;普通冒泡排序&quot;</span>);</span><br><span class="line">SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">        (arr) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        SortUtils.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>这是最为常见的冒泡排序，编写简单，易于理解，但是在一些特殊情况下，可能会浪费一些性能。</p>
<p>比如排序到 n - i 轮的时候，这是遍历数组，发现数组已经有序了，剩下的 i -1 轮其实已经可以不进行遍历了。</p>
<p>所以我们可以对冒泡排序进行一些优化。</p>
<h2 id="布尔类型变量判断有序"><a href="#布尔类型变量判断有序" class="headerlink" title="布尔类型变量判断有序"></a>布尔类型变量判断有序</h2><p>这种冒泡排序的思想是，在每一轮遍历数组前，设置一个变量用于标识数组有序，如果在该轮中，数组相邻的元素之间发生了交换，则说明此时数组仍处于无序状态，反之则有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 布尔类型变量判断有序优化冒泡排序</span></span><br><span class="line">System.out.println(<span class="string">&quot;布尔类型变量判断有序优化冒泡排序&quot;</span>);</span><br><span class="line">SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">        (arr) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isSorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        SortUtils.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                        isSorted = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="无序边界值"><a href="#无序边界值" class="headerlink" title="无序边界值"></a>无序边界值</h2><p>布尔类型变量判断有序优化冒泡排序，本质上是减少了冒泡排序的轮数，可以让冒泡排序轮询 &lt;= n - 1 次，但是对于每一轮交换的元素个数，依然是固定的。</p>
<p>但是有的时候，每一轮交换元素的时候，可能交换 n - i 次，数组后段的元素其实就已经有序了，这时继续向后遍历比较是无用的。</p>
<p>所以为了解决这种情况，可以使用无序边界来优化冒泡排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无序边界值优化冒泡排序</span></span><br><span class="line">System.out.println(<span class="string">&quot;无序边界值优化冒泡排序&quot;</span>);</span><br><span class="line">SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">        (arr) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastExchangeIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sortBorder</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isSorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        SortUtils.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                        isSorted = <span class="literal">false</span>;</span><br><span class="line">                        lastExchangeIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sortBorder = lastExchangeIndex;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>在一些特殊情况下，比如对一些近似有序的数组进行排序的时候，可以考虑用鸡尾酒排序来对数据进行排序。</p>
<p>鸡尾酒排序的思想是：在冒泡排序比较元素和交换的过程中，使用双向遍历比较和交换元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鸡尾酒排序</span></span><br><span class="line">System.out.println(<span class="string">&quot;鸡尾酒排序&quot;</span>);</span><br><span class="line">SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">        (arr) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 奇数轮，从左往右排序</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isSorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        SortUtils.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                        isSorted = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偶数轮，从右往左毕竟</span></span><br><span class="line">                isSorted = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - i - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        SortUtils.swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">                        isSorted = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="左右无序边界值"><a href="#左右无序边界值" class="headerlink" title="左右无序边界值"></a>左右无序边界值</h2><blockquote>
<p>鸡尾酒排序同样可以使用无序边界值的方法对算法进行优化，不过因为鸡尾酒排序是双向的，所以无序值也是有左右两个。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左右无序边界值优化鸡尾酒排序</span></span><br><span class="line">System.out.println(<span class="string">&quot;左右无序边界值优化鸡尾酒排序&quot;</span>);</span><br><span class="line">SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">100000</span>),</span><br><span class="line">        (arr) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 左边最后进行元素交换的索引位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftExchangeIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 左边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftSortBorder</span> <span class="operator">=</span> leftExchangeIndex;</span><br><span class="line">            <span class="comment">// 右边最后进行元素交换的索引位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightExchangeIndex</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 右边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightSortBorder</span> <span class="operator">=</span> rightExchangeIndex;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 奇数轮，从左往右排序</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isSorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; rightSortBorder; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        SortUtils.swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                        isSorted = <span class="literal">false</span>;</span><br><span class="line">                        rightExchangeIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                rightSortBorder = rightExchangeIndex;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 偶数轮，从右往左毕竟</span></span><br><span class="line">                isSorted = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - i - <span class="number">1</span>; j &gt; leftSortBorder; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        SortUtils.swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">                        isSorted = <span class="literal">false</span>;</span><br><span class="line">                        leftExchangeIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                leftSortBorder = leftExchangeIndex;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>


<h2 id="鸡尾酒排序的效率"><a href="#鸡尾酒排序的效率" class="headerlink" title="鸡尾酒排序的效率"></a>鸡尾酒排序的效率</h2><p>数组长度：100000</p>
<table>
<thead>
<tr>
<th></th>
<th>冒泡排序</th>
<th>鸡尾酒排序</th>
</tr>
</thead>
<tbody><tr>
<td>无序数组</td>
<td>27412毫秒</td>
<td>12868毫秒</td>
</tr>
<tr>
<td>近似有序</td>
<td>13962毫秒</td>
<td>43毫秒</td>
</tr>
</tbody></table>
<blockquote>
<p>以上的测试数据仅仅为简单测试，具体情况请自行测试，另外，如果排序数组长度过长，建议修改 SortRunner.run() 方法，去掉一些无用的操作步骤，减少排序测试的总体时长</p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之计数排序</title>
    <url>/2021/04/18/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="什么是计数排序"><a href="#什么是计数排序" class="headerlink" title="什么是计数排序"></a>什么是计数排序</h1><p>计数排序是一种利用数组下标来确定元素的正确位置的排序算法。</p>
<span id="more"></span>

<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>1、根据数组中最大的元素的值 length，创建一个额外的长度为 length + 1 的数组，该数组的初始值均为 0。</p>
<p>2、遍历原数组，通过原数组的值，找到新开辟的数组的位置，将该位置的元素值进行 +1 操作。</p>
<p>3、遍历新数组，新数组中，下标标索引代表了原数组的元素的值，下标索引对应的值代表了原数组的元素出现的次数。</p>
<h3 id="计数排序的基本实现"><a href="#计数排序的基本实现" class="headerlink" title="计数排序的基本实现"></a>计数排序的基本实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">1000</span>),</span><br><span class="line">            (arr) -&gt; &#123;</span><br><span class="line">                countSort(arr);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计每个元素的个数</span></span><br><span class="line">    <span class="type">int</span>[] countArray = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArray[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过元素个数，输入所有元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countArray[i]; j++) &#123;</span><br><span class="line">            arr[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数排序优化"><a href="#计数排序优化" class="headerlink" title="计数排序优化"></a>计数排序优化</h3><p>在上述的计数排序中，有一个问题，就是原数组的最小值是 100，最大值是 1000，而用于计数的数组长度开辟为 length + 1，这样一来，计数数组 0-99 的索引空间就被浪费了。</p>
<p>所以可以对计数排序进行一些优化，获取数组的最小值，作为计数数组的偏移量，用于计算整数在计数数组中的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">1000</span>),</span><br><span class="line">            (arr) -&gt; &#123;</span><br><span class="line">                countSort(arr);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计每个元素的个数</span></span><br><span class="line">    <span class="type">int</span>[] countArray = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArray[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过元素个数，输入所有元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countArray[i]; j++) &#123;</span><br><span class="line">            arr[index++] = i + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><p>什么是稳定排序？</p>
<p>稳定排序是指，在需要排序的元素之中，值相同的元素可以保持原本的相对位置，这种排序就被称作稳定排序。</p>
<p>上述的计数排序并不是稳定排序，可以通过再次进行优化，而使计数排序变成一种稳定排序。</p>
<p>为了使计数排序变成稳定排序，需要对计数数组进行变形，从计数数组的第二个元素开始，每一个元素都加上前面所有元素之和。</p>
<p>这样做的目的是使得计数数组的元素值，由原本对应的整数的个数，变成对应整数的最终排序的序号。</p>
<p>计数数组变形之和，从后往前遍历原数组，将原数组找到计数数组的值，从而将元素放入一个新的数组中，并将计数数组对应的值 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SortRunner.run(SortUtils.generateRandomArray(<span class="number">10000</span>, <span class="number">100</span>, <span class="number">1000</span>),</span><br><span class="line">            (arr) -&gt; &#123;</span><br><span class="line">                countSort(arr);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计每个元素的个数</span></span><br><span class="line">    <span class="type">int</span>[] countArray = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArray[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 变形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">        countArray[i] += countArray[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] sortArray = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 获取排序的序号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sort</span> <span class="operator">=</span> countArray[arr[i] - min];</span><br><span class="line">        <span class="comment">// 索引 = 序号-1</span></span><br><span class="line">        sortArray[sort - <span class="number">1</span>] = arr[i];</span><br><span class="line">        countArray[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(sortArray, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数排序的复杂度"><a href="#计数排序的复杂度" class="headerlink" title="计数排序的复杂度"></a>计数排序的复杂度</h2><p>元素数组的规模为 n，最大和最小整数的差值是 m，则计数排序的时间复杂度和空间复杂度为：</p>
<p>时间复杂度为：O(n+m)</p>
<p>空间复杂度为：O(m)</p>
<h2 id="计数排序的局限性"><a href="#计数排序的局限性" class="headerlink" title="计数排序的局限性"></a>计数排序的局限性</h2><p>计数排序的速度非常快，但是有一定的局限性。</p>
<p>1、当原始数组的规模最大值和最小值差距过大时，计数排序并不适用，因为差值过大的时候，会严重浪费空间，而且计数数组过大，也会增加时间复杂度。</p>
<p>2、当原始数组的值不是整数的时候，也不适用计数排序，因为计数排序需要通过值来找到对应的索引，而小数找不到对应的索引。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-排序算法辅助工具编写与三种基本排序算法（Java实现）</title>
    <url>/2020/01/11/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E7%BC%96%E5%86%99%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<p>初学者刚刚接触算法的时候，可以通过编写一些辅助的工具来辅助算法的学习。</p>
<span id="more"></span>

<h1 id="一、排序算法辅助工具类"><a href="#一、排序算法辅助工具类" class="headerlink" title="一、排序算法辅助工具类"></a>一、排序算法辅助工具类</h1><h2 id="1-随机生成一个整形数组"><a href="#1-随机生成一个整形数组" class="headerlink" title="1. 随机生成一个整形数组"></a>1. 随机生成一个整形数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     随机生成一个整形数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size        数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rangeL    数组左边范围（包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rangeR    数组右边范围（包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generateRandomArray(<span class="type">int</span> size,<span class="type">int</span> rangeL,<span class="type">int</span> rangeR) &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">        arr[i] = (<span class="type">int</span>) (Math.random() * (rangeR-rangeL+<span class="number">1</span>)) + rangeL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-生成一个近乎有序的整形数组"><a href="#2-生成一个近乎有序的整形数组" class="headerlink" title="2. 生成一个近乎有序的整形数组"></a>2. 生成一个近乎有序的整形数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个近乎有序的整形数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size        数组大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> swapTimes    将有序数组打乱次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generateAlmostOrderlyArray(<span class="type">int</span> size,<span class="type">int</span> swapTimes) &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; swapTimes;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> (<span class="type">int</span>) Math.random()*size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> (<span class="type">int</span>) Math.random()*size;</span><br><span class="line">        swap(arr,index1,index2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-判断一个数组是否正反皆有序"><a href="#3-判断一个数组是否正反皆有序" class="headerlink" title="3. 判断一个数组是否正反皆有序"></a>3. 判断一个数组是否正反皆有序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个数组是否有序，有序返回true，无序返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    整形数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOrderly</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(isOrderAsc(arr) || isOrderDesc(arr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个数组是否顺序有序，有序返回true，无序返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOrderAsc</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个数组是否倒序有序，有序返回true，无序返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOrderDesc</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-拷贝一个整形数组"><a href="#4-拷贝一个整形数组" class="headerlink" title="4. 拷贝一个整形数组"></a>4. 拷贝一个整形数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝一个整形数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    整形数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyIntArray(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span>[] copyArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length; i++) &#123;</span><br><span class="line">        copyArr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-交换数组中的两个索引的位置"><a href="#5-交换数组中的两个索引的位置" class="headerlink" title="5. 交换数组中的两个索引的位置"></a>5. 交换数组中的两个索引的位置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组中的两个索引的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    整形数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i        第一个索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j        第二个索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-打印数组"><a href="#6-打印数组" class="headerlink" title="6. 打印数组"></a>6. 打印数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     打印数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    整形数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、三种基本排序算法"><a href="#二、三种基本排序算法" class="headerlink" title="二、三种基本排序算法"></a>二、三种基本排序算法</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    整形数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length-<span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j+<span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                SortTestUtils.swap(arr, j+<span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> *         -选择一个最小的数，插入最左边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    整形数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; arr.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SortTestUtils.swap(arr, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> *         -随机选一个数，插入到合适的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    整形数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = i;j &gt; <span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; insertValue; j--) &#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = insertValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
        <tag>数据结构</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——栈与队列（Java实现）</title>
    <url>/2020/02/14/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="什么是栈与队列？"><a href="#什么是栈与队列？" class="headerlink" title="什么是栈与队列？"></a>什么是栈与队列？</h1><ul>
<li>栈是一种特殊的线性表结构，数据在栈中，只能从栈顶进入，也只能从栈顶弹出，具有<strong>先进后出</strong>的特点。</li>
<li>队列也是一种特殊的线性表结构，数据在队列中，只能从队列的最后存入队列，数据移出只能从队列的最前面取出，具有<strong>先进先出，后进后出</strong>的特点。<span id="more"></span>
【<strong>循环队列</strong>】循环队列是一种特殊的队列，在满足普通队列的基础上，解决了普通队列因为取出数据而造成空间浪费的情况，它维护了队列的队首和队尾索引，使索引在越界时能够从新返回初始化。</li>
</ul>
<h2 id="栈的实现（Java）"><a href="#栈的实现（Java）" class="headerlink" title="栈的实现（Java）"></a>栈的实现（Java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     数据栈，Java实现</span></span><br><span class="line"><span class="comment"> *         数据栈是一种特殊的线性表结构，</span></span><br><span class="line"><span class="comment"> *         所有数据只能从栈顶插入，也只能从栈顶取出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hrp</span></span><br><span class="line"><span class="comment"> * 2020年2月14日 上午11:33:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     指定栈的大小，初始化栈</span></span><br><span class="line"><span class="comment">     *         maxSize：栈的最大容量</span></span><br><span class="line"><span class="comment">     *         top：栈顶数据的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = size;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="built_in">this</span>.top = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     压栈，将数据从栈顶压入栈中，维护top索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[++top] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     弹出，将数据中栈顶弹出，维护top索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[top--];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     判断栈是否为空，直接比较top==-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     判断栈是否满了，直接比较top==(maxSize-1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     打印栈，循环次数为top+1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环队列的实现（Java）"><a href="#循环队列的实现（Java）" class="headerlink" title="循环队列的实现（Java）"></a>循环队列的实现（Java）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *     循环队列，Java实现</span></span><br><span class="line"><span class="comment"> *         队列是一种特殊的线性表结构，</span></span><br><span class="line"><span class="comment"> *         它只允许在表的前端进行删除操作，在表的后端进行添加操作 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hrp</span></span><br><span class="line"><span class="comment"> * 2020年2月14日 上午10:46:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> elems;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> font;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     指定队列的大小，初始化队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = size;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="built_in">this</span>.elems = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.font = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.end = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     插入操作，如果此时end索引已经到达最后了，将索引维护为-1，在执行插入操作</span></span><br><span class="line"><span class="comment">     *         同时判断队列是否满了，如果队列未满，则elems++，如果满了，则覆盖最前面的值，font++</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(end == maxSize - <span class="number">1</span>) &#123;</span><br><span class="line">            end = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++end] = value;</span><br><span class="line">        <span class="keyword">if</span>(elems &lt; maxSize) &#123;</span><br><span class="line">            elems++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            font++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     移除操作，先判断font是否已经超出了数组索引范围，是则重新维护索引</span></span><br><span class="line"><span class="comment">     *         首先队列长度elems--，并将font索引是指返回，同时维护索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(font == maxSize) &#123;</span><br><span class="line">            font = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elems--;</span><br><span class="line">        <span class="keyword">return</span> arr[font++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     判断队列是否为空，直接比较队列的elems属性是否为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elems == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     判断队列是否满了，直接比较队列的elems属性和MaxSize的值是否相等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elems == maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     打印队列，已知循环次数为队列长度，打印次数为elems</span></span><br><span class="line"><span class="comment">     *         注意：不应该直接使用font作为数组索引进行打印，</span></span><br><span class="line"><span class="comment">     *         因为在++过程中会破坏数组font索引的正确性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> font;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elems; i++) &#123;</span><br><span class="line">            System.out.print(arr[index++]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(index == maxSize) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法——希尔排序（Java实现）</title>
    <url>/2020/02/18/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<p>希尔排序是插入排序的一个变种排序算法，由D.L.Shell在1959年提出，所以命名为希尔排序。</p>
<span id="more"></span>
<p>插入排序是一个时间复杂度为O(n^2)级别的不稳定的排序算法，之所以说它的不稳定的，是因为插入排序在处理近乎有序的数组的时候，排序效率会非常快，而在处理完全无序的数组的时候，排序效率则为N平方级别。<br>希尔排序就是为了解决插入排序在处理完全无序的数组时效率过慢而诞生的优秀算法。<br>希尔排序是思想是，在插入排序的基础上，对插入数组的索引的间隔进行扩大，这个间隔大小为 h。<br>h的最小值为1，最大值为h*3+1小于数组长度。</p>
<ul>
<li>希尔排序（Java实现）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellsort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((h*<span class="number">3</span>+<span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">        h = h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(j = i; j &gt; h-<span class="number">1</span> &amp;&amp; arr[j-h] &gt; insertValue; j = j-h ) &#123;</span><br><span class="line">                arr[j] = arr[j-h];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = insertValue;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h-<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之什么是二叉堆？</title>
    <url>/2021/03/06/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    <content><![CDATA[<h1 id="什么是二叉堆？"><a href="#什么是二叉堆？" class="headerlink" title="什么是二叉堆？"></a>什么是二叉堆？</h1><p>二叉堆本质上是一种完全二叉树，它分为两个类型：</p>
<ul>
<li>最大堆</li>
<li>最小堆<span id="more"></span>

</li>
</ul>
<p>什么是最大堆？</p>
<p>最大堆的任何一个父节点的值，都大于或等于它的左、右孩子节点的值。</p>
<p>什么是最小堆？</p>
<p>最小堆的任何一个父节点的值，都小于或等于它的左、右孩子节点的值。</p>
<p>二叉堆的根节点叫做堆顶。<br>最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素，最小堆的堆顶是整个堆中的最小元素。</p>
<h1 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h1><p>二叉堆的操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整为一个堆。</p>
<blockquote>
<p>本篇文章中是以最小堆为例子讲述的。</p>
</blockquote>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>当二叉堆插入节点时，插入的位置是二叉堆的最后一个位置，可以将新插入的节点和它的父节点进行对比，如果新节点比父节点小，就需要让新节点“<strong>上浮</strong>”，和父节点交换位置。</p>
<p>然后继续和父节点比较大小，直到父节点比当前节点的值小为止。</p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>当二叉堆删除节点时，所删除的节点是对于堆顶的节点。</p>
<p>然后将堆的最后一个节点补到堆顶的位置，然后对堆顶的位置的节点进行“<strong>下沉</strong>”操作</p>
<h1 id="构建二叉堆"><a href="#构建二叉堆" class="headerlink" title="构建二叉堆"></a>构建二叉堆</h1><p>构建二叉堆，是通过一个无序的完全二叉树，对所有非叶子节点进行依次“下沉”操作，这样就得到了一个最小二叉堆。</p>
<h2 id="最小二叉堆的实现"><a href="#最小二叉堆的实现" class="headerlink" title="最小二叉堆的实现"></a>最小二叉堆的实现</h2><p>二叉堆虽然是一个完全二叉堆，但是它并不是链式存储，而是顺序存储，也就是说，二叉堆是通过数组实现的。</p>
<p>在数组中，在没有左、右孩子节点指针的情况下，可以通过数组下标的计算来得到一个节点的左右孩子节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="number">1</span></span><br><span class="line">     /   \</span><br><span class="line">    <span class="number">4</span>     <span class="number">8</span></span><br><span class="line">   /  \  / \</span><br><span class="line">  <span class="number">10</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">13</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">11</span>  <span class="number">19</span></span><br></pre></td></tr></table></figure>

<p>如上图中的最小堆，在数组中的存储位置为：</p>
<table>
<tr>
<td>1</td>
<td>4</td>
<td>8</td>
<td>10</td>
<td>7</td>
<td>9</td>
<td>13</td>
<td>11</td>
<td>19</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</table>

<p>如果一个节点的数组下标为<code>current</code>，则该节点的左孩子节点下标为<code>2 * current + 1</code>，该节点的右孩子节点下标为<code>2 * current + 2</code>，该节点的父节点下标为<code>(current - 1) / 2</code>。</p>
<h2 id="最小堆的构建"><a href="#最小堆的构建" class="headerlink" title="最小堆的构建"></a>最小堆的构建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存储二叉堆的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前二叉堆的最大节点个数，即数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前二叉堆的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的实际元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的实际元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小堆的构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        buildMinHeap(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建最小堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = arr.length;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = arr.length;</span><br><span class="line">        <span class="built_in">this</span>.array = arr;</span><br><span class="line">        <span class="comment">// 获取最后一个节点的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始进行下沉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getParentIndex(lastIndex); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            downAdjust(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过孩子节点下标，获取父节点下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> childIndex 孩子节点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 父节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> childIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过取余数的方式，直接获取左右孩子节点的父节点</span></span><br><span class="line">        <span class="keyword">return</span> (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过父节点下标，获取左孩子节点下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 父节点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 左孩子节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> parentIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过父节点下标，获取右孩子节点下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 父节点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 右孩子节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> parentIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * parentIndex + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小堆插入节点并上浮"><a href="#最小堆插入节点并上浮" class="headerlink" title="最小堆插入节点并上浮"></a>最小堆插入节点并上浮</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在堆的末尾插入一个数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxSize) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.array[<span class="built_in">this</span>.size++] = data;</span><br><span class="line">    upAdjust();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扩容操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新数组的长度为原数组的2倍</span></span><br><span class="line">    <span class="built_in">this</span>.maxSize = <span class="built_in">this</span>.maxSize * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 初始化新数组</span></span><br><span class="line">    Integer[] newArray = <span class="keyword">new</span> <span class="title class_">Integer</span>[maxSize];</span><br><span class="line">    <span class="comment">// 将原数组的元素复制到新数组中</span></span><br><span class="line">    System.arraycopy(<span class="built_in">this</span>.array, <span class="number">0</span>, newArray, <span class="number">0</span>, <span class="built_in">this</span>.size);</span><br><span class="line">    <span class="comment">// 使用新数组替换原数组</span></span><br><span class="line">    <span class="built_in">this</span>.array = newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上浮操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">upAdjust</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数组最后一个节点所在的下标，即需要上浮的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.size - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parentIndex</span> <span class="operator">=</span> getParentIndex(currentIndex);</span><br><span class="line">    <span class="comment">// 将当前孩子节点使用临时变量保存</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.array[currentIndex];</span><br><span class="line">    <span class="comment">// 如果当前孩子节点的下标大于0，并且当前孩子节点的值小于父节点的值</span></span><br><span class="line">    <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; <span class="built_in">this</span>.array[parentIndex]) &#123;</span><br><span class="line">        <span class="comment">// 将父节点的值和当前孩子节点的值进行交换</span></span><br><span class="line">        <span class="built_in">this</span>.array[currentIndex] = <span class="built_in">this</span>.array[parentIndex];</span><br><span class="line">        <span class="comment">// 将当前孩子节点的值修改为之前的父节点的值</span></span><br><span class="line">        currentIndex = parentIndex;</span><br><span class="line">        <span class="comment">// 维护父节点的下标</span></span><br><span class="line">        parentIndex = getParentIndex(currentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.array[currentIndex] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="最小堆删除节点并下沉"><a href="#最小堆删除节点并下沉" class="headerlink" title="最小堆删除节点并下沉"></a>最小堆删除节点并下沉</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除堆顶的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 堆顶的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">removeData</span> <span class="operator">=</span> <span class="built_in">this</span>.array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="built_in">this</span>.array[<span class="number">0</span>] = <span class="built_in">this</span>.array[size - <span class="number">1</span>];</span><br><span class="line">    downAdjust(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">this</span>.array[--size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> removeData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下沉操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 需要下沉的节点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">downAdjust</span><span class="params">(<span class="type">int</span> parentIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取左孩子节点的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getLeftChildIndex(parentIndex);</span><br><span class="line">    <span class="comment">// 将需要下沉的节点使用临时变量保存</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.array[parentIndex];</span><br><span class="line">    <span class="comment">// 如果左孩子节点的下标还在堆的有效个数之内，</span></span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; <span class="built_in">this</span>.size) &#123;</span><br><span class="line">        <span class="comment">// 右孩子节点为左孩子节点的下一位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightChildIndex</span> <span class="operator">=</span> childIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果有右孩子节点，并右孩子节点比左孩子节点的值小，则定位到右孩子节点</span></span><br><span class="line">        <span class="keyword">if</span> (rightChildIndex &lt; <span class="built_in">this</span>.size &amp;&amp; <span class="built_in">this</span>.array[rightChildIndex] &lt; <span class="built_in">this</span>.array[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果需要下沉的节点小于孩子节点中最小的那个节点的值，直接打断程序，不继续下沉</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= <span class="built_in">this</span>.array[childIndex]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调换父子节点的值</span></span><br><span class="line">        <span class="built_in">this</span>.array[parentIndex] = <span class="built_in">this</span>.array[childIndex];</span><br><span class="line">        <span class="comment">// 将父节点的下标修改为子节点的下标</span></span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        <span class="comment">// 维护左孩子节点的下标</span></span><br><span class="line">        childIndex = getLeftChildIndex(parentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小堆的完整代码实现"><a href="#最小堆的完整代码实现" class="headerlink" title="最小堆的完整代码实现"></a>最小堆的完整代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存储二叉堆的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前二叉堆的最大节点个数，即数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前二叉堆的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的实际元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的实际元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小堆的构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        buildMinHeap(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建最小堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMinHeap</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = arr.length;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = arr.length;</span><br><span class="line">        <span class="built_in">this</span>.array = arr;</span><br><span class="line">        <span class="comment">// 获取最后一个节点的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始进行下沉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getParentIndex(lastIndex); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            downAdjust(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在堆的末尾插入一个数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= maxSize) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.array[<span class="built_in">this</span>.size++] = data;</span><br><span class="line">        upAdjust();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组扩容操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新数组的长度为原数组的2倍</span></span><br><span class="line">        <span class="built_in">this</span>.maxSize = <span class="built_in">this</span>.maxSize * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 初始化新数组</span></span><br><span class="line">        Integer[] newArray = <span class="keyword">new</span> <span class="title class_">Integer</span>[maxSize];</span><br><span class="line">        <span class="comment">// 将原数组的元素复制到新数组中</span></span><br><span class="line">        System.arraycopy(<span class="built_in">this</span>.array, <span class="number">0</span>, newArray, <span class="number">0</span>, <span class="built_in">this</span>.size);</span><br><span class="line">        <span class="comment">// 使用新数组替换原数组</span></span><br><span class="line">        <span class="built_in">this</span>.array = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">upAdjust</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 数组最后一个节点所在的下标，即需要上浮的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.size - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parentIndex</span> <span class="operator">=</span> getParentIndex(currentIndex);</span><br><span class="line">        <span class="comment">// 将当前孩子节点使用临时变量保存</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.array[currentIndex];</span><br><span class="line">        <span class="comment">// 如果当前孩子节点的下标大于0，并且当前孩子节点的值小于父节点的值</span></span><br><span class="line">        <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; <span class="built_in">this</span>.array[parentIndex]) &#123;</span><br><span class="line">            <span class="comment">// 将父节点的值和当前孩子节点的值进行交换</span></span><br><span class="line">            <span class="built_in">this</span>.array[currentIndex] = <span class="built_in">this</span>.array[parentIndex];</span><br><span class="line">            <span class="comment">// 将当前孩子节点的值修改为之前的父节点的值</span></span><br><span class="line">            currentIndex = parentIndex;</span><br><span class="line">            <span class="comment">// 维护父节点的下标</span></span><br><span class="line">            parentIndex = getParentIndex(currentIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.array[currentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除堆顶的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">removeData</span> <span class="operator">=</span> <span class="built_in">this</span>.array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取最后一个节点</span></span><br><span class="line">        <span class="built_in">this</span>.array[<span class="number">0</span>] = <span class="built_in">this</span>.array[size - <span class="number">1</span>];</span><br><span class="line">        downAdjust(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.array[--size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> removeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 需要下沉的节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">downAdjust</span><span class="params">(<span class="type">int</span> parentIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取左孩子节点的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getLeftChildIndex(parentIndex);</span><br><span class="line">        <span class="comment">// 将需要下沉的节点使用临时变量保存</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.array[parentIndex];</span><br><span class="line">        <span class="comment">// 如果左孩子节点的下标还在堆的有效个数之内，</span></span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; <span class="built_in">this</span>.size) &#123;</span><br><span class="line">            <span class="comment">// 右孩子节点为左孩子节点的下一位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightChildIndex</span> <span class="operator">=</span> childIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果有右孩子节点，并右孩子节点比左孩子节点的值小，则定位到右孩子节点</span></span><br><span class="line">            <span class="keyword">if</span> (rightChildIndex &lt; <span class="built_in">this</span>.size &amp;&amp; <span class="built_in">this</span>.array[rightChildIndex] &lt; <span class="built_in">this</span>.array[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果需要下沉的节点小于孩子节点中最小的那个节点的值，直接打断程序，不继续下沉</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt;= <span class="built_in">this</span>.array[childIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调换父子节点的值</span></span><br><span class="line">            <span class="built_in">this</span>.array[parentIndex] = <span class="built_in">this</span>.array[childIndex];</span><br><span class="line">            <span class="comment">// 将父节点的下标修改为子节点的下标</span></span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            <span class="comment">// 维护左孩子节点的下标</span></span><br><span class="line">            childIndex = getLeftChildIndex(parentIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.array[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过孩子节点下标，获取父节点下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> childIndex 孩子节点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 父节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getParentIndex</span><span class="params">(<span class="type">int</span> childIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过取余数的方式，直接获取左右孩子节点的父节点</span></span><br><span class="line">        <span class="keyword">return</span> (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过父节点下标，获取左孩子节点下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 父节点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 左孩子节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLeftChildIndex</span><span class="params">(<span class="type">int</span> parentIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过父节点下标，获取右孩子节点下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 父节点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 右孩子节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRightChildIndex</span><span class="params">(<span class="type">int</span> parentIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * parentIndex + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之什么是数组？</title>
    <url>/2021/02/23/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a>什么是数组？</h1><p>数组对应的英文是array，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。</p>
<span id="more"></span>

<ul>
<li>数组的每一个元素都有自己的下标，该下标从0开始，一直到数组长度-1结束。</li>
<li>数组在内容中是顺序存储，在内存中的表现形式为一整块完整的内存空间。</li>
<li>数组的特点，有限个数，相同类型，有序。</li>
</ul>
<h1 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h1><p>数组的基本操作，无非就是增、删、改、查四种情况。</p>
<h2 id="查——读取元素"><a href="#查——读取元素" class="headerlink" title="查——读取元素"></a>查——读取元素</h2><p>对于数组来说，读取元素是最为简单的操作。由于数组在内存中顺序存储，所以只需要给出一个数组下标，就可以读取到对应的数组元素。</p>
<p>这种通过数组下标读取元素的方式叫做<strong>随机读取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 输出下标为2的数组元素，即数组的第三个元素，4</span></span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="改——更新元素"><a href="#改——更新元素" class="headerlink" title="改——更新元素"></a>改——更新元素</h2><p>把数组的某一个元素替换为一个新值，也是非常简单的事情，直接利用数组的下标，就可以把新值赋给该元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 输出赋值前，下标为4的数组元素，值为：1</span></span><br><span class="line">System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 赋值，改变数组元素的值</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 输出赋值后，下标为4的数组元素，值为：10</span></span><br><span class="line">System.out.println(arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="增——插入元素"><a href="#增——插入元素" class="headerlink" title="增——插入元素"></a>增——插入元素</h2><p>数组的插入元素操作是一个比较复杂的操作，因为涉及数组元素个数的变动，所以在介绍插入元素操作之前，需要先介绍一下数组的长度和数组的实际元素个数。</p>
<p>数组的长度：即数组初始化时开辟的内存空间大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开辟了一个数组长度为5的数组内存空间</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>数组的实际元素个数：即数组中存在的元素个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开辟了一个数组长度为5的数组内存空间</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">    <span class="comment">// 输出：2 8 0 0 0，数组的实际元素个数为2</span></span><br><span class="line">    System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的数组中，实际的元素个数只有两个，即下标为0、1的两个元素，其他元素之所以输出为0，是因为在Java中，int类型的初始化值为0，所以输出的数组为<code>2 8 0 0 0</code>，如果使用<code>Integer</code>类型的数组，则可以通过<code>null</code>值进行更直观的判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开辟了一个数组长度为5，类型为Integer的数组内存空间</span></span><br><span class="line">Integer[] array = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">5</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer integer : array) &#123;</span><br><span class="line">    <span class="comment">// 输出：2	8	null	null	null，数组的实际元素个数为2</span></span><br><span class="line">    System.out.print(integer + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是因为存在数组的长度和实际元素个数不同的情况，所以在一般情况下，我们会使用一个变量来记录数组的实际元素个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组的最大元素个数，即为数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组的实际元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 初始化数组的容量大小，即maxSize大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Array</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数组长度</span></span><br><span class="line">        <span class="built_in">this</span>.maxSize = capacity;</span><br><span class="line">        <span class="comment">// 初始化数组，开辟数组空间</span></span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="comment">// 初始化数组实际元素个数，为0</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的实际元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的实际元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要通过创建Array类的对象的方式，即可完成一个数组的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 数组的实际元素个数为：0</span></span><br><span class="line">System.out.println(array.size());</span><br><span class="line"><span class="comment">// 数组长度为：5</span></span><br><span class="line">System.out.println(array.length());</span><br></pre></td></tr></table></figure>

<p>这个时候，数组的插入插入操作即可以开始了。</p>
<p>数组的插入操作也分为三种，分别为：</p>
<ul>
<li>尾部插入  </li>
<li>中间插入，头部插入本质上也属于中间插入的一种</li>
<li>超范围插入</li>
</ul>
<p>尾部插入最为简单，只需要将元素放置在数组尾部的空闲元素的位置上即可。</p>
<p>中间插入较为复杂，因为在数组中间位置插入元素，需要先将插入位置及插入位置后面的元素向后移动，空出一个数组下标给插入的元素。</p>
<p>超范围插入最为复杂，因为超范围插入涉及到了数组的扩容。</p>
<h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>为什么需要数组扩容？</p>
<p>我们不断往一个数组中插入元素，最终数组实际元素个数等于，甚至大于数组长度，这个时候数组已经无法容纳更多的元素了，所以我们需要通过扩容在扩大数组的容量。</p>
<p>怎么扩容？</p>
<p>数组的长度在初始化的时候就已经固定了，这也是数组有限个数的特点，如果如果想要对数组进行扩容，就需要创建一个容量比原数组更大的新数组，并将原数组的元素复制到新数组中，实现原数组的替换操作。</p>
<p>所以数组的插入操作的具体代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接在数组尾部插入元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 需要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">    add(<span class="built_in">this</span>.size, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在数组指定位置插入元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index   数组指定的下标位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 需要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="comment">// 这样操作的目的是为了保证数组的元素全部都可以从0开始，并且中间不会出现空闲元素</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入元素的位置超出数组的实际元素范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前数组实际元素个数大于等于数组长度，进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxSize) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从下标index开始将元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array[i] = <span class="built_in">this</span>.array[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在index位置插入需要插入的元素</span></span><br><span class="line">    <span class="built_in">this</span>.array[index] = element;</span><br><span class="line">    <span class="comment">// 数组实际元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容操作，每次扩容，新数组的长度为原数组的2倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新数组的长度为原数组的2倍</span></span><br><span class="line">    <span class="built_in">this</span>.maxSize = <span class="built_in">this</span>.maxSize * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 初始化新数组</span></span><br><span class="line">    <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    <span class="comment">// 将原数组的元素复制到新数组中</span></span><br><span class="line">    System.arraycopy(<span class="built_in">this</span>.array, <span class="number">0</span>, newArray, <span class="number">0</span>, <span class="built_in">this</span>.size);</span><br><span class="line">    <span class="comment">// 使用新数组替换原数组</span></span><br><span class="line">    <span class="built_in">this</span>.array = newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删——删除元素"><a href="#删——删除元素" class="headerlink" title="删——删除元素"></a>删——删除元素</h2><p>数组的删除操作比起插入元素来，比较简单一些，因为不涉及数组扩容的问题，我们只需要将数组被删除位置后面的元素向前移动即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除数组元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 需要删除的数组元素下标位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断需要删除的数组下标是否在数组实际元素范围之内</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除元素的位置超出数组的实际元素范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">deleteElement</span> <span class="operator">=</span> <span class="built_in">this</span>.array[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array[index] = <span class="built_in">this</span>.array[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> deleteElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="数组操作的时间复杂度"><a href="#数组操作的时间复杂度" class="headerlink" title="数组操作的时间复杂度"></a>数组操作的时间复杂度</h1><table>
<thead>
<tr>
<th>数组操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>读取元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>更新元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入元素</td>
<td>O(n)</td>
</tr>
<tr>
<td>删除元素</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h1 id="数组的优势和劣势"><a href="#数组的优势和劣势" class="headerlink" title="数组的优势和劣势"></a>数组的优势和劣势</h1><p>优势：数组拥有非常高效的随机访问能力，只需要通过下标，就可以用常量时间找到对应的元素。</p>
<p>劣势：数组在插入和删除的时候，需要移动大量元素，导致效率低下。</p>
<p>总结：数组适用于读操作多，写操作少的场景。</p>
<h1 id="数组的完整代码（Java）"><a href="#数组的完整代码（Java）" class="headerlink" title="数组的完整代码（Java）"></a>数组的完整代码（Java）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组的最大元素个数，即为数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组的实际元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 初始化数组的容量大小，即maxSize大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Array</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数组长度</span></span><br><span class="line">        <span class="built_in">this</span>.maxSize = capacity;</span><br><span class="line">        <span class="comment">// 初始化数组，开辟数组空间</span></span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="comment">// 初始化数组实际元素个数，为0</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的实际元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的实际元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数组的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下标对应的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下标对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断需要删除的数组下标是否在数组实际元素范围之内</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除元素的位置超出数组的实际元素范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新下标对应的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index   数组下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 需要更新的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断需要删除的数组下标是否在数组实际元素范围之内</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除元素的位置超出数组的实际元素范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.array[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接在数组尾部插入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 需要插入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">        add(<span class="built_in">this</span>.size, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在数组指定位置插入元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index   数组指定的下标位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 需要插入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">        <span class="comment">// 这样操作的目的是为了保证数组的元素全部都可以从0开始，并且中间不会出现空闲元素</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入元素的位置超出数组的实际元素范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前数组实际元素个数大于等于数组长度，进行扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= maxSize) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从下标index开始将元素向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--) &#123;</span><br><span class="line">            <span class="built_in">this</span>.array[i] = <span class="built_in">this</span>.array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在index位置插入需要插入的元素</span></span><br><span class="line">        <span class="built_in">this</span>.array[index] = element;</span><br><span class="line">        <span class="comment">// 数组实际元素个数+1</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容操作，每次扩容，新数组的长度为原数组的2倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新数组的长度为原数组的2倍</span></span><br><span class="line">        <span class="built_in">this</span>.maxSize = <span class="built_in">this</span>.maxSize * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 初始化新数组</span></span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="comment">// 将原数组的元素复制到新数组中</span></span><br><span class="line">        System.arraycopy(<span class="built_in">this</span>.array, <span class="number">0</span>, newArray, <span class="number">0</span>, <span class="built_in">this</span>.size);</span><br><span class="line">        <span class="comment">// 使用新数组替换原数组</span></span><br><span class="line">        <span class="built_in">this</span>.array = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数组元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要删除的数组元素下标位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断需要删除的数组下标是否在数组实际元素范围之内</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除元素的位置超出数组的实际元素范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleteElement</span> <span class="operator">=</span> <span class="built_in">this</span>.array[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.array[index] = <span class="built_in">this</span>.array[index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> deleteElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之什么是树？</title>
    <url>/2021/02/28/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91/</url>
    <content><![CDATA[<h1 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h1><p>数据结构中的树和现实生活中的树虽然不是同一种事物，但是却有着相同的特点。</p>
<p>数据结构中的树，其实就是一种和现实生活中的树有着相似结构的数据逻辑结构，从同一个“根”衍生出许多“枝干”，最后衍生出更多的“叶子”。</p>
<span id="more"></span>

<p>树的定义：</p>
<blockquote>
<p>树是n（你&gt;=0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。<br>1、有且仅有一个特定的称为根的节点。<br>2、当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">7</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">10</span>    <span class="number">8</span></span><br><span class="line"> /  \  /  \</span><br><span class="line"><span class="number">4</span>   <span class="number">1</span>  <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>根节点：树的最上面的那个节点，被称为<strong>根节点</strong>，所有非空树有且只有一个根节点。在上图中，元素<code>7</code>为根节点。</p>
</li>
<li><p>叶子节点：树的末端，没有“孩子”节点的节点被称作<strong>叶子节点</strong>。在上图中，元素<code>4、1、3、6</code>为叶子节点。</p>
</li>
<li><p>子树：树的非根节点，以及它的孩子节点，组成的树结构被称为<strong>子树</strong>。在上图中，由元素<code>10、4、1</code>组成的树结构为整棵树的子树。</p>
</li>
<li><p>树的高度：树的最大层级数，被称为树的高度或深度。在上图中，树的高度为<code>3</code>。</p>
</li>
<li><p>父节点：一个节点的上一层级的节点被称为当前节点的<strong>父节点</strong>。根节点没有父节点。在上图中，节点<code>10</code>是节点<code>4、1</code>的父节点。</p>
</li>
<li><p>孩子节点：一个节点的下一层级的节点被称为当前节点的<strong>孩子节点</strong>。叶子节点没有孩子节点。在上图中，节点<code>10</code>是节点<code>7</code>的孩子节点。</p>
</li>
<li><p>兄弟节点：一个节点同一层级的节点被称为当前节点的<strong>兄弟节点</strong>。所有节点都有n（n&gt;=0）个兄弟节点。在上图中，节点<code>8</code>是节点<code>10</code>的兄弟节点。</p>
</li>
</ul>
<h1 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h1><p>二叉树（binary tree）是数的一种特殊形式。二叉，顾名思义，这种数的每个节点最多有2个孩子节点。</p>
<blockquote>
<p>注意：这里是最多有2两个，可能只有1个节点，或者没有孩子节点。</p>
</blockquote>
<p>二叉树节点的两个孩子节点，一个被称为左孩子（lift child），一个被称为右孩子（right child）。这两个孩子节点的顺序是固定的，不能够颠倒或者混淆。</p>
<p>二叉树有两种特殊形式，分别叫做<strong>满二叉树</strong>和<strong>完全二叉树</strong>。</p>
<p>什么是满二叉树？</p>
<p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就叫做满二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  满二叉树</span><br><span class="line">     <span class="number">7</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">10</span>    <span class="number">8</span></span><br><span class="line"> /  \  /  \</span><br><span class="line"><span class="number">4</span>   <span class="number">1</span>  <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>什么是完全二叉树？</p>
<p>对于一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树的所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  完全二叉树</span><br><span class="line">     <span class="number">7</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">10</span>    <span class="number">8</span></span><br><span class="line"> /  \  /</span><br><span class="line"><span class="number">4</span>   <span class="number">1</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h1><p>二叉树的实现方法一般有两种，分别为：</p>
<ul>
<li>链式存储结构</li>
<li>数组</li>
</ul>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>链式存储结构实现二叉树，每个二叉树的节点拥有存储数据的data变量，同时有着指向左右孩子节点的指针变量，这样就可以简单实现二叉树的数据结构了。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树根节点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取二叉树的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过数组创建二叉树时数组的索引位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">createBinaryTreeByArrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过数组创建二叉树的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过数组构建二叉树，并保存二叉树根节点的指针</span></span><br><span class="line">        <span class="built_in">this</span>.root = createBinaryTree(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建二叉树的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root根节点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">createBinaryTree</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果数组为空，或者索引越界，则直接返回空的二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || createBinaryTreeByArrIndex &lt; <span class="number">0</span></span><br><span class="line">                || createBinaryTreeByArrIndex &gt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过索引获取数组对应位置的数据</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">data</span> <span class="operator">=</span> arr[createBinaryTreeByArrIndex++];</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果这个数据不为空，则创建节点，并返回</span></span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(data);</span><br><span class="line">            <span class="comment">// 数组的下一个节点为该节点的左孩子节点</span></span><br><span class="line">            node.leftChild = createBinaryTree(arr);</span><br><span class="line">            <span class="comment">// 数组的下一个节点为该节点的右孩子节点</span></span><br><span class="line">            node.rightChile = createBinaryTree(arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 二叉树节点存储节点数据的变量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Integer data;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 二叉树节点左孩子节点指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode leftChild;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 二叉树节点右孩子节点指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode rightChile;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取节点数据的方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 节点数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取节点左孩子节点指针的方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 节点左孩子节点指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> TreeNode <span class="title function_">leftChild</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取节点右孩子节点指针的方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 节点右孩子节点指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> TreeNode <span class="title function_">rightChile</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.rightChile;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data 节点数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TreeNode(Integer data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>使用数组存储时，会按照层级顺序把二叉树的节点放入数组中对应的位置上去。如果某一个节点的左孩子或者右孩子缺失，则数组对应的位置也会空出来。</p>
<p>其中二叉树的根节点存储在数组的第一位，即下标为0的位置。</p>
<p>如果一个二叉树的父节点下标为<code>parent</code>，则该节点的左孩子节点的下标即为<code>2*parent+1</code>，该节点的右孩子节点的下标为<code>2*parent+2</code>。</p>
<p>同理而言，一个左孩子节点的下标为<code>leftChild</code>，则该左孩子节点的父节点为<code>(leftChile-1)/2</code>。</p>
<p>如果一个右孩子节点的下标为<code>rightChild</code>，则该右孩子节点的父节点为<code>(rightChild-1)/2</code>。</p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>什么是二叉查找树？</p>
<p>二叉查找树是一种特殊的二叉树，这种树的主要作用是进行查找操作的。</p>
<ul>
<li><p>如果左子树不为空，则左子树上的所有节点的值均小于根节点的值。</p>
</li>
<li><p>如果右子树不为空，则右子树上的所有节点的值均大于根节点的值。</p>
</li>
<li><p>左右子树也都是二叉查找树。</p>
</li>
</ul>
<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>二叉树的遍历，从节点之间的位置关系角度来看，二叉树的遍历分为4种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后续遍历</li>
<li>层序遍历</li>
</ul>
<p>如果从宏观的角度来看，二叉树的遍历归结为两大类：</p>
<ul>
<li><p>深度优先遍历（前序遍历，中序遍历，后续遍历）</p>
</li>
<li><p>广度优先遍历（层序遍历）</p>
</li>
</ul>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>二叉树的前序遍历，输出顺序为根节点、左子树、右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">3</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">8</span></span><br><span class="line"> /  \     \</span><br><span class="line"><span class="number">9</span>   <span class="number">10</span>     <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>上述的二叉树中，前序遍历的输出循序为：<code>3、2、9、10、8、4</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(arr);</span><br><span class="line">    <span class="comment">// 获取二叉树的根节点</span></span><br><span class="line">    BinaryTree.<span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> binaryTree.root();</span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    preOrderTraveral(root);</span><br><span class="line">    System.out.println();</span><br><span class="line">    preOrderTraveralWithStack(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderTraveral</span><span class="params">(BinaryTree.TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(node.data() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    preOrderTraveral(node.leftChild());</span><br><span class="line">    preOrderTraveral(node.rightChile());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历，非递归</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderTraveralWithStack</span><span class="params">(BinaryTree.TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;BinaryTree.TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    BinaryTree.<span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (treeNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(treeNode.data() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            treeNode = treeNode.leftChild();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            treeNode = stack.pop();</span><br><span class="line">            treeNode = treeNode.rightChile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>二叉树的中序遍历，输出顺序为左子树、根节点、右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">3</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">8</span></span><br><span class="line"> /  \     \</span><br><span class="line"><span class="number">9</span>   <span class="number">10</span>     <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>上述的二叉树中，中序遍历的输出循序为：<code>9、2、10、3、8、4</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(arr);</span><br><span class="line">    <span class="comment">// 获取二叉树的根节点</span></span><br><span class="line">    BinaryTree.<span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> binaryTree.root();</span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    inOrderTraveral(root);</span><br><span class="line">    System.out.println();</span><br><span class="line">    inOrderTraveralWithStack(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderTraveral</span><span class="params">(BinaryTree.TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraveral(node.leftChild());</span><br><span class="line">    System.out.print(node.data() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    inOrderTraveral(node.rightChile());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历，非递归</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderTraveralWithStack</span><span class="params">(BinaryTree.TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;BinaryTree.TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    BinaryTree.<span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (treeNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            treeNode = treeNode.leftChild();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            treeNode = stack.pop();</span><br><span class="line">            System.out.print(treeNode.data() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            treeNode = treeNode.rightChile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>二叉树的后序遍历，输出顺序为左子树、右子树、根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">3</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">8</span></span><br><span class="line"> /  \     \</span><br><span class="line"><span class="number">9</span>   <span class="number">10</span>     <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>上述的二叉树中，后序遍历的输出循序为：<code>9、10、2、4、8、3</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(arr);</span><br><span class="line">    <span class="comment">// 获取二叉树的根节点</span></span><br><span class="line">    BinaryTree.<span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> binaryTree.root();</span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    postOrderTraveral(root);</span><br><span class="line">    System.out.println();</span><br><span class="line">    postOrderTraveralWithStack(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderTraveral</span><span class="params">(BinaryTree.TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderTraveral(node.leftChild());</span><br><span class="line">    postOrderTraveral(node.rightChile());</span><br><span class="line">    System.out.print(node.data() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历，非递归</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderTraveralWithStack</span><span class="params">(BinaryTree.TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;BinaryTree.TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    BinaryTree.<span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (treeNode != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (treeNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(treeNode.data());</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            treeNode = treeNode.rightChile();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            treeNode = stack.pop();</span><br><span class="line">            treeNode = treeNode.leftChild();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        System.out.print(list.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>二叉树的层序遍历，输出顺序按照一层一层往下输出，所以也叫作广度优先遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">3</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">8</span></span><br><span class="line"> /  \     \</span><br><span class="line"><span class="number">9</span>   <span class="number">10</span>     <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>上述的二叉树中，层序遍历的输出循序为：<code>3、2、8、9、10、4</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 构建二叉树</span></span><br><span class="line">    <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(arr);</span><br><span class="line">    <span class="comment">// 获取二叉树的根节点</span></span><br><span class="line">    BinaryTree.<span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> binaryTree.root();</span><br><span class="line">    System.out.println(<span class="string">&quot;层序遍历：&quot;</span>);</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    levelOrderTraveralWithQueue(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层序遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraveralWithQueue</span><span class="params">(BinaryTree.TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;BinaryTree.TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        BinaryTree.<span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.print(node.data() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        BinaryTree.<span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> node.leftChild();</span><br><span class="line">        <span class="keyword">if</span> (leftChild != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryTree.<span class="type">TreeNode</span> <span class="variable">rightChile</span> <span class="operator">=</span> node.rightChile();</span><br><span class="line">        <span class="keyword">if</span> (rightChile != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(rightChile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>面试算法之如何判断链表有环</title>
    <url>/2021/04/21/algorithm/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="如何判断链表有环"><a href="#如何判断链表有环" class="headerlink" title="如何判断链表有环"></a>如何判断链表有环</h1><p>给一个单向链表，使用程序来判断链表中是否存在环结构。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> data) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    node1.next = node2;</span><br><span class="line">    node2.next = node3;</span><br><span class="line">    node3.next = node4;</span><br><span class="line">    node4.next = node5;</span><br><span class="line">    node5.next = node2;</span><br><span class="line">    <span class="comment">// 解法一</span></span><br><span class="line">    System.out.println(isCycle1(node1));</span><br><span class="line">    <span class="comment">// 解法二</span></span><br><span class="line">    System.out.println(isCycle2(node1));</span><br><span class="line">    <span class="comment">// 解法三</span></span><br><span class="line">    System.out.println(isCycle3(node1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>解法一：依次遍历链表的节点，每遍历一个节点，就从头部开始检查到当前节点之前的所有节点，用当前节点和此节点之前的所有节点进行比较，如果存在相等的节点，则说明链表结构存在环，否则继续遍历节点，直到链表结束。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCycle1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">currentNode</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; i &lt; currentIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == currentNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">        currentIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>解法二：使用一个 HashSet 结构，从头开始遍历链表，每次遍历连接，使用当前节点去 HashSet 中获取节点元素，如果 HashSet 中不存在当前节点，则将当前节点存入 HashSet 容器中，如果 HashSet 中存在当前节点，说明链表存在环。</p>
<blockquote>
<p>这其实是一种类似 Redis 中的布隆过滤器的结构。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCycle2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.remove(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>解法三：使用两个指针，让它们从头部开始遍历，其中一个指针每次遍历向后移动一个节点，另一个指针每次遍历向后移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有换，如果不同，则继续下一次循环。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCycle3</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; p2.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法评估"><a href="#解法评估" class="headerlink" title="解法评估"></a>解法评估</h2><table>
<thead>
<tr>
<th>-</th>
<th>解法一</th>
<th>解法二</th>
<th>解法三</th>
</tr>
</thead>
<tbody><tr>
<td>时间复杂度</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之什么是链表？</title>
    <url>/2021/02/24/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h1><p>链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干个节点（node）所组成。</p>
<span id="more"></span>

<p>链表分为单向链表和双向链表。</p>
<ul>
<li><p>单向链表的每一个节点包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next。</p>
</li>
<li><p>双向链表比单向链表复杂一些，它的每一个节点除了拥有data和next指针，还拥有指向前置节点的prev指针。</p>
</li>
</ul>
<p>如果说数组在内存中的存储方式为顺序存储，那么链表在内存在的存储方式则是随机存储。</p>
<p><strong>什么是随机存储？</strong></p>
<p>数组在内存中占用了连续完整的存储空间。而链表则采用见缝插针的方式，链表的每一个节点分布在内存空间中的不同位置，依靠指针关联起来，这样可以灵活有效地利用零散的碎片空间。</p>
<h1 id="链表的组成"><a href="#链表的组成" class="headerlink" title="链表的组成"></a>链表的组成</h1><blockquote>
<p>本篇文章中的链表均以单链表的Demo，在文章的末尾处会附带双向链表的实现代码。</p>
</blockquote>
<ul>
<li><p>节点：一个链表是有若干个结点组成的，节点是链表的基础结构。</p>
</li>
<li><p>头节点指针：链表需要一个头节点指针，用于表示链表开始的位置。</p>
</li>
<li><p>尾结点指针：链表可以设置一个尾部节点指针。</p>
<blockquote>
<p>当然，链表的尾部节点指针不是必须的，因为链表最后一个节点的next指针指向空，也可以标识链表的结尾。</p>
</blockquote>
</li>
<li><p>链表实际长度：可以设置一个变量记录链表的实际长度。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的尾部指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的头指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">head</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的尾部指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的尾部指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的实际长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点点作为链表的一个内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 节点存储的数据data</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">        <span class="comment">// 该指针指向下一个节点的指针next</span></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Node(<span class="type">int</span> data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回节点中存储的数据值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 节点中存储的数据值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回下一个节点的指针</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 下一个节点的指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h1><p>和数组一样，链表的基本操作也同样是增、删、改、查四种操作。</p>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>链表查找元素不像数组那样可以通过下标进行随机访问，链表想要查找一个元素，只能从头节点开始，一个一个向后查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表的查找操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 需要查找的链表索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引对应的链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到链表的头节点的位置</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="comment">// 从头节点向后查找，共向后循环index次，即可找到index位置的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>链表的更新操作也比较简单，只需要查找到需要修改的节点，直接将原节点的数据替换即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新链表节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 需要更新的链表位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data  需要更新的节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到链表的头节点的位置</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="comment">// 从头节点向后查找，共向后循环index次，即可找到index位置的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用需要替换的值，替换原值</span></span><br><span class="line">    temp.data = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>链表的插入操作分为三组：</p>
<ul>
<li><p>尾部插入</p>
<blockquote>
<p>链表的尾部操作最为简单，只需要将链表的尾部节点的next指针，指向新结点即可。<br>  如果有尾部节点指针，则还需要维护链表尾部节点指针，将其指向新节点。</p>
</blockquote>
</li>
<li><p>中间插入</p>
<blockquote>
<p>链表的中间插入，分为三步：<br>  第一步：找到要插入的链表位置。<br>  第二步：将新结点的next指针指向插入位置的节点。<br>  第三步：将原插入位置的节点的上一个节点的next指针指向新节点。  </p>
</blockquote>
</li>
<li><p>头部插入</p>
<blockquote>
<p>链表的头部插入，分为三步：<br>  第一步：将新节点的next指针指向新节点。<br>  第二步：维护链表的头部节点指针，将其指向新节点。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>链表的插入操作与数组的插入操作有些许不同，就在于链表不会出现容量不足的情况，无需进行扩容操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接在尾部插入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 需要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    insert(size, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接在尾部插入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 需要插入的链表位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data  需要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将需要插入的数据封装为一个链表节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">insertNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">    <span class="comment">// 链表节点为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 维护链表头部节点指针</span></span><br><span class="line">        <span class="built_in">this</span>.head = insertNode;</span><br><span class="line">        <span class="comment">// 维护链表尾部节点指针</span></span><br><span class="line">        <span class="built_in">this</span>.last = insertNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 头部插入</span></span><br><span class="line">        <span class="comment">// 使用新节点的next指针指向头部节点</span></span><br><span class="line">        insertNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="comment">// 维护链表头部节点的指针</span></span><br><span class="line">        <span class="built_in">this</span>.head = insertNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="comment">// 尾部插入</span></span><br><span class="line">        <span class="comment">// 直接使用尾部节点指针指向新结点</span></span><br><span class="line">        <span class="built_in">this</span>.last.next = insertNode;</span><br><span class="line">        <span class="comment">// 维护链表尾部节点的指针</span></span><br><span class="line">        <span class="built_in">this</span>.last = insertNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取插入位置的前一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将新节点的next指针指向插入位置节点</span></span><br><span class="line">        insertNode.next = prevNode.next;</span><br><span class="line">        <span class="comment">// 插入位置的前一个节点的next指针指向新节点</span></span><br><span class="line">        prevNode.next = insertNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 维护链表长度</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>链表的删除操作和插入操作类似。</p>
<ul>
<li><p>删除头部节点</p>
<blockquote>
<p>删除头部节点，只需要将链表的head指针指向原head节点的下一个节点即可。</p>
</blockquote>
</li>
<li><p>删除中间节点</p>
<blockquote>
<p>删除中间节点，删除位置的前一个节点的next指针指向删除位置的下一个节点即可。</p>
</blockquote>
</li>
<li><p>删除尾部节点</p>
<blockquote>
<p>删除尾部节点，将尾部节点的前一个节点的next指针置空，并维护last指针即可。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表的结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 需要删除的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">removeNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 头部删除</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        removeNode = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="comment">// 维护链表的头部指针</span></span><br><span class="line">        <span class="built_in">this</span>.head = removeNode.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 尾部删除</span></span><br><span class="line">        <span class="comment">// 获取尾部的前一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">        removeNode = prevNode.next;</span><br><span class="line">        <span class="comment">// 置空尾部的前一个节点的next指针</span></span><br><span class="line">        prevNode.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 维护链表的尾部指针</span></span><br><span class="line">        <span class="built_in">this</span>.last = prevNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取插入位置的前一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 需要删除的节点</span></span><br><span class="line">        removeNode = prevNode.next;</span><br><span class="line">        <span class="comment">// 将删除位置的上一个节点的next指针指向删除位置的下一个节点</span></span><br><span class="line">        prevNode.next = removeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 维护链表长度</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> removeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表操作的时间复杂度"><a href="#链表操作的时间复杂度" class="headerlink" title="链表操作的时间复杂度"></a>链表操作的时间复杂度</h1><table>
<thead>
<tr>
<th>链表操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>查找节点</td>
<td>O(n)</td>
</tr>
<tr>
<td>更新节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除节点</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h1 id="链表的优势和劣势"><a href="#链表的优势和劣势" class="headerlink" title="链表的优势和劣势"></a>链表的优势和劣势</h1><p>优势：链表能够灵活地插入，删除节点，所以更适用于插入，更新，删除操作更多场景。</p>
<p>劣势：链表的查找操作，需要从头遍历整个链表，性能低下，不适用与读操作多的场景。</p>
<h1 id="单链表的完整代码（Java）"><a href="#单链表的完整代码（Java）" class="headerlink" title="单链表的完整代码（Java）"></a>单链表的完整代码（Java）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的尾部指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的头指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">head</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的尾部指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的尾部指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的实际长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的查找操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要查找的链表索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 索引对应的链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到链表的头节点的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="comment">// 从头节点向后查找，共向后循环index次，即可找到index位置的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新链表节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要更新的链表位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  需要更新的节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到链表的头节点的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="comment">// 从头节点向后查找，共向后循环index次，即可找到index位置的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用需要替换的值，替换原值</span></span><br><span class="line">        temp.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接在尾部插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 需要插入的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        insert(size, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接在尾部插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要插入的链表位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  需要插入的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将需要插入的数据封装为一个链表节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">insertNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="comment">// 链表节点为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 维护链表头部节点指针</span></span><br><span class="line">            <span class="built_in">this</span>.head = insertNode;</span><br><span class="line">            <span class="comment">// 维护链表尾部节点指针</span></span><br><span class="line">            <span class="built_in">this</span>.last = insertNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 头部插入</span></span><br><span class="line">            <span class="comment">// 使用新节点的next指针指向头部节点</span></span><br><span class="line">            insertNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="comment">// 维护链表头部节点的指针</span></span><br><span class="line">            <span class="built_in">this</span>.head = insertNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            <span class="comment">// 尾部插入</span></span><br><span class="line">            <span class="comment">// 直接使用尾部节点指针指向新结点</span></span><br><span class="line">            <span class="built_in">this</span>.last.next = insertNode;</span><br><span class="line">            <span class="comment">// 维护链表尾部节点的指针</span></span><br><span class="line">            <span class="built_in">this</span>.last = insertNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取插入位置的前一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将新节点的next指针指向插入位置节点</span></span><br><span class="line">            insertNode.next = prevNode.next;</span><br><span class="line">            <span class="comment">// 插入位置的前一个节点的next指针指向新节点</span></span><br><span class="line">            prevNode.next = insertNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护链表长度</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除链表的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要删除的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removeNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 头部删除</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            removeNode = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="comment">// 维护链表的头部指针</span></span><br><span class="line">            <span class="built_in">this</span>.head = removeNode.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 尾部删除</span></span><br><span class="line">            <span class="comment">// 获取尾部的前一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            <span class="comment">// 置空尾部的前一个节点的next指针</span></span><br><span class="line">            prevNode.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 维护链表的尾部指针</span></span><br><span class="line">            <span class="built_in">this</span>.last = prevNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取插入位置的前一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 需要删除的节点</span></span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            <span class="comment">// 将删除位置的上一个节点的next指针指向删除位置的下一个节点</span></span><br><span class="line">            prevNode.next = removeNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护链表长度</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removeNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点点作为链表的一个内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 节点存储的数据data</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">        <span class="comment">// 该指针指向下一个节点的指针next</span></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Node(<span class="type">int</span> data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回节点中存储的数据值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 节点中存储的数据值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回下一个节点的指针</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 下一个节点的指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双向链表的完整代码（Java）"><a href="#双向链表的完整代码（Java）" class="headerlink" title="双向链表的完整代码（Java）"></a>双向链表的完整代码（Java）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的尾部指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的头指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">head</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的尾部指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的尾部指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表的实际长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表的实际长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的查找操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要查找的链表索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 索引对应的链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到链表的头节点的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="comment">// 从头节点向后查找，共向后循环index次，即可找到index位置的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新链表节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要更新的链表位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  需要更新的节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到链表的头节点的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="comment">// 从头节点向后查找，共向后循环index次，即可找到index位置的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用需要替换的值，替换原值</span></span><br><span class="line">        temp.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接在尾部插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 需要插入的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        insert(size, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接在尾部插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要插入的链表位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  需要插入的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将需要插入的数据封装为一个链表节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">insertNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="comment">// 链表节点为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 维护链表头部节点指针</span></span><br><span class="line">            <span class="built_in">this</span>.head = insertNode;</span><br><span class="line">            <span class="comment">// 维护链表尾部节点指针</span></span><br><span class="line">            <span class="built_in">this</span>.last = insertNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 头部插入</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">headNode</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="comment">// 将原头节点的上一个节点指针指向新节点</span></span><br><span class="line">            headNode.prev = insertNode;</span><br><span class="line">            <span class="comment">// 使用新节点的next指针指向头部节点</span></span><br><span class="line">            insertNode.next = headNode;</span><br><span class="line">            <span class="comment">// 维护链表头部节点的指针</span></span><br><span class="line">            <span class="built_in">this</span>.head = insertNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            <span class="comment">// 尾部插入</span></span><br><span class="line">            <span class="comment">// 直接使用尾部节点指针指向新结点</span></span><br><span class="line">            <span class="built_in">this</span>.last.next = insertNode;</span><br><span class="line">            <span class="comment">// 新节点的上一个节点指向原尾部节点</span></span><br><span class="line">            insertNode.prev = <span class="built_in">this</span>.last;</span><br><span class="line">            <span class="comment">// 维护链表尾部节点的指针</span></span><br><span class="line">            <span class="built_in">this</span>.last = insertNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取插入位置的前一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 插入位置的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">nextNode</span> <span class="operator">=</span> prevNode.next;</span><br><span class="line">            nextNode.prev = insertNode;</span><br><span class="line">            <span class="comment">// 将新节点的next指针指向插入位置节点,prev指针指向前一个节点</span></span><br><span class="line">            insertNode.next = nextNode;</span><br><span class="line">            insertNode.prev = prevNode;</span><br><span class="line">            <span class="comment">// 插入位置的前一个节点的next指针指向新节点</span></span><br><span class="line">            prevNode.next = insertNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护链表长度</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除链表的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要删除的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超出链表的实际节点范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removeNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 头部删除</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            removeNode = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">nextHead</span> <span class="operator">=</span> removeNode.next;</span><br><span class="line">            <span class="comment">// 置空新的头部节点的pre指针</span></span><br><span class="line">            nextHead.prev = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 维护链表的头部指针</span></span><br><span class="line">            <span class="built_in">this</span>.head = nextHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 尾部删除</span></span><br><span class="line">            <span class="comment">// 获取尾部的前一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            <span class="comment">// 置空尾部的前一个节点的next指针</span></span><br><span class="line">            prevNode.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 维护链表的尾部指针</span></span><br><span class="line">            <span class="built_in">this</span>.last = prevNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取插入位置的前一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">prevNode</span> <span class="operator">=</span> get(index - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 需要删除的节点</span></span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            <span class="comment">// 删除节点的下一个节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">nextNode</span> <span class="operator">=</span> removeNode.next;</span><br><span class="line">            <span class="comment">// 将删除位置的上一个节点的next指针指向删除位置的下一个节点</span></span><br><span class="line">            prevNode.next = nextNode;</span><br><span class="line">            nextNode.prev = prevNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 维护链表长度</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removeNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点点作为链表的一个内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 节点存储的数据data</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">        <span class="comment">// 该指针指向上一个</span></span><br><span class="line">        <span class="keyword">private</span> Node prev;</span><br><span class="line">        <span class="comment">// 该指针指向下一个节点的指针next</span></span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Node(<span class="type">int</span> data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回节点中存储的数据值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 节点中存储的数据值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回上一个节点的指针</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 上一个节点的指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">prev</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回下一个节点的指针</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 下一个节点的指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本文<strong>Github</strong> <a href="https://github.com/herenpeng/code-learn">https://github.com/herenpeng/code-learn</a> 已收录，欢迎<strong>Star</strong>。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议的三次握手和四次挥手</title>
    <url>/2020/03/22/computer/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h2 id="什么是TCP协议？"><a href="#什么是TCP协议？" class="headerlink" title="什么是TCP协议？"></a>什么是TCP协议？</h2><p>TCP是传输控制协议，是一个面向连接的协议，在使用TCP协议收发数据前，必须和对方建立可靠的连接，一个TCP连接必须要经过3次“对话”才能建立起来。</p>
<span id="more"></span>
<p>第一次对话：由主机A发送一个请求连接的消息报文给主机B。<br>第二次对话：由主机B发送同意连接和要求同步的数据包。<br>第三次对话：由主机A发送一个数据包确认主机B要求同步。</p>
<p><img src="/images/2020/03/20200322143430540.png" alt="在这里插入图片描述"></p>
<p><strong>同步就是两台主机一个发送，一个接收，协调工作。</strong></p>
<blockquote>
<p>三次“对话”的目的是使数据包的发送和接受同步，经过三次“对话”之后，主机A才向主机B正式发送数据。</p>
</blockquote>
<h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><strong>TCP建立可靠连接的三次对话过程也被称作为三次握手。</strong></p>
<p>在了解TCP的三次握手前，需要先了解几个概念。</p>
<ul>
<li><strong>Seq：</strong> 序列号，根据序列号标识某个操作。</li>
<li><strong>Ack：</strong> 确认标志，如果确认某个操作，则回复Ack=对方主机Seq+1。</li>
<li><strong>SYN：</strong> 同步标志。</li>
<li><strong>FIN：</strong> 结束标志。</li>
</ul>
<p><img src="/images/2020/03/20200322143744670.png" alt="在这里插入图片描述"></p>
<h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p><strong>TCP的四次挥手是为了正常断开连接，并保证传输的数据的完整性。</strong></p>
<p><img src="/images/2020/03/20200322144424861.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>TCP的四次挥手不一定是由Client发起的，Client和Server均可以发起四次挥手，断开连接。</p>
</blockquote>
<h2 id="为什么TCP是三次握手，四次挥手？"><a href="#为什么TCP是三次握手，四次挥手？" class="headerlink" title="为什么TCP是三次握手，四次挥手？"></a>为什么TCP是三次握手，四次挥手？</h2><ul>
<li>当Server端接收到Client端发送的SYN（同步标志）连接请求的消息报文之后，可以直接发送Ack+SYN报文给Client，其中Ack表示应答，确认，SYN报文是表示同步。</li>
<li>但是当被动方接受到FIN（结束标志）消息报文之后，很可能不会立即关闭Socket，所以只能先回复一个Ack表示同意结束连接。</li>
<li>当被动方的所有报文发送完毕，发会发送FIN（结束标志）报文，所以TCP是四次挥手断开连接。</li>
</ul>
<blockquote>
<p>总而言之，TCP协议之所以是三次握手，四次挥手，全部都是为了保证数据传输的完整性。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的GoPath和GoModule</title>
    <url>/2020/04/13/golang/Golang%E4%B8%AD%E7%9A%84GoPath%E5%92%8CGoModule/</url>
    <content><![CDATA[<blockquote>
<p>在Golang中，有两个概念非常容易弄错，第一个就是GoPath，第二个则是GoModule，很多初学者不清楚这两者之间的关系，也就难以清晰地了解项目的整体结构，自然也就难以编写结构清晰的代码。</p>
</blockquote>
<span id="more"></span>
<h1 id="什么是GoPath？"><a href="#什么是GoPath？" class="headerlink" title="什么是GoPath？"></a>什么是GoPath？</h1><p>什么是Gopath？在我的上一篇博客<a href="/2020/04/08/golang/Golang环境安装&IDEA开发Golang/">Golang环境安装&amp;IDEA开发Golang</a>中，曾经提到过GoPath的概念。<br>GoPath是Golang的工作空间，所有的Go文件，都需要放在GoPath下的src目录下才能够编译运行，所以我提议不要直接配置全局的GoPath目录，否则会非常难以管理所有的Golang项目。</p>
<p>但是在另一篇博客<a href="/2020/04/12/golang/Golang连接MySQL数据库之CRUD/">Golang连接MySQL数据库之CRUD</a>中，我也提到过，我们在项目中使用第三方类库的时候，可以使用<code>go get</code>命令从网下直接拉去第三方类库的包，而拉取下来的包就会直接下载到我们的GoPath目录下的src包下。</p>
<p>这样就导致了一个问题，我们自己的Golang代码，和第三方的Golang文件混在了一起，这对于我们管理Golang项目的包显然是非常麻烦的，而且每个如果项目都需要同样的依赖，那么我们就会在不同的GoPath的src中下载大量重复的第三方依赖包，这同样会占用大量的磁盘空间。</p>
<p><strong>我们给不同的项目设置不同的GoPath，优点非常明显：</strong></p>
<p>便于管理项目，每个项目都是不同的GoPath，这对于我们管理多个Golang项目而言，能够非常清晰的处理项目结构。如果我们把所有项目都放在同一个GoPath的src包下，那么项目的结构就会变得非常混乱，难以管理。</p>
<p><strong>但是当我们需要依赖第三方的包的时候，不同的项目设置不同的GoPath的缺点也非常明显：</strong></p>
<ol>
<li>第三方依赖的包和我们自己的Golang包混在一起，会给我们的项目文件管理带来一定的麻烦。</li>
<li>不同的GoPath都需要下载依赖，那么磁盘中重复的依赖就会非常多，会占用我们大量的磁盘空间。</li>
</ol>
<p>所以，究竟是设置一个GoPath目录，解决依赖重复的问题，还是设置不同的GoPath目录，解决Golang项目结构混乱的问题，这是一个有争议性的问题。</p>
<p><strong>为了解决这所有的问题，Golang最终引入了GoModule的概念。</strong></p>
<h1 id="什么是GoModule？"><a href="#什么是GoModule？" class="headerlink" title="什么是GoModule？"></a>什么是GoModule？</h1><p>GoModule是Golang在1.11版本初步引入的概念，在1.12版本中正是开始使用，所以如果需要使用GoModule，那么需要保证你的Golang的版本在1.12或以上。<br>另外需要说一下，Golang1.11和1.12版本虽然已经引入了GoModule的概念，但是GoModule是默认不开启的，如果需要开启，那么需要配置一个环境变量：<code>GO111MODULE=on</code>，默认是<code>off</code>。</p>
<p>而在Golang1.13及以上的版本中，GoModule的默认配置为auto，即GoModule会通过你的目录下是否有go.mod文件来判断是否开启GoModule。所以Golang1.13+的版本中我们就不需要配置GO111MODULE属性了。<br>所以如果你使用GoModule，那么就直接使用Golang1.13+的版本好了！</p>
<p><strong>那么究竟什么是GoModule？</strong></p>
<ul>
<li>其实说得直白一下，GoModule就是一个用来取代GoPath的Golang的工作空间。</li>
</ul>
<p>我们之前说过，所有的Golang的文件，都需要放在GoPath目录下才能进行正确的编译和运行，而有了GoModule之后，那么我们就可以把文件放在GoModule目录下，而放在GoModule目录下的Golang文件，也可以正确地编译运行。</p>
<p>那么我们有了GoModule之后，GoPath是不是就可以被舍弃了？</p>
<p>不是的！</p>
<p>我们之前说过，GoPath所引出的问题，就是因为第三方类库的包所导致的，所以我们在有了GoModule之后，GoPath和GoModule就分别负责不同的职责，共同为我们的Golang项目服务。</p>
<p><strong>GoPath我们用来存放我们从网上拉取的第三方依赖包。</strong><br><strong>GoModule我们用来存放我们自己的Golang项目文件</strong>，当我们自己的项目需要依赖第三方的包的时候，我们通过GoModule目录下的一个go.mod文件来引用GoPath目录src包下的第三方依赖即可。</p>
<p>这样依赖，既解决了原来只能局限在GoPath目录src包下进行编程的问题，也解决了第三方依赖包难以管理和重复依赖占用磁盘空间的问题。</p>
<blockquote>
<p>总而言之，在引入GoModule之后，我们不会直接在GoPath目录进行编程，而是把GoPath作为一个第三方依赖包的仓库，我们真正的工作空间在GoModule目录下。</p>
</blockquote>
<h1 id="GoModule的设置"><a href="#GoModule的设置" class="headerlink" title="GoModule的设置"></a>GoModule的设置</h1><p>既然搞清楚了GoPath和GoModule之间的区别，那么GoModule又该怎么配置呢？一个目录怎么才能算是一个GoModule目录了。</p>
<p>很简单，我们直接使用<code>go mod init 模块名称</code>命令对目录进行初始化操作，即可将这个目录设置为GoModule目录。<br>我们在<code>F:\GoModule</code>目录下创建一个文件夹，名字为：<code>go_module</code>。<br>然后通过cmd命令提示符进入该目录，执行<code>go mod init 模块名称</code>初始化命令。<br><img src="/images/2020/04/20200413173543729.png" alt="在这里插入图片描述"><br>当初始化命令执行完毕之后，会在go_module目录下生成一个go.mod文件，该文件就是用来引入GoPath目录下的第三方依赖的文件。</p>
<p><strong>初始化之后的go.mod文件</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module go_module</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure>

<p>当我们需要引入GoPath目录下的第三方依赖包的时候，只需要在go.mod目录下添加依赖名称，GoModule就会自动帮我们把第三方依赖包下载到GoPath目录下。</p>
<p>例如下面的go.mod文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module go_module_demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/astaxie/beego v1<span class="number">.12</span><span class="number">.1</span></span><br><span class="line">	github.com/<span class="keyword">go</span>-sql-driver/mysql v1<span class="number">.5</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们在这个go.mod文件中引入了两个依赖，分别是：<code>beego框架 v1.12.1版本</code>和<code>mysql驱动  v1.5.0版本</code>。</p>
<ul>
<li>而如果我们使用IDE进行开发的话，那么可以直接创建一个GoModule项目，这样的话IDE会自动帮我们生成所需要的文件，而且在使用依赖的包的时候，IDE还会自动帮我们加入依赖和下载依赖，这会省去我们大量的时间，而且可以不用再去记忆依赖的具体包名和版本号。</li>
</ul>
<h1 id="GoModule无法下载国外的依赖包问题"><a href="#GoModule无法下载国外的依赖包问题" class="headerlink" title="GoModule无法下载国外的依赖包问题"></a>GoModule无法下载国外的依赖包问题</h1><p>这是一个很多开发者都碰到过的问题，对于国外的依赖包无法直接通过网络进行下载，这显然会让开发者非常难受，所以Golang也引入了另一个属性：GOPROXY，我们只需要在环境变量中配置GOPROXY=<code>https://goproxy.io</code>即可解决GoModule无法下载国外的依赖包问题。<br>当然，也可以通过IDE来配置，这样省的在电脑系统的环境变量配置太多难以管理。</p>
<p><strong>在IDEA中配置GOPROXY属性：</strong></p>
<p><img src="/images/2020/04/2020041318024526.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang环境安装&amp;IDEA开发Golang</title>
    <url>/2020/04/08/golang/Golang%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85&amp;IDEA%E5%BC%80%E5%8F%91Golang/</url>
    <content><![CDATA[<blockquote>
<p>在这篇博客中，我们学习Windows系统安装Golang的环境，并使用IDEA安装Go插件来开发Golang。</p>
</blockquote>
<span id="more"></span>

<h1 id="Golang简介"><a href="#Golang简介" class="headerlink" title="Golang简介"></a>Golang简介</h1><p>Golang，即Go语言，是Google的Robert Griesemer，Rob Pike及Ken Thompson开发的一种静态强类型、编译型语言。Go语言语法与C相近，但功能上有：内存安全，GC（垃圾回收），结构形态及CSP-style并发计算。</p>
<h1 id="Golang环境安装"><a href="#Golang环境安装" class="headerlink" title="Golang环境安装"></a>Golang环境安装</h1><p>Golang下载官网：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a></p>
<p>我们首选访问官网，下载对应操作系统的Golang安装包，在这里，我们选择的是Windows版的安装包。<br><img src="/images/2020/04/2020040818545544.png" alt="在这里插入图片描述">安装包下载之后，直接安装，一路next即可安装完毕。<br>安装完毕之后，可以使用<code>go version</code>命令来查看golang版本，如果显示版本号，则说明golang安装成功。<br><img src="/images/2020/04/20200408190942781.png" alt="在这里插入图片描述"></p>
<h1 id="Golang环境变量配置"><a href="#Golang环境变量配置" class="headerlink" title="Golang环境变量配置"></a>Golang环境变量配置</h1><p>Golang中有需要配置三个环境变量，分别是：</p>
<ul>
<li>GOROOT：Golang的安装目录</li>
<li>PATH：Golang的安装目录下的bin目录</li>
<li>GOPATH：Golang的项目目录</li>
</ul>
<p><strong>【注意】我们将GOROOT和PATH配置到系统的环境变量中，但是GOPATH我们不直接在系统变量中配置成一个固定的配置，因为我们可能在一个系统中创建多个Golang的项目，每一个项目都需要配置一个GOPATH变量，这显然是繁琐而且非常难以管理的，所以我们在创建项目的时候，直接通过IDE在创建项目的时候来配置GOPATH变量，这样就可以给每个Golang项目都配置上对应的GOPATH路径。</strong></p>
<p>我们首先找到系统环境变量的配置界面：<br>此电脑（我的电脑）——右键属性——高级系统设置——环境变量<br>我们会看到如下的界面，其中GOROOT的环境变量如下：<br><img src="/images/2020/04/20200408192238222.png" alt="在这里插入图片描述"><br>PATH的环境变量配置如下：<br><img src="/images/2020/04/20200408192450190.png" alt="在这里插入图片描述"><br><strong>如果你是用的是msi的安装包安装Golang，一般都会在安装的时候自动帮你配置这些信息，只要是用<code>go version</code>能够查看版本信息，就说明Golang配置成功，这些变量也都已经配置好了。<br>如果你使用的是zip解压缩的方式，那么就需要手动配置这些环境变量。</strong></p>
<h1 id="IDEA安装Go插件"><a href="#IDEA安装Go插件" class="headerlink" title="IDEA安装Go插件"></a>IDEA安装Go插件</h1><p>如果要使用IDEA来进行Golang的开发，那么我们需要下载一个Go插件，否则是无法进行Golang的开发的。<br>IDEA自动集成了Go插件，我们只需要在IDEA上下载安装一下即可。<br>我们进入插件下载界面：File——Settings——Plugins</p>
<p><img src="/images/2020/04/2020040819341761.png" alt="在这里插入图片描述"></p>
<h1 id="IDEA开发Golang"><a href="#IDEA开发Golang" class="headerlink" title="IDEA开发Golang"></a>IDEA开发Golang</h1><h2 id="创建一个Golang项目"><a href="#创建一个Golang项目" class="headerlink" title="创建一个Golang项目"></a>创建一个Golang项目</h2><p><img src="/images/2020/04/20200408193655789.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200408193852625.png" alt="在这里插入图片描述"></p>
<h2 id="配置GOPATH环境变量"><a href="#配置GOPATH环境变量" class="headerlink" title="配置GOPATH环境变量"></a>配置GOPATH环境变量</h2><p>我们创建项目之后，打开项目，选择File——Settings——Languages&amp;Frameworks——Go——GOPATH，配置项目的GOPATH路径。<br><img src="/images/2020/04/20200408194527479.png" alt="在这里插入图片描述"></p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Golang的项目代码全部放在GOPATH路径下的src目录下，所以我们直接在项目下创建一个src目录，用来存放我们的Golang源代码。</p>
<p><strong>项目目录结构如下：</strong><br><img src="/images/2020/04/20200408200952535.png" alt="在这里插入图片描述"><br><strong>action.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Say</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我正在说话&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;com/person&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    person.Say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong><br><img src="/images/2020/04/20200408201121766.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang连接MySQL数据库之CRUD</title>
    <url>/2020/04/12/golang/Golang%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BCRUD/</url>
    <content><![CDATA[<blockquote>
<p>我们这次来学习使用Golang来连接MySQL数据库，并使用Golang实现数据库的CRUD操作。</p>
</blockquote>
<span id="more"></span>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>首先我们创建一个Golang的项目，并配置项目GOPATH，这一步可以参考我的博客<a href="/2020/04/08/golang/Golang环境安装&IDEA开发Golang/">Golang环境安装&amp;IDEA开发Golang</a>。</p>
<p>因为我们使用的是MySQL数据库，所以我们需要获取Golang的MySQL数据库驱动。<br>我们在项目GOPATH的目录下，执行<code>go get</code>命令来获取MySQL的驱动，命令执行成功之后，会直接从网上下载MySQL驱动的包到你的<code>GOPATH</code>目录下的<code>src</code>目录下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/<span class="keyword">go</span>-sql-driver/mysql</span><br></pre></td></tr></table></figure>
<p>Golang的项目环境搭建完成之后，我们还需要创建一张数据库表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `nameindex` (`name`(<span class="number">10</span>))</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p><img src="/images/2020/04/2020041210175843.png" alt="在这里插入图片描述"></p>
<h1 id="编写结构体"><a href="#编写结构体" class="headerlink" title="编写结构体"></a>编写结构体</h1><p>为了能够便于封装从数据库中获取的数据，我们创建一个Golang结构，来封装我们的数据。<br>我们创建一个<code>bean</code>包，然后在该包下创建一个<code>user.go</code>文件。</p>
<p><strong>user.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bean</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> GetId() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> user.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> SetId(id <span class="type">int</span>) &#123;</span><br><span class="line">	user.id = id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> user.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">	user.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> GetPassword() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> user.password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> SetPassword(password <span class="type">string</span>) &#123;</span><br><span class="line">	user.password = password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编写数据库连接工具"><a href="#编写数据库连接工具" class="headerlink" title="编写数据库连接工具"></a>编写数据库连接工具</h1><p>由于每次连接数据库都需要获取数据库连接，所以我们直接将数据库的连接操作封装为一个方法，这样就可以不用每次都执行获取连接的步骤了。<br>我们创建一个<code>util</code>包，在包下创建一个<code>initdb.go</code>文件。</p>
<p><strong>initdb.go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们先将数据库配置信息定义成为常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	userName = <span class="string">&quot;root&quot;</span></span><br><span class="line">	password = <span class="string">&quot;admin&quot;</span></span><br><span class="line">	ip       = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">	port     = <span class="string">&quot;3306&quot;</span></span><br><span class="line">	dbName   = <span class="string">&quot;db_database08&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据库连接，返回数据库连接的指针引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDB</span><span class="params">()</span></span> *sql.DB &#123;</span><br><span class="line">	<span class="comment">//Golang数据连接：&quot;用户名:密码@tcp(IP:端口号)/数据库名?charset=utf8&quot;</span></span><br><span class="line">	path := strings.Join([]<span class="type">string</span>&#123;userName, <span class="string">&quot;:&quot;</span>, password, <span class="string">&quot;@tcp(&quot;</span>, ip, <span class="string">&quot;:&quot;</span>, port, <span class="string">&quot;)/&quot;</span>, dbName, <span class="string">&quot;?charset=utf8&quot;</span>&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="comment">//打开数据库,前者是驱动名，所以要导入： _ &quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//如果打开数据库错误，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置数据库最大连接数</span></span><br><span class="line">	db.SetConnMaxLifetime(<span class="number">10</span>)</span><br><span class="line">	<span class="comment">//设置上数据库最大闲置连接数</span></span><br><span class="line">	db.SetMaxIdleConns(<span class="number">5</span>)</span><br><span class="line">	<span class="comment">//验证连接</span></span><br><span class="line">	<span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将数据库连接的指针引用返回</span></span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h1><h2 id="Insert操作"><a href="#Insert操作" class="headerlink" title="Insert操作"></a>Insert操作</h2><p>我们创建一个<code>insert</code>包，在该包下创建一个<code>insert.go</code>文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;mysql/util&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//使用工具获取数据库连接</span></span><br><span class="line">	db := util.InitDB()</span><br><span class="line">	<span class="comment">//开启事务</span></span><br><span class="line">	tx, err := db.Begin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//事务开启失败，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//准备SQL语句</span></span><br><span class="line">	sql := <span class="string">&quot;insert into tb_user (`name`, `password`) values (?, ?)&quot;</span></span><br><span class="line">	<span class="comment">//对SQL语句进行预处理</span></span><br><span class="line">	stmt, err := db.Prepare(sql)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	result, err := stmt.Exec(<span class="string">&quot;阿部多瑞&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//SQL执行失败，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提交事务</span></span><br><span class="line">	tx.Commit()</span><br><span class="line">	<span class="comment">//返回插入记录的id</span></span><br><span class="line">	fmt.Println(result.LastInsertId())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Select操作"><a href="#Select操作" class="headerlink" title="Select操作"></a>Select操作</h2><p>我们创建一个<code>select</code>包，在该包下创建一个<code>select.go</code>文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;mysql/bean&quot;</span></span><br><span class="line">	<span class="string">&quot;mysql/util&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//使用工具获取数据库连接</span></span><br><span class="line">	db := util.InitDB()</span><br><span class="line">	<span class="comment">//准备SQL语句</span></span><br><span class="line">	sql := <span class="string">&quot;select * from tb_user&quot;</span></span><br><span class="line">	<span class="comment">//对SQL语句进行预处理</span></span><br><span class="line">	stmt, err := db.Prepare(sql)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	rows, err := stmt.Query()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//SQL执行失败，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> users []bean.User</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		<span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">		<span class="keyword">var</span> name, password <span class="type">string</span></span><br><span class="line">		err := rows.Scan(&amp;id, &amp;name, &amp;password)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//读取结果集失败</span></span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> user bean.User</span><br><span class="line">		user.SetId(id)</span><br><span class="line">		user.SetName(name)</span><br><span class="line">		user.SetPassword(password)</span><br><span class="line">		users = <span class="built_in">append</span>(users, user)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Update操作"><a href="#Update操作" class="headerlink" title="Update操作"></a>Update操作</h2><p>我们创建一个<code>update</code>包，在该包下创建一个<code>update.go</code>文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;mysql/util&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//使用工具获取数据库连接</span></span><br><span class="line">	db := util.InitDB()</span><br><span class="line">	<span class="comment">//开启事务</span></span><br><span class="line">	tx, err := db.Begin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//事务开启失败，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//准备SQL语句</span></span><br><span class="line">	sql := <span class="string">&quot;update tb_user set `password` = ? where `id` = ?&quot;</span></span><br><span class="line">	<span class="comment">//对SQL语句进行预处理</span></span><br><span class="line">	stmt, err := db.Prepare(sql)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = stmt.Exec(<span class="string">&quot;789&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//SQL执行失败，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提交事务</span></span><br><span class="line">	tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Delete操作"><a href="#Delete操作" class="headerlink" title="Delete操作"></a>Delete操作</h2><p>我们创建一个<code>delete</code>包，在该包下创建一个<code>delete.go</code>文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;mysql/util&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//使用工具获取数据库连接</span></span><br><span class="line">	db := util.InitDB()</span><br><span class="line">	<span class="comment">//开启事务</span></span><br><span class="line">	tx, err := db.Begin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//事务开启失败，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//准备SQL语句</span></span><br><span class="line">	sql := <span class="string">&quot;delete from tb_user where `id` = ?&quot;</span></span><br><span class="line">	<span class="comment">//对SQL语句进行预处理</span></span><br><span class="line">	stmt, err := db.Prepare(sql)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = stmt.Exec(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//SQL执行失败，直接panic</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提交事务</span></span><br><span class="line">	tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试基础题目</title>
    <url>/2020/05/04/interview/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="如果浏览器的Cookie被禁用，有什么方法可以继续追踪Session？"><a href="#如果浏览器的Cookie被禁用，有什么方法可以继续追踪Session？" class="headerlink" title="如果浏览器的Cookie被禁用，有什么方法可以继续追踪Session？"></a>如果浏览器的Cookie被禁用，有什么方法可以继续追踪Session？</h1><p>Session是基于Cookie的一种会话机制，每当一个Session被开启之后，都会将SessionID返回给浏览器，浏览器中的Cookie保存着SessionID，每当浏览器发送一次请求之后，都会携带这么一份Cookie传递到服务器中，服务器通过SessionID找到浏览器对应的Session，从而追踪Session。</p>
<span id="more"></span>
<p>如果浏览器Cookie被禁用，那么就无法通过Cookie将SessionID传递到服务器中，也无法找到对应的Session，Session也就无法使用了。<br>不过这种情况也不是没有办法了，可以用过URL重写的方式，在URL中加上一个参数，参数值为SessionID，这样的话就可以把SessionID传递到服务器中，从而继续追踪Session。</p>
<h1 id="请简述HTTP的长连接和短连接。"><a href="#请简述HTTP的长连接和短连接。" class="headerlink" title="请简述HTTP的长连接和短连接。"></a>请简述HTTP的长连接和短连接。</h1><ul>
<li>HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次挥手），等待在同域名下继续用这个通道传输数据。</li>
<li>与长连接相反的就是短连接，数据传输完毕之后，便通过四次挥手断开连接。</li>
</ul>
<h1 id="请简述Integer和int的区别？"><a href="#请简述Integer和int的区别？" class="headerlink" title="请简述Integer和int的区别？"></a>请简述Integer和int的区别？</h1><ul>
<li>Integer是int类型的包装类，Integer的引用数据类型，而int是基本数据类型。</li>
<li>Integer的默认初始值是null，而int的默认初始值为0。</li>
<li>Integer可以运用在泛型上，而int类型不能运用在泛型上。</li>
</ul>
<h1 id="为什么Golang的运行速度会快于Java？"><a href="#为什么Golang的运行速度会快于Java？" class="headerlink" title="为什么Golang的运行速度会快于Java？"></a>为什么Golang的运行速度会快于Java？</h1><p>Java的源代码会被编译成为字节码文件，而字节码文件需要运行在Java虚拟机（JVM）上，所以在运行速度上比较慢，而Golang的源代码会直接编译为机器代码，所以运行速度比起Java来要快很多。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列01</title>
    <url>/2020/03/06/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9701/</url>
    <content><![CDATA[<h2 id="1、下面两段代码的输出结果是？"><a href="#1、下面两段代码的输出结果是？" class="headerlink" title="1、下面两段代码的输出结果是？"></a>1、下面两段代码的输出结果是？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">a += ++a;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>输出结果为31</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">a += a++;</span><br></pre></td></tr></table></figure>
<p>输出结果为30</p>
<h2 id="2、下面三个二进制式子的运算结果是（使用10进制表达）？"><a href="#2、下面三个二进制式子的运算结果是（使用10进制表达）？" class="headerlink" title="2、下面三个二进制式子的运算结果是（使用10进制表达）？"></a>2、下面三个二进制式子的运算结果是（使用10进制表达）？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1001</span>|<span class="number">1010</span></span><br></pre></td></tr></table></figure>
<p>|是<strong>或运算</strong>，参加运算的两个对象只要有一个为1结果则为1，否则为0，所以结果为11（1011）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1001</span>^<span class="number">1001</span></span><br></pre></td></tr></table></figure>
<p>^是<strong>异或运算</strong>，参加运算的两个对象相同结果为0，否则为1，所以结果为0（0000）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1100</span>&amp;<span class="number">1010</span></span><br></pre></td></tr></table></figure>
<p>&amp;是<strong>与运算</strong>，参加运算的两个对象都为1结果为1，否则为0，所以结果为8（1000）</p>
<h2 id="3、下面代码的输出结果是什么？"><a href="#3、下面代码的输出结果是什么？" class="headerlink" title="3、下面代码的输出结果是什么？"></a>3、下面代码的输出结果是什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：0</p>
<h2 id="4、Linux系统中，用于显示TCP协议的相关信息的命令是？"><a href="#4、Linux系统中，用于显示TCP协议的相关信息的命令是？" class="headerlink" title="4、Linux系统中，用于显示TCP协议的相关信息的命令是？"></a>4、Linux系统中，用于显示TCP协议的相关信息的命令是？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure>

<h2 id="5、POST请求由哪些部分组成？"><a href="#5、POST请求由哪些部分组成？" class="headerlink" title="5、POST请求由哪些部分组成？"></a>5、POST请求由哪些部分组成？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请求行：请求方式，请求路径，HTTP版本</span><br><span class="line">请求头：消息报文，一些附加信息</span><br><span class="line">请求体：请求主体，POST请求携带的参数就在这里</span><br></pre></td></tr></table></figure>

<h2 id="6、POST请求常用的编码格式？"><a href="#6、POST请求常用的编码格式？" class="headerlink" title="6、POST请求常用的编码格式？"></a>6、POST请求常用的编码格式？</h2><ul>
<li><strong>Content-Type</strong>：application/x-www-form-urlencoded</li>
<li><strong>Content-Type</strong>：multipart/form-data</li>
<li><strong>Content-Type</strong>：application/json</li>
<li><strong>Content-Type</strong>：text/xml</li>
</ul>
<h2 id="7、将两个长度为m和n的有序数组，合并为一个有序数组，最坏的情况的时间复杂度为？"><a href="#7、将两个长度为m和n的有序数组，合并为一个有序数组，最坏的情况的时间复杂度为？" class="headerlink" title="7、将两个长度为m和n的有序数组，合并为一个有序数组，最坏的情况的时间复杂度为？"></a>7、将两个长度为m和n的有序数组，合并为一个有序数组，最坏的情况的时间复杂度为？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(m+n)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列02</title>
    <url>/2020/03/10/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9702/</url>
    <content><![CDATA[<h2 id="1、SpringBootApplication这个注解包含了哪些注解？"><a href="#1、SpringBootApplication这个注解包含了哪些注解？" class="headerlink" title="1、SpringBootApplication这个注解包含了哪些注解？"></a>1、SpringBootApplication这个注解包含了哪些注解？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="2、Spring-bean的注入有哪几种方式？"><a href="#2、Spring-bean的注入有哪几种方式？" class="headerlink" title="2、Spring bean的注入有哪几种方式？"></a>2、Spring bean的注入有哪几种方式？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、构造方法注入</span><br><span class="line"><span class="number">2</span>、setter方法注入</span><br><span class="line"><span class="number">3</span>、注解注入</span><br></pre></td></tr></table></figure>

<h2 id="3、Spring-bean的作用范围有哪些？"><a href="#3、Spring-bean的作用范围有哪些？" class="headerlink" title="3、Spring bean的作用范围有哪些？"></a>3、Spring bean的作用范围有哪些？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">singleton：单例，默认作用范围。</span><br><span class="line">prototype：多例。</span><br><span class="line">request：每次请求都会创建一个实例对象。</span><br><span class="line">session：每次会话都会创建一个实例对象。</span><br><span class="line">globalSession：全局Session只有一个实例对象。</span><br></pre></td></tr></table></figure>

<h2 id="4、Spring的声明式事务管理有哪几种？"><a href="#4、Spring的声明式事务管理有哪几种？" class="headerlink" title="4、Spring的声明式事务管理有哪几种？"></a>4、Spring的声明式事务管理有哪几种？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> PROPAGATION_REQUIRED：默认值，如果A中有事务，使用A中的事务，如果A没有，创建一个新的事务，将操作包含进来。</span><br><span class="line"><span class="number">2.</span> PROPAGATION_SUPPORTS：支持事务，如果A中有事务，使用A中的事务。如果A没有事务，不使用事务。</span><br><span class="line"><span class="number">3.</span> PROPAGATION_MANDATORY：如果A中有事务，使用A中的事务。如果A没有事务，抛出异常。</span><br><span class="line"><span class="number">4.</span> PROPAGATION_REQUIRES_NEW：如果A中有事务，将A的事务挂起（暂停），创建新事务，只包含自身操作。如果A中没有事务，创建一个新事务，包含自身操作。</span><br><span class="line"><span class="number">5.</span> PROPAGATION_NOT_SUPPORTED：如果A中有事务，将A的事务挂起。不使用事务管理。</span><br><span class="line"><span class="number">6.</span> PROPAGATION_NEVER：如果A中有事务，报异常。</span><br><span class="line"><span class="number">7.</span> PROPAGATION_NESTED：嵌套事务，如果A中有事务，按照A的事务执行，执行完成后，设置一个保存点，执行B中的操作，如果没有异常，执行通过，如果有异常，可以选择回滚到最初始位置，也可以回滚到保存点。</span><br></pre></td></tr></table></figure>

<h2 id="5、Java的元注解有哪些？"><a href="#5、Java的元注解有哪些？" class="headerlink" title="5、Java的元注解有哪些？"></a>5、Java的元注解有哪些？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>：表示可注解的位置，比如类上，方法上，或者参数上。</span><br><span class="line"><span class="meta">@Retention</span>：表示注解的保留阶段，源码阶段，class文件阶段，运行时阶段</span><br><span class="line"><span class="meta">@Documented</span>：表示注解是否被javadoc命令抽取为注释文档。</span><br><span class="line"><span class="meta">@Inherited</span>：表示子类是否可以继承该注解</span><br></pre></td></tr></table></figure>

<h2 id="6、MyBatis常用的动态标签有哪些？"><a href="#6、MyBatis常用的动态标签有哪些？" class="headerlink" title="6、MyBatis常用的动态标签有哪些？"></a>6、MyBatis常用的动态标签有哪些？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;where&gt;</span><br><span class="line">&lt;<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;choose&gt;</span><br><span class="line">&lt;Trim&gt;</span><br><span class="line">&lt;prefix&gt;</span><br><span class="line">&lt;suffix&gt;</span><br><span class="line">&lt;prefixoverrides&gt;</span><br><span class="line">&lt;suffixoverrides&gt;</span><br><span class="line">&lt;Foreach&gt;</span><br><span class="line">&lt;item&gt;</span><br><span class="line">&lt;separator&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7、FTP协议的默认端口号是？"><a href="#7、FTP协议的默认端口号是？" class="headerlink" title="7、FTP协议的默认端口号是？"></a>7、FTP协议的默认端口号是？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FTP是文件传输协议，默认端口号为<span class="number">21</span>。</span><br></pre></td></tr></table></figure>

<h2 id="8、Linux系统切换用户的命令是？"><a href="#8、Linux系统切换用户的命令是？" class="headerlink" title="8、Linux系统切换用户的命令是？"></a>8、Linux系统切换用户的命令是？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">su [用户名]</span><br></pre></td></tr></table></figure>

<h2 id="9、Linux系统查看进程的命令是？"><a href="#9、Linux系统查看进程的命令是？" class="headerlink" title="9、Linux系统查看进程的命令是？"></a>9、Linux系统查看进程的命令是？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure>

<h2 id="10、不能用来修饰Interface的有（）"><a href="#10、不能用来修饰Interface的有（）" class="headerlink" title="10、不能用来修饰Interface的有（）"></a>10、不能用来修饰Interface的有（）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A：<span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">B：<span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">C：<span class="keyword">protected</span></span><br><span class="line"></span><br><span class="line">D：<span class="keyword">static</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">答案：ACD</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列03</title>
    <url>/2020/03/13/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9703/</url>
    <content><![CDATA[<h2 id="1、HashMap的遍历方法？"><a href="#1、HashMap的遍历方法？" class="headerlink" title="1、HashMap的遍历方法？"></a>1、HashMap的遍历方法？</h2><span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line"><span class="comment">//第一种遍历方法</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种遍历方法</span></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String,String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">	<span class="type">String</span> <span class="variable">valeu</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种遍历方法</span></span><br><span class="line">Iterator&lt;String&gt; it =  map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、ArrayList和LinkedList的区别？"><a href="#2、ArrayList和LinkedList的区别？" class="headerlink" title="2、ArrayList和LinkedList的区别？"></a>2、ArrayList和LinkedList的区别？</h2><table>
<thead>
<tr>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>底层基于数组实现</td>
<td>底层基于链表实现</td>
</tr>
<tr>
<td>查找效率快，增删效率慢</td>
<td>查找效率慢，增删效率快</td>
</tr>
</tbody></table>
<h2 id="3、ArrayList和LinkedList通过下标查找元素的时间复杂度是多少？"><a href="#3、ArrayList和LinkedList通过下标查找元素的时间复杂度是多少？" class="headerlink" title="3、ArrayList和LinkedList通过下标查找元素的时间复杂度是多少？"></a>3、ArrayList和LinkedList通过下标查找元素的时间复杂度是多少？</h2><table>
<thead>
<tr>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="4、浅拷贝和深拷贝的区别？"><a href="#4、浅拷贝和深拷贝的区别？" class="headerlink" title="4、浅拷贝和深拷贝的区别？"></a>4、浅拷贝和深拷贝的区别？</h2><p><strong>浅拷贝和深拷贝的区别在于引用数据类型的拷贝。</strong></p>
<ul>
<li>浅拷贝在拷贝引用数据类型的时候，只是将引用数据类的地址引用复制一份，不会在内存中开辟一块新的地址空间来创建新的对象。</li>
<li>深拷贝会在内存中重新开辟一块地址空间，将原来的数据复制一份到新的内存中，创建一个新的对象。</li>
</ul>
<h2 id="5、数据结构中，与所使用的计算机无关的是数据的-？"><a href="#5、数据结构中，与所使用的计算机无关的是数据的-？" class="headerlink" title="5、数据结构中，与所使用的计算机无关的是数据的( )？"></a>5、数据结构中，与所使用的计算机无关的是数据的( )？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A．存储结构</span><br><span class="line">B．物理结构</span><br><span class="line">C．逻辑结构</span><br><span class="line">D．物理和存储结构</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">答案：C</span><br></pre></td></tr></table></figure>

<h2 id="6、有一张sal表结构数据如图一所示，写出SQL语句将表数据查询为图2所示的结果。"><a href="#6、有一张sal表结构数据如图一所示，写出SQL语句将表数据查询为图2所示的结果。" class="headerlink" title="6、有一张sal表结构数据如图一所示，写出SQL语句将表数据查询为图2所示的结果。"></a>6、有一张sal表结构数据如图一所示，写出SQL语句将表数据查询为图2所示的结果。</h2><ul>
<li><strong>图一</strong><br><img src="https://img-blog.csdnimg.cn/20200313191642534.png" alt="图一"></li>
<li><strong>图二</strong><br><img src="https://img-blog.csdnimg.cn/20200313191736753.png" alt="图二"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT years,</span><br><span class="line">sum(<span class="keyword">case</span> when quarter=<span class="string">&#x27;1&#x27;</span> then sales end) as <span class="string">&#x27;一季度&#x27;</span>,</span><br><span class="line">sum(<span class="keyword">case</span> when quarter=<span class="string">&#x27;2&#x27;</span> then sales end) as <span class="string">&#x27;二季度&#x27;</span>,</span><br><span class="line">sum(<span class="keyword">case</span> when quarter=<span class="string">&#x27;3&#x27;</span> then sales end) as <span class="string">&#x27;三季度&#x27;</span>,</span><br><span class="line">sum(<span class="keyword">case</span> when quarter=<span class="string">&#x27;4&#x27;</span> then sales end) as <span class="string">&#x27;四季度&#x27;</span></span><br><span class="line"> from sal group by years</span><br></pre></td></tr></table></figure>

<h2 id="7、MySQL数据库查询当前时间？"><a href="#7、MySQL数据库查询当前时间？" class="headerlink" title="7、MySQL数据库查询当前时间？"></a>7、MySQL数据库查询当前时间？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select CURRENT_DATE;		#查询当前日期</span><br><span class="line">select CURRENT_TIME;		#查询当前时间</span><br><span class="line">select <span class="title function_">now</span><span class="params">()</span>;				#查询当前日期和时间</span><br><span class="line">select <span class="title function_">SYSDATE</span><span class="params">()</span>;			#查询当前日期和时间</span><br></pre></td></tr></table></figure>


<h2 id="8、GET请求和POST请求的区别？"><a href="#8、GET请求和POST请求的区别？" class="headerlink" title="8、GET请求和POST请求的区别？"></a>8、GET请求和POST请求的区别？</h2><table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>后退按钮/刷新</td>
<td>无害</td>
<td>数据会被重新提交</td>
</tr>
<tr>
<td>书签</td>
<td>可收藏为书签</td>
<td>不可收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不可缓存</td>
</tr>
<tr>
<td>编码类型</td>
<td>application/x-www-form-urlencoded</td>
<td>application/x-www-form-urlencoded，multipart/form-data，application/json，text/xml</td>
</tr>
<tr>
<td>历史</td>
<td>参数保留在浏览器历史中</td>
<td>参数不会保留在浏览器历史中</td>
</tr>
<tr>
<td>对数据长度的限制</td>
<td>2kb</td>
<td>无限制</td>
</tr>
<tr>
<td>对数据类型的限制</td>
<td>只允许ASCII</td>
<td>没有限制，也运行二进制数据</td>
</tr>
<tr>
<td>安全性</td>
<td>与POST相比，GET的安全性较差，因为所发送的数据是URL中的一部分</td>
<td>POST比GET更安全，因为参数不会保存在浏览器历史或web服务器的日志中</td>
</tr>
<tr>
<td>可见性</td>
<td>数据在URL中对所有人都是可见的</td>
<td>数据不会显示在URL中</td>
</tr>
</tbody></table>
<h2 id="9、将字符串”abcdefg”反转，变为”gfedcba”。"><a href="#9、将字符串”abcdefg”反转，变为”gfedcba”。" class="headerlink" title="9、将字符串”abcdefg”反转，变为”gfedcba”。"></a>9、将字符串”abcdefg”反转，变为”gfedcba”。</h2><ul>
<li><strong>方法一：使用StringBuffer的方法reverse()，可以实现字符串的反转。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">System.out.println(sb.reverse());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法二：使用Java的栈集合先进后出的特点，将字符串反转。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">	stack.push(str.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法三：使用一个char数组，从后向前遍历该数组实现字符串的反转。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] ch = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ch.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">	System.out.print(ch[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列04</title>
    <url>/2020/03/18/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9704/</url>
    <content><![CDATA[<h2 id="1、请简述一下Git的分支管理？"><a href="#1、请简述一下Git的分支管理？" class="headerlink" title="1、请简述一下Git的分支管理？"></a>1、请简述一下Git的分支管理？</h2><p><strong>两种核心分支</strong></p>
<ul>
<li><strong>master分支</strong>存放的是随时可供在生产环境中部署的稳定版本代码。</li>
<li><strong>develop分支</strong>是保存当前最新开发成果的分支。<span id="more"></span></li>
</ul>
<p><strong>三种辅助分支</strong></p>
<ul>
<li><strong>功能(feature)分支：</strong> 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li>
<li><strong>预发布(release)分支：</strong> 当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li>
<li><strong>修补bug(hotfix)分支：</strong> 当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li>
</ul>
<h2 id="2、请说一下Web项目的分层结构？"><a href="#2、请说一下Web项目的分层结构？" class="headerlink" title="2、请说一下Web项目的分层结构？"></a>2、请说一下Web项目的分层结构？</h2><p><strong>JavaWeb一般分为三层架构，分别是：</strong></p>
<ul>
<li>数据访问层，即Dao层，主要用来封装对数据库的操作。</li>
<li>业务逻辑层，即Service层，主要用于处理具体的业务逻辑，即对Dao层的数据进行处理。</li>
<li>Web层，或者是Controller层，主要用于对前端请求作出响应。</li>
</ul>
<h2 id="3、请简述一下Spring的IOC和AOP？"><a href="#3、请简述一下Spring的IOC和AOP？" class="headerlink" title="3、请简述一下Spring的IOC和AOP？"></a>3、请简述一下Spring的IOC和AOP？</h2><p><strong>Spring的两大核心特征就是IOC（控制反转）和AOP（面向切面编程）。</strong></p>
<ul>
<li><strong>IOC：</strong> 控制反转，是Spring用来解决类与类之间的程序耦合问题的，因为Java代码需要通过类与类之间的相互协作来完成特定的业务逻辑，每个类都需要管理与自己有交互的类的引用和依赖，代码将会变得难以维护和极度的高耦合。而Spring IOC正是为了解决这个问题，将类与类之间的引用和依赖交给Spring IOC容器管理，每个对象只需要专注自己的业务逻辑即可，降低了程序之间的耦合度。</li>
<li><strong>AOP：</strong> 面向切面编程，AOP不是单独指某一种技术，而是一种编程思想，AOP是OOP的一种补充，用于处理各个业务逻辑中的横切关注点，比如日志记录，事务处理，性能统计，异常处理等等。AOP的主要功能是将大量的通用行为从业务逻辑中抽取出来，将这些行为封装成独立的非业务方法，用于横向切入，这些行为不会对已有的业务逻辑产生任何影响。AOP是一种设计思想，而Spring AOP则是符合AOP思想的一种框架实现。</li>
</ul>
<h2 id="4、怎么记录一个项目的访问日志？"><a href="#4、怎么记录一个项目的访问日志？" class="headerlink" title="4、怎么记录一个项目的访问日志？"></a>4、怎么记录一个项目的访问日志？</h2><p>可以使用Spring AOP技术，设置一个前置通知，记录访问开始时间和访问请求的具体信息，设置一个后置通知，记录响应的时间，并通过这些信息，处理获得请求的访问时长，访问方法，访问路径，访问用户等等信息。</p>
<h2 id="5、MyBatis中-和-的区别？"><a href="#5、MyBatis中-和-的区别？" class="headerlink" title="5、MyBatis中#{}和${}的区别？"></a>5、MyBatis中#{}和${}的区别？</h2><table>
<thead>
<tr>
<th>#{}</th>
<th>${}</th>
</tr>
</thead>
<tbody><tr>
<td>相当于的占位符</td>
<td>相当于字符串拼接</td>
</tr>
<tr>
<td>在传参的时候会先对SQL进行预编译</td>
<td>在传参的时候相当于字符串拼接</td>
</tr>
<tr>
<td>可以防止SQL注入</td>
<td>不能防止SQL注入</td>
</tr>
<tr>
<td>尽量使用</td>
<td>在需要传入表名或者列名的时候使用，比如order by</td>
</tr>
</tbody></table>
<h2 id="6、请简述一下left-join，right-join，inner-join？"><a href="#6、请简述一下left-join，right-join，inner-join？" class="headerlink" title="6、请简述一下left join，right join，inner join？"></a>6、请简述一下left join，right join，inner join？</h2><ul>
<li><strong>left join:</strong> 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li>
<li><strong>right join:</strong> 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li>
<li><strong>inner join:</strong> 在两张表进行连接查询时，只保留两张表中完全匹配的结果集。</li>
</ul>
<h2 id="7、数据库为什么要有事务？"><a href="#7、数据库为什么要有事务？" class="headerlink" title="7、数据库为什么要有事务？"></a>7、数据库为什么要有事务？</h2><p>所谓事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>
<h2 id="8、乐观锁和悲观锁？"><a href="#8、乐观锁和悲观锁？" class="headerlink" title="8、乐观锁和悲观锁？"></a>8、乐观锁和悲观锁？</h2><ul>
<li><strong>乐观锁：</strong> 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。</li>
<li><strong>悲观锁：</strong> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</li>
</ul>
<h2 id="9、SpringBoot设置端口号？"><a href="#9、SpringBoot设置端口号？" class="headerlink" title="9、SpringBoot设置端口号？"></a>9、SpringBoot设置端口号？</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<h2 id="10、数据库连接池？"><a href="#10、数据库连接池？" class="headerlink" title="10、数据库连接池？"></a>10、数据库连接池？</h2><ul>
<li>数据库连接是一种关键的有限的昂贵资源，无论是创建数据库连接还是关闭数据库连接，都会消耗大量的系统性能，频繁创建连接和关闭连接，会造成系统性能低下。</li>
<li>数据库连接池就是为了解决这个问题而诞生的，数据库连接池是在启动项目的时候，在程序中创建足够多的数据库连接池，当程序需要使用连接池的时候，就可以直接从数据库连接池中获取一个连接，使用完毕后则将连接归还到数据库连接池中。</li>
<li>数据库连接池技术尽可能地减少了系统资源的开销，大大节省了内存，提高了程序的运行效率。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列05——我的SQL为什么这么慢？</title>
    <url>/2020/03/18/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9705%E2%80%94%E2%80%94%E6%88%91%E7%9A%84SQL%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E6%85%A2/</url>
    <content><![CDATA[<h2 id="SQL执行速度慢的原因分析？"><a href="#SQL执行速度慢的原因分析？" class="headerlink" title="SQL执行速度慢的原因分析？"></a>SQL执行速度慢的原因分析？</h2><p><strong>SQL执行偶尔很慢</strong></p>
<ul>
<li>数据库在刷新脏页。</li>
<li>数据库无法获取锁。<span id="more"></span></li>
</ul>
<p><strong>SQL执行一直很慢</strong></p>
<ul>
<li>没有给字段设置索引或者字段设置了索引但是SQL没有用上。</li>
<li>IO吞吐量小，形成了瓶颈效应。</li>
<li>数据库内存不足。</li>
<li>SQL查询的数据量太大，或者返回了不必要的行和列。</li>
<li>如果SQL和数据库不再同一台服务器，那么还有可能是网络速度慢。</li>
</ul>
<h2 id="优化SQL执行速度慢的方法？"><a href="#优化SQL执行速度慢的方法？" class="headerlink" title="优化SQL执行速度慢的方法？"></a>优化SQL执行速度慢的方法？</h2><ul>
<li>根据查询条件，给数据库表建立索引，优化索引，优化访问方式。</li>
<li>横向、纵向拆分大表，减小表的尺寸。</li>
<li>优化SQL，多次查询少量数据，少使用*、distinct等关键字。</li>
<li>升级数据库服务器硬件，扩大内存。</li>
<li>提高网速。</li>
</ul>
<h2 id="怎么判断一条SQL是否是通过索引查询到的数据？"><a href="#怎么判断一条SQL是否是通过索引查询到的数据？" class="headerlink" title="怎么判断一条SQL是否是通过索引查询到的数据？"></a>怎么判断一条SQL是否是通过索引查询到的数据？</h2><ul>
<li>在select语句前加上explain就可以了。</li>
<li>查找出来的结果中有一个key属性，key属性是用来显示使用的索引的，如果key属性为null，那就说明没有使用索引。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index nameindex <span class="keyword">on</span> tb_user(name(<span class="number">10</span>));	#在tb_user表以name字段创建一个名为nameindex的索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;鞠婧祎&#x27;</span>;	#通过关键字explain查询</span><br></pre></td></tr></table></figure>
<img src="/images/2020/03/20200318202145836.png" alt="在这里插入图片描述"><h2 id="数据库的索引"><a href="#数据库的索引" class="headerlink" title="数据库的索引"></a>数据库的索引</h2></li>
</ul>
<p><strong>数据库索引的创建方式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX [索引名] <span class="keyword">ON</span> [表名]([列名](长度)); </span><br><span class="line"><span class="keyword">create</span> index nameindex <span class="keyword">on</span> tb_user(name(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p><strong>索引的数据结构</strong></p>
<ul>
<li>索引的底层是一个平衡树（非二叉树）。</li>
</ul>
<p><strong>索引的优点：</strong></p>
<ul>
<li>提高SQL的查询速度。</li>
</ul>
<p><strong>索引的缺点：</strong></p>
<ul>
<li>虽然索引可以提高SQL的查询速度，但是会降低SQL语句insert、update、delete语句的速度，因为这些语句不仅要操作数据表数据，还要维护索引数据。</li>
<li>索引会占用磁盘空间。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列06</title>
    <url>/2020/03/20/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9706/</url>
    <content><![CDATA[<h2 id="1、请简述一下SpringBoot？"><a href="#1、请简述一下SpringBoot？" class="headerlink" title="1、请简述一下SpringBoot？"></a>1、请简述一下SpringBoot？</h2><ul>
<li>SpringBoot是一个Spring框架的启动器，使用SpringBoot可以快速地搭建一个基于Spring框架的Web项目。</li>
<li>SpringBoot不是一个新的框架，而是Spring框架的延续和扩展。</li>
<li>SpringBoot使用约定大于配置的原则，默认配置了Spring项目中的大部分配置，所以我们使用SpringBoot搭建Spring项目可以省去Spring框架的大部分配置，简化我们的开发。<span id="more"></span>

</li>
</ul>
<h2 id="2、请简述一下SpringCloud？"><a href="#2、请简述一下SpringCloud？" class="headerlink" title="2、请简述一下SpringCloud？"></a>2、请简述一下SpringCloud？</h2><ul>
<li>SpringCloud并不是一个单独的框架，而是指一系列适用于解决分布式系统开发的框架集合。是一套用于治理微服务架构的解决方案。</li>
<li>SpringCloud是基于SpringBoot，SpringCloud的每个微服务，都是使用SpringBoot来进行开发的。</li>
</ul>
<h2 id="3、什么是微服务？"><a href="#3、什么是微服务？" class="headerlink" title="3、什么是微服务？"></a>3、什么是微服务？</h2><ul>
<li>微服务是指一个可以独立部署，水平拓展，独立访问的服务单元。</li>
<li>微服务单独运行在独立的进程中，并通过轻量级的通信机制进行通信，一般使用的是HTTP协议。</li>
<li>微服务强调技术独立，可以使用不同的语言编写或者不同的数据库存储，服务之间相互调用通过服务对外暴露的API接口进行，达到资源隔离的效果。</li>
</ul>
<h2 id="4、为什么要使用微服务，微服务有什么优势？"><a href="#4、为什么要使用微服务，微服务有什么优势？" class="headerlink" title="4、为什么要使用微服务，微服务有什么优势？"></a>4、为什么要使用微服务，微服务有什么优势？</h2><ul>
<li>微服务可以独立开发，独立部署服务，更容易扩展，解决了一体化架构中服务难以扩展的问题。</li>
<li>微服务开发速度快，敏捷性高，维护单个微服务不影响整体系统。</li>
<li>微服务围绕业务功能创建、组织代码，代码可维护性高。</li>
<li>自由（在某种程度上）选择实施技术/语言，实现了技术独立。</li>
</ul>
<h2 id="5、请简述一下HTTP协议？"><a href="#5、请简述一下HTTP协议？" class="headerlink" title="5、请简述一下HTTP协议？"></a>5、请简述一下HTTP协议？</h2><ul>
<li>HTPP是超文本传输协议，是当前互联网上使用最为广泛的一种传输协议，HTTP是网络传输的一种规范，是客户端和服务器端请求和响应的标准。</li>
<li>HTTP的默认端口号是80，HTTPS的默认端口号是443，HTTPS的HTTP的安全版本，是完全的Web传输协议。</li>
<li>HTTP是无连接的，即每次连接都只处理一次请求，响应完成之后断开连接，这种方式可以节省传输时间。</li>
<li>HTTP是无状态的，即HTTP的每次请求都是独立的，不会记忆之前的请求或数据。</li>
<li>HTTP可以传输任意类型的数据对象，常用的请求方法有GET、POST等。</li>
<li>HTTP的请求由三部分构成，分别是：<ul>
<li>请求行：请求方法，请求URL，HTTP协议版本</li>
<li>请求头：包含了一些请求客户端的信息，比如Cookie，Host，Accept等等</li>
<li>请求体：GET请求没有请求体，POST请求的请求体用于存放参数和请求数据</li>
</ul>
</li>
<li>HTTP的响应由三部分构成，分别是：<ul>
<li>响应行：HTTP协议版本，状态码，状态代码的文本描述</li>
<li>响应头：包含服务器发送非客户端的信息，比如Content-Type，Server等等</li>
<li>响应正文：服务器响应给客户端的响应数据</li>
</ul>
</li>
</ul>
<h2 id="6、请说一下HTTP协议的常见状态码及状态码的含义？"><a href="#6、请说一下HTTP协议的常见状态码及状态码的含义？" class="headerlink" title="6、请说一下HTTP协议的常见状态码及状态码的含义？"></a>6、请说一下HTTP协议的常见状态码及状态码的含义？</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>成功</td>
</tr>
<tr>
<td>301</td>
<td>永久重定向，请求资源被移动到新的URL</td>
</tr>
<tr>
<td>302</td>
<td>临时重定向</td>
</tr>
<tr>
<td>400</td>
<td>错误的请求，请求格式错误</td>
</tr>
<tr>
<td>401</td>
<td>当前请求需要通过用户验证</td>
</tr>
<tr>
<td>403</td>
<td>拒绝服务</td>
</tr>
<tr>
<td>404</td>
<td>资源没有找到</td>
</tr>
<tr>
<td>408</td>
<td>请求超时</td>
</tr>
<tr>
<td>500</td>
<td>服务器内部错误</td>
</tr>
<tr>
<td>502</td>
<td>服务器网关错误</td>
</tr>
<tr>
<td>504</td>
<td>服务器响应超时</td>
</tr>
</tbody></table>
<h2 id="7、什么是分布式事务（简述）？"><a href="#7、什么是分布式事务（简述）？" class="headerlink" title="7、什么是分布式事务（简述）？"></a>7、什么是分布式事务（简述）？</h2><ul>
<li>分布式事务是指在分布式环境下的不同节点上的一系列操作，这一系列操作要么全部执行成功，要么全部执行失败。</li>
<li>分布式事务是为了保证分布式环境下的数据一致性。</li>
</ul>
<h2 id="8、什么是分布式锁（简述）？"><a href="#8、什么是分布式锁（简述）？" class="headerlink" title="8、什么是分布式锁（简述）？"></a>8、什么是分布式锁（简述）？</h2><ul>
<li>分布式锁就是指在分布式环境下，需要保证一个方法在同一时间只能被一个线程调用。</li>
<li>分布式锁是为了保证数据的一致性而进行的加锁操作。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列07</title>
    <url>/2020/03/25/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9707/</url>
    <content><![CDATA[<h2 id="1、请问下面代码的执行结果是？"><a href="#1、请问下面代码的执行结果是？" class="headerlink" title="1、请问下面代码的执行结果是？"></a>1、请问下面代码的执行结果是？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;G:\\temp\\empty&quot;</span>);</span><br><span class="line">	System.out.println(file.canWrite());</span><br><span class="line">	System.out.println(file.canRead());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果文件目录存在，结果为：<span class="literal">true</span>，<span class="literal">true</span>。</span><br><span class="line">如果文件目录不存在，结果为：<span class="literal">false</span>，<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>
<h2 id="2、下面代码的输出结果为？"><a href="#2、下面代码的输出结果为？" class="headerlink" title="2、下面代码的输出结果为？"></a>2、下面代码的输出结果为？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">initial</span> <span class="operator">=</span> <span class="string">&quot;ABCDEFG&quot;</span>, after = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    after = initial = initial.replace(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">    System.out.println(initial + <span class="string">&quot;, &quot;</span> + after);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行结果为：ZBCDEFG, ZBCDEFG</span><br></pre></td></tr></table></figure>

<h2 id="3、请问下面的代码是否能够正常编译？"><a href="#3、请问下面的代码是否能够正常编译？" class="headerlink" title="3、请问下面的代码是否能够正常编译？"></a>3、请问下面的代码是否能够正常编译？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">final</span><span class="params">()</span> &#123;</span><br><span class="line">    test++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">final</span>() | <span class="keyword">final</span>()) || <span class="keyword">final</span>()) </span><br><span class="line">        test++; </span><br><span class="line">    System.out.println(test); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">不能</span><br><span class="line"><span class="number">1</span>、因为<span class="keyword">final</span>是Java中的关键字，不能作为方法名。</span><br><span class="line"><span class="number">2</span>、静态方法不能调用非静态方法，所以<span class="keyword">final</span>方法需要添加<span class="keyword">static</span>关键字修饰。</span><br></pre></td></tr></table></figure>
<h2 id="4、请简述一下Applet生命周期？"><a href="#4、请简述一下Applet生命周期？" class="headerlink" title="4、请简述一下Applet生命周期？"></a>4、请简述一下Applet生命周期？</h2><ul>
<li><strong>init()方法：</strong> 当Applet在创建的时候会执行<code>init()</code>方法。</li>
<li><strong>start()方法：</strong> 当执行完<code>init()</code>方法之后，会执行<code>start()</code>方法。</li>
<li><strong>paint()方法:</strong> 当执行完<code>start()</code>方法之后，如果Applet调整浏览器窗口大小，会执行<code>paint()</code>方法。</li>
<li><strong>stop()方法：</strong> 用于停止Applet，当Apple停止或者最小化浏览器窗口的时候，会执行<code>stop()</code>方法。</li>
<li><strong>destory()方法：</strong> 用于销毁Applet，当关闭浏览器后悔执行<code>destory()</code>方法。</li>
</ul>
<p><strong>Applet的生命周期以<code>init()</code>方法开始，以<code>destory()</code>方法结束，且这两个方法只会执行一次，但是<code>start()</code>、<code>paint()</code>、<code>stop()</code>方法会执行多次。</strong></p>
<h2 id="5、请编写一条SQL语句，从user表中获取name为Bod和Mike的用户的所有信息。"><a href="#5、请编写一条SQL语句，从user表中获取name为Bod和Mike的用户的所有信息。" class="headerlink" title="5、请编写一条SQL语句，从user表中获取name为Bod和Mike的用户的所有信息。"></a>5、请编写一条SQL语句，从user表中获取name为Bod和Mike的用户的所有信息。</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;Bod&#x27;</span>,<span class="string">&#x27;Mike&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Bod&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;Mike&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="6、程序编写，判断字符串是否为回文？"><a href="#6、程序编写，判断字符串是否为回文？" class="headerlink" title="6、程序编写，判断字符串是否为回文？"></a>6、程序编写，判断字符串是否为回文？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdcba&quot;</span>;</span><br><span class="line">	System.out.println(isPalindrome(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>,end = str.length()-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str.charAt(start++) != str.charAt(end--)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、请问下面代码的输出结果，为什么？"><a href="#7、请问下面代码的输出结果，为什么？" class="headerlink" title="7、请问下面代码的输出结果，为什么？"></a>7、请问下面代码的输出结果，为什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	System.out.println(str1.equals(str2));</span><br><span class="line">	<span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	<span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	System.out.println(sb1.equals(sb2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">因为在Java语言中，String类重写了equals()方法，但是StringBuffer类没有重写equals()方法。</span><br></pre></td></tr></table></figure>
<h2 id="8、下面代码的结果是什么，为什么？"><a href="#8、下面代码的结果是什么，为什么？" class="headerlink" title="8、下面代码的结果是什么，为什么？"></a>8、下面代码的结果是什么，为什么？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	System.out.println(i1 == i2);</span><br><span class="line">	i1 = <span class="number">200</span>;</span><br><span class="line">	i2 = <span class="number">200</span>;</span><br><span class="line">	System.out.println(i1 == i2);</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	System.out.println(in1 == in2);</span><br><span class="line">	in1 = <span class="number">200</span>;</span><br><span class="line">	in1 = <span class="number">200</span>;</span><br><span class="line">	System.out.println(in1 == in2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">因为基本数据类类型使用==比较的是值，而引用数据类型使用==比较的是引用。</span><br><span class="line">但是Integer类型的值如果在[-<span class="number">128</span>,<span class="number">127</span>]之间的话，那么会使用Integer类中的缓存，而不会创建新的对象。</span><br><span class="line">所以最后一个比较值为<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列08</title>
    <url>/2021/03/13/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9708/</url>
    <content><![CDATA[<h2 id="说一下Java对象的创建过程"><a href="#说一下Java对象的创建过程" class="headerlink" title="说一下Java对象的创建过程"></a>说一下Java对象的创建过程</h2><p>Java对象的创建过程一共分为五个步骤：</p>
<span id="more"></span>
<p>1、当创建一个对象的时候，JVM 会去常量池中找该类的符号引用，并且检查该类还有没有被 JVM 加载过，如果没有，则进行类的加载过程。</p>
<p>2、在类加载检查通过之后，JVM 开始在 Java 堆中为对象分配具体的内存空间。</p>
<p>3、对象内存分配完成之后，JVM 会给 Java 对象除了对象头之外的示例数据初始化零值。这就是为什么类变量可以不需要手动进行初始化值，就可以使用的原因，而局部变量需要手动赋值才可以使用。</p>
<p>4、设置对象头，给对象头设置一些信息。比如：对象的哈希吗，对象的 GC 分代年龄，指向类的元数据信息的指针，锁信息等等。</p>
<p>5、执行对象的 init 方法，比如执行普通代码块，构造函数等等。</p>
<h2 id="简单聊聊-JVM-内存分配与回收"><a href="#简单聊聊-JVM-内存分配与回收" class="headerlink" title="简单聊聊 JVM 内存分配与回收"></a>简单聊聊 JVM 内存分配与回收</h2><p>Java 内存管理主要是针对对象内存的分配和对象内存的回收。</p>
<p>Java 堆是垃圾收集管理的主要区域，因此 Java 堆也被称作 GC 堆。从垃圾回收的角度，目前的垃圾回收器基本上采用的是分代垃圾收集算法，所以 Java 堆也被划分为多个区域。</p>
<p>Java 堆主要分为新生代和老年代，其中新生代又分为 <code>Eden</code> 空间、<code>From Survivor</code>、<code>To Survivor</code> 等空间。</p>
<p>1、当创建一个新的对象，对象会被分配到 Eden 空间。</p>
<p>2、如果该对象经历过一次垃圾回收之后，该对象还存活，则会将该对象移动到 <code>From Survivor</code> 或者 <code>To Survivor</code> 区域，并且该对象的年龄变为 1 岁。</p>
<p>3、该对象在  <code>From Survivor</code> 或者 <code>To Survivor</code> 区域 每经过一次垃圾回收，年龄就会 +1 。当对象年龄达到晋升老年代区域的阈值的时候，就会将该对象移动至老年代区域。晋升老年代区域的阈值默认为 15 岁，并且该阈值可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h2 id="说一下堆内存中对象的分配的基本策略"><a href="#说一下堆内存中对象的分配的基本策略" class="headerlink" title="说一下堆内存中对象的分配的基本策略"></a>说一下堆内存中对象的分配的基本策略</h2><p>1、对象优先分配在 Eden 区域，当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC 。</p>
<p>2、大对象直接进入老年代，比如字符串和数组。</p>
<p>3、年龄大的对象，进入老年区。对象在 Eden 区域经过一次 GC ，移动到Survivor 区域，年龄为1岁，然后每经过一次 GC ，对象年龄 +1 ，当对象年龄达到晋升老年代区域的阈值年龄时，对象移动到老年代，晋升老年代区域的阈值年龄默认为 15 岁，并且该阈值可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h2 id="如何判断对象是否死亡"><a href="#如何判断对象是否死亡" class="headerlink" title="如何判断对象是否死亡"></a>如何判断对象是否死亡</h2><p>1、引用计数法</p>
<p>给对象添加一个引用计数器，每当有一个地方引用该对象，则计数器 +1 ，如果引用失效，则计数器 -1 ，计数器为 0 的对象将不可以再被使用，即被判定为死亡。</p>
<p>2、可达性分析算法</p>
<p>这个算法是通过一系列被称作 <code>GC Roots</code> 的对象作为起点，从这些节点依次向下搜索，该节点走过的路径被称为引用链，凡是在引用链上的对象，则对象可用，如果一个对象没有到达 <code>GC Roots</code> 的引用链相连接的话，则说明该对象不可用，判断为死亡。</p>
<h2 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h2><p>当一个常量没有被任何变量所引用的时候，就将该变量称为废弃变量，这时如果发生 GC ，并且内存不足的时候，就会将废弃变量回收。</p>
<h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h2><p>满足以下三点，该类则被称作无用的类：</p>
<p>1、该类的所有对象实例都已经被回收。</p>
<p>2、加载该类的 <code>ClassLoader</code> 被回收。</p>
<p>3、该类对应的 <code>java.lang.Class</code> 对象在任何地方都没有被引用，程序无法通过反射访问该类的方法。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试系列09</title>
    <url>/2021/03/17/interview/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%9709/</url>
    <content><![CDATA[<h2 id="简单介绍一下-Spring-有啥缺点"><a href="#简单介绍一下-Spring-有啥缺点" class="headerlink" title="简单介绍一下 Spring?有啥缺点?"></a>简单介绍一下 Spring?有啥缺点?</h2><p>答：Spring框架中使用了大量的反射操作，比起原生的 Java 代码更加消耗性能。</p>
<span id="more"></span>
<h2 id="说出使用-Spring-Boot-的主要优点"><a href="#说出使用-Spring-Boot-的主要优点" class="headerlink" title="说出使用 Spring Boot 的主要优点"></a>说出使用 Spring Boot 的主要优点</h2><p>1、SpringBoot 是对 Spring 框架的二次封装，简化了 Spirng 框架繁琐的配置，能够进行自动装配。</p>
<p>2、SpringBoot 提供了内嵌的 Tomcat 容器，能够将项目打包成 jar 包独立运行。</p>
<p>3、SpringBoot 能够很轻松地集成第三方的框架。</p>
<h2 id="什么是-Spring-Boot-Starters"><a href="#什么是-Spring-Boot-Starters" class="headerlink" title="什么是 Spring Boot Starters?"></a>什么是 Spring Boot Starters?</h2><p>答：Spring Boot Starters 是一个启动器，里面包含了程序需要集成的一系列依赖，使用 Starters 可以快速使用一项技术，而不用考虑其他繁琐的问题。</p>
<p>其中 SpringBoot 的官方依赖都以 <code>spring-boot-starter-</code> 命名，而第三方的 Stater 则以 <code>-spring-boot-starter</code> 命名。</p>
<h2 id="Spring-Boot-支持哪些内嵌-Servlet-容器？"><a href="#Spring-Boot-支持哪些内嵌-Servlet-容器？" class="headerlink" title="Spring Boot 支持哪些内嵌 Servlet 容器？"></a>Spring Boot 支持哪些内嵌 Servlet 容器？</h2><p>答：Tomcat、jetty、undertow</p>
<h2 id="如何在-Spring-Boot-应用程序中使-undertow-而不是-Tomcat"><a href="#如何在-Spring-Boot-应用程序中使-undertow-而不是-Tomcat" class="headerlink" title="如何在 Spring Boot 应用程序中使 undertow 而不是 Tomcat?"></a>如何在 Spring Boot 应用程序中使 undertow 而不是 Tomcat?</h2><p>答：排除 <code>Tomcat</code> 容器，引入 <code>undertow</code> 容器的 Starter 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除Tomcat容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--替换内置默认容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="介绍一下-SpringBootApplication-注解"><a href="#介绍一下-SpringBootApplication-注解" class="headerlink" title="介绍一下@SpringBootApplication 注解"></a>介绍一下@SpringBootApplication 注解</h2><p>答：SpringBootApplication 注解是一个复合型注解，其中包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 三个注解。</p>
<h2 id="开发-RESTful-Web-服务常用的注解有哪些？"><a href="#开发-RESTful-Web-服务常用的注解有哪些？" class="headerlink" title="开发 RESTful Web 服务常用的注解有哪些？"></a>开发 RESTful Web 服务常用的注解有哪些？</h2><p>答：<br><code>@RestController</code>、<code>@RequestMapper</code>、<code>@GetMapper</code>、<code>@PostMapper</code>、<code>@PutMapper</code>、<code>@DeleteMapper</code>、<code>@PathVariable</code>、<code>@RequestBody</code>、<code>@RequestParam</code></p>
<h2 id="Spirng-Boot-常用的两种配置文件"><a href="#Spirng-Boot-常用的两种配置文件" class="headerlink" title="Spirng Boot 常用的两种配置文件"></a>Spirng Boot 常用的两种配置文件</h2><p>答：<code>application.yml</code>、<code>application.properties</code></p>
<h2 id="什么是-YAML？YAML-配置的优势在哪里"><a href="#什么是-YAML？YAML-配置的优势在哪里" class="headerlink" title="什么是 YAML？YAML 配置的优势在哪里 ?"></a>什么是 YAML？YAML 配置的优势在哪里 ?</h2><p>答：YAML 是一种数据序列化语言、是一种可读的文本数据结构。YAML的优势在于：易于阅读，程序易于解析，能够使用本地数据结构进行存储。</p>
<h2 id="Spring-Boot-常用的读取配置文件的方法有哪些？"><a href="#Spring-Boot-常用的读取配置文件的方法有哪些？" class="headerlink" title="Spring Boot 常用的读取配置文件的方法有哪些？"></a>Spring Boot 常用的读取配置文件的方法有哪些？</h2><p>答：<br>1、<code>@Value</code> 注解读取文件<br>2、<code>@ConfigurationProperties</code></p>
<h2 id="Spring-Boot-如何做请求参数校验？"><a href="#Spring-Boot-如何做请求参数校验？" class="headerlink" title="Spring Boot 如何做请求参数校验？"></a>Spring Boot 如何做请求参数校验？</h2><p>答：可以使用 <code>spring-boot-starter-validation</code> 框架进行注解式参数校验。</p>
<h2 id="如何使用-Spring-Boot-实现全局异常处理？"><a href="#如何使用-Spring-Boot-实现全局异常处理？" class="headerlink" title="如何使用 Spring Boot 实现全局异常处理？"></a>如何使用 Spring Boot 实现全局异常处理？</h2><p>答：可以使用 <code>@ControllerAdvice</code> 和 <code>@ExceptionHandler</code> 注解实现全局异常处理。</p>
<h2 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h2><p>答：可以使用 <code>@Scheduled</code> 注解实现定时任务。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA Java项目JDK无效</title>
    <url>/2020/08/10/java/IDEA%20Java%E9%A1%B9%E7%9B%AEJDK%E6%97%A0%E6%95%88/</url>
    <content><![CDATA[<p>今天在创建一个新的Java项目的时候，发现项目的JDK失效了，导致main方法的String类爆红，而且其他JDK的类也无法使用。</p>
<span id="more"></span>
<p>一开始我以为是项目资源的Project SDK没有设置，但是我打开File-&gt;Project Structure的时候，发现SDK已经设置了。<br><img src="/images/2020/08/20200810221241367.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>最终我发现，该问题其实是因为设置了忽略文件导致的。</p>
</blockquote>
<p><img src="/images/2020/08/20200810221422533.png" alt="在这里插入图片描述"><br>由于我在Ignore Files and Folders中设置了<code>*.classes</code>,导致项目无法依赖JDK下的包，所以才导致了这个问题，我们把Ignore Files and Folders中的<code>*.classes</code>删除即可解决该问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA使用Spring Initializr创建Spring项目</title>
    <url>/2020/03/31/java/IDEA%E4%BD%BF%E7%94%A8Spring%20Initializr%E5%88%9B%E5%BB%BASpring%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>今天我们来学习使用 IDEA 自带的 Spring Initializr 项目来创建一个全新的 Spring 项目。</p>
<span id="more"></span>
<h2 id="1、创建一个Module项目"><a href="#1、创建一个Module项目" class="headerlink" title="1、创建一个Module项目"></a>1、创建一个Module项目</h2><p><img src="/images/2020/03/20200331091443775.png" alt="在这里插入图片描述"></p>
<h2 id="2、选择Spring-Initializr创建项目。"><a href="#2、选择Spring-Initializr创建项目。" class="headerlink" title="2、选择Spring_Initializr创建项目。"></a>2、选择Spring_Initializr创建项目。</h2><p><img src="/images/2020/03/20200331091705922.png" alt="在这里插入图片描述"></p>
<h2 id="3、设置项目的基本信息"><a href="#3、设置项目的基本信息" class="headerlink" title="3、设置项目的基本信息"></a>3、设置项目的基本信息</h2><p><img src="/images/2020/03/20200331091740988.png" alt="在这里插入图片描述"></p>
<h2 id="4、选择项目所需的依赖"><a href="#4、选择项目所需的依赖" class="headerlink" title="4、选择项目所需的依赖"></a>4、选择项目所需的依赖</h2><p><img src="/images/2020/03/20200331091808586.png" alt="在这里插入图片描述"></p>
<h2 id="5、创建SpringBoot项目"><a href="#5、创建SpringBoot项目" class="headerlink" title="5、创建SpringBoot项目"></a>5、创建SpringBoot项目</h2><p><img src="/images/2020/03/20200331091826459.png" alt="在这里插入图片描述"></p>
<h2 id="6、项目结构图"><a href="#6、项目结构图" class="headerlink" title="6、项目结构图"></a>6、项目结构图</h2><p><img src="/images/2020/03/20200331092101572.png" alt="在这里插入图片描述"></p>
<h2 id="7、项目pom-xml文件"><a href="#7、项目pom-xml文件" class="headerlink" title="7、项目pom.xml文件"></a>7、项目pom.xml文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring_initializr_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring_initializr_demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8新特性之Optional类</title>
    <url>/2021/04/06/java/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="什么是-Optional-类？"><a href="#什么是-Optional-类？" class="headerlink" title="什么是 Optional 类？"></a>什么是 Optional 类？</h1><p>Optional 是 JDK8 新增加的一个工具类，位于 <code>java.util</code> 包下。</p>
<p>Optional 类是一个可以为 <code>null</code> 的容器对象。如果值存在则 isPresent() 方法会返回 <code>true</code>，调用 get() 方法会返回该对象。</p>
<p>Optional 是个容器：它可以保存类型 <code>T</code> 的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional 类的引入很好的解决空指针异常（微笑）。</p>
<span id="more"></span>

<h1 id="Optional-类的方法及使用"><a href="#Optional-类的方法及使用" class="headerlink" title="Optional 类的方法及使用"></a>Optional 类的方法及使用</h1><p>Optional 类中提供了一些常用的方法，同时结合 JDK8 的 Lambda 新特性使用，能够更加方便。</p>
<h2 id="私有构造"><a href="#私有构造" class="headerlink" title="私有构造"></a>私有构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Optional 类中，构造函数被私有访问修饰符修饰，也就意味着我们无法使用 <code>new</code> 关键字来创建对象。</p>
<h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty != <span class="literal">null</span>);</span><br><span class="line">System.out.println(empty);</span><br></pre></td></tr></table></figure>

<p>使用 <code>Optional</code> 类的静态方法 <code>empty()</code> ，可以创建一个容器内值为 <code>null</code> 的 <code>Optional</code> 对象。使用该方法，得到的 <code>Optional</code> 类是存在的，只不过该类中的值为 <code>null</code>。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="of-T-value"><a href="#of-T-value" class="headerlink" title="of(T value)"></a>of(T value)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.of(user1);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optionalUser2 = Optional.of(user2);</span><br></pre></td></tr></table></figure>

<p><code>of(T value)</code> 方法是 <code>Optional</code> 类创建容器的主要方法，使用该方法，可以创建一个泛型为 <code>T</code> 的 <code>Optional</code> 容器，并向容器内注入一个值对象。</p>
<p>需要注意的是，使用 <code>of(T value)</code> 方法，参数不可以为 <code>null</code>，否则程序会报空指针异常。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ofNullable-T-value"><a href="#ofNullable-T-value" class="headerlink" title="ofNullable(T value)"></a>ofNullable(T value)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optionalUser2 = Optional.ofNullable(user2);</span><br></pre></td></tr></table></figure>

<p><code>ofNullable(T value)</code> 方法和 <code>of(T value)</code> 方法唯一的区别在于，参数可以为 <code>null</code>，如果参数为 <code>null</code>，会调用 <code>empty()</code> 方法返回一个空的 <code>Optional</code> 对象。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line">optionalUser1.get();</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optionalUser2 = Optional.ofNullable(user2);</span><br><span class="line">optionalUser2.get();</span><br></pre></td></tr></table></figure>
<p><code>get()</code> 方法，用于返回 <code>Optional</code> 容器中的值对象。但是如果 <code>Optional</code> 容器为一个空容器，即内部的值为 <code>null</code>，则会抛出 <code>NoSuchElementException</code> 异常。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent()"></a>isPresent()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line">System.out.println(optionalUser1.isPresent());</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optionalUser2 = Optional.ofNullable(user2);</span><br><span class="line">System.out.println(optionalUser2.isPresent());</span><br></pre></td></tr></table></figure>
<p><code>isPresent()</code> 方法，用于判断 <code>Optional</code> 容器内是否有值，有则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ifPresent-Consumer-lt-super-T-gt-consumer"><a href="#ifPresent-Consumer-lt-super-T-gt-consumer" class="headerlink" title="ifPresent(Consumer&lt;? super T&gt; consumer)"></a>ifPresent(Consumer&lt;? super T&gt; consumer)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line">optionalUser1.ifPresent((o) -&gt; System.out.println(o));</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;User&gt; optionalUser2 = Optional.ofNullable(user2);</span><br><span class="line">optionalUser2.ifPresent((o) -&gt; System.out.println(o));</span><br></pre></td></tr></table></figure>

<p><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code> 方法，参数是一个消费型函数式接口，可以配合 Lambda 表达式使用。<br>该方法的作用为：如果 <code>Optional</code> 容器中有值，则执行 <code>Consumer</code> 接口中的方法，否则不做其他任何操作。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="filter-Predicate-lt-super-T-gt-predicate"><a href="#filter-Predicate-lt-super-T-gt-predicate" class="headerlink" title="filter(Predicate&lt;? super T&gt; predicate)"></a>filter(Predicate&lt;? super T&gt; predicate)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user1.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line">System.out.println(optionalUser1.filter((o) -&gt; o.getUsername().equals(<span class="string">&quot;zhangsan&quot;</span>)));;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user2.setUsername(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">Optional&lt;User&gt; optionalUser2 = Optional.ofNullable(user2);</span><br><span class="line">System.out.println(optionalUser2.filter((o) -&gt; o.getUsername().equals(<span class="string">&quot;zhangsan&quot;</span>)));;</span><br></pre></td></tr></table></figure>

<p><code>filter(Predicate&lt;? super T&gt; predicate)</code> 方法用于过滤 <code>Optional</code> 容器中的值，如果 容器内的值符合 <code>Predicate</code> 函数所定义的接口，即返回 <code>true</code>，则返回原来的 <code>Optional</code> 对象，否则返回空的 <code>Optional</code> 容器对象。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="map-Function-lt-super-T-extends-U-gt-mapper"><a href="#map-Function-lt-super-T-extends-U-gt-mapper" class="headerlink" title="map(Function&lt;? super T, ? extends U&gt; mapper)"></a>map(Function&lt;? super T, ? extends U&gt; mapper)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user1.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line">System.out.println(optionalUser1.map((o) -&gt; o.getUsername()).get());</span><br></pre></td></tr></table></figure>

<p><code>map(Function&lt;? super T, ? extends U&gt; mapper)</code> 方法，可以将 <code>Optional</code> 容器内的值替换为其他类型的值，具体的替换规则由 <code>Function</code> 函数定义。<br>例如上面的代码中，将 <code>User</code> 类型的 <code>Optional</code> 容器替换为了 <code>String</code> 类型的 <code>Optional</code> 容器。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="flatMap-Function-lt-super-T-Optional-gt-mapper"><a href="#flatMap-Function-lt-super-T-Optional-gt-mapper" class="headerlink" title="flatMap(Function&lt;? super T, Optional&gt; mapper)"></a>flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user1.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line">System.out.println(optionalUser1.flatMap((o) -&gt; Optional.ofNullable(o.getUsername())).get());</span><br></pre></td></tr></table></figure>

<p>该方法与 <code>map(Function&lt;? super T, ? extends U&gt; mapper)</code> 方法类似，不过该方法要求在 <code>Function</code> 函数中返回 <code>Optional</code> 对象，并且返回的 <code>Optional</code> 对象不允许为 <code>null</code>。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="orElse-T-other"><a href="#orElse-T-other" class="headerlink" title="orElse(T other)"></a>orElse(T other)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> optionalUser1.orElse(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure>

<p> <code>orElse(T other)</code> 方法和 <code>get()</code> 方法类似，不过比 <code>get()</code> 方法多了一层保险机制，如果 <code>Optional</code> 容器中的值为 <code>null</code>，则会返回 <code>orElse(T other)</code> 方法参数中的对象，该参数类型必须和 <code>Optional</code> 泛型类型一致。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="orElseGet-Supplier-lt-extends-T-gt-other"><a href="#orElseGet-Supplier-lt-extends-T-gt-other" class="headerlink" title="orElseGet(Supplier&lt;? extends T&gt; other)"></a>orElseGet(Supplier&lt;? extends T&gt; other)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> optionalUser1.orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure>

<p>该方法和功能类似，不过和 orElse(T other) 方法不同的是， <code>Optional</code> 容器中的值为 <code>null</code>时返回的对象通过生产型函数接口来创建并返回。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="orElseThrow-Supplier-lt-extends-X-gt-exceptionSupplier"><a href="#orElseThrow-Supplier-lt-extends-X-gt-exceptionSupplier" class="headerlink" title="orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)"></a>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Optional&lt;User&gt; optionalUser1 = Optional.ofNullable(user1);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> optionalUser1.orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;抛出异常信息&quot;</span>));</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure>

<p>该方法的逻辑和 <code>orElse(T other)</code>、<code>orElseGet(Supplier&lt;? extends T&gt; other)</code> 基本类似，不过当 <code>Optional</code> 容器的值为 <code>null</code> 时，会抛出生产型函数返回的异常对象。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p><code>Optional</code> 类除了上述的特有方法之外，还重写了 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 等通用方法，在本篇文章中不做过多的讲述。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8新特性之Stream流</title>
    <url>/2020/03/15/java/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/</url>
    <content><![CDATA[<h1 id="什么是Stream流？"><a href="#什么是Stream流？" class="headerlink" title="什么是Stream流？"></a>什么是Stream流？</h1><p>Stream流是JDK8中的一个全新的概念，用于解决已有集合类库既有的弊端。</p>
<span id="more"></span>
<h2 id="传统集合遍历的弊端"><a href="#传统集合遍历的弊端" class="headerlink" title="传统集合遍历的弊端"></a>传统集合遍历的弊端</h2><ul>
<li>每当我们需要对集合中的元素进行操作的时候，总是需要循环、循环、再循环，循环是遍历集合的方式，而不是目的，我们的目的是将集合中的元素全部都处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	list.add(<span class="string">&quot;我爱中国&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;第二元素&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;第三元素&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;东西南北&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;碳元素&quot;</span>);	</span><br><span class="line">	<span class="comment">//对list集合中的元素进行过滤，将包含&quot;元素&quot;的元素放入listA集合</span></span><br><span class="line">	List&lt;String&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str.contains(<span class="string">&quot;元素&quot;</span>)) &#123;</span><br><span class="line">			listA.add(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//对listA集合中的元素进行过滤，将包含&quot;三&quot;的元素放入listB集合</span></span><br><span class="line">	List&lt;String&gt; listB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String str : listA) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str.contains(<span class="string">&quot;三&quot;</span>)) &#123;</span><br><span class="line">			listB.add(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历listB集合，输出元素</span></span><br><span class="line">	<span class="keyword">for</span> (String str : listB) &#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream的方式"><a href="#Stream的方式" class="headerlink" title="Stream的方式"></a>Stream的方式</h2><ul>
<li>使用Stream流的方式，可以更简单高效的方式处理集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	list.add(<span class="string">&quot;我爱中国&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;第二元素&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;第三元素&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;东西南北&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;碳元素&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	list.stream()</span><br><span class="line">		.filter(name-&gt;name.contains(<span class="string">&quot;元素&quot;</span>))</span><br><span class="line">		.filter(name-&gt;name.contains(<span class="string">&quot;三&quot;</span>)).forEach(name-&gt;System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两种获取Stream流的方式"><a href="#两种获取Stream流的方式" class="headerlink" title="两种获取Stream流的方式"></a>两种获取Stream流的方式</h1><p>java.util.stream.Stream是JDK8新加入的最常用的流接口（这不是一个函数式接口）。</p>
<ul>
<li>所有Collection集合都可以通过stream默认方法获取流。</li>
<li>Stream接口中的静态方法of可以获取数组对应的流。</li>
</ul>
<h2 id="根据stream-方法获取流"><a href="#根据stream-方法获取流" class="headerlink" title="根据stream()方法获取流"></a>根据stream()方法获取流</h2><p>Collection接口中有一个默认方法stream()，所有Collection集合都可以通过这个方法来获取流。</p>
<ul>
<li>Map集合无法直接通过这种方式获取流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//List集合获取流对象</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set集合获取流对象</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Map集合的keySet获取流对象</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//获取map集合的键stream流</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">Stream&lt;String&gt; stream3 = keySet.stream();</span><br><span class="line"><span class="comment">//获取map集合的值stream流</span></span><br><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">Stream&lt;String&gt; stream4 = values.stream();</span><br><span class="line"><span class="comment">//获取map集合键值对的stream流</span></span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">Stream&lt;Entry&lt;String, String&gt;&gt; stream5 = entries.stream();</span><br></pre></td></tr></table></figure>

<h2 id="根据of-方法获取流"><a href="#根据of-方法获取流" class="headerlink" title="根据of()方法获取流"></a>根据of()方法获取流</h2><p>Stream接口中的静态方法of()，参数是一个可变参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接传入可变数组</span></span><br><span class="line">Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//传入一个整形数组</span></span><br><span class="line">Integer[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream7 = Stream.of(arr1);</span><br><span class="line"><span class="comment">//传入一个字符串数组</span></span><br><span class="line">String[] arr2 = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream8 = Stream.of(arr2);</span><br></pre></td></tr></table></figure>

<h1 id="Stream流中的常用方法"><a href="#Stream流中的常用方法" class="headerlink" title="Stream流中的常用方法"></a>Stream流中的常用方法</h1><p>Stream流中的方法被分成两种：</p>
<ul>
<li><strong>延迟方法：</strong> 返回值类型仍然是Stream流接口自身类型的方法，因此支持链式编程（除了终结方法外，其余方法均为延迟方法）。</li>
<li><strong>终结方法：</strong> 返回值类型不再是Stream流接口自身类型的方法，因此不再支持链式编程调用。</li>
</ul>
<h2 id="延迟方法"><a href="#延迟方法" class="headerlink" title="延迟方法"></a>延迟方法</h2><p><strong>过滤：filter</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream2 = stream1.filter(name-&gt;name.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">stream2.forEach(name-&gt;System.out.println(name));</span><br></pre></td></tr></table></figure>
<p><strong>映射： map</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream2 = stream1.map(str-&gt;Integer.parseInt(str));</span><br><span class="line">stream2.forEach(i-&gt;System.out.println(i));</span><br></pre></td></tr></table></figure>
<p><strong>切割前几个元素：limit</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream2 = stream1.limit(<span class="number">3</span>);</span><br><span class="line">stream2.forEach(str-&gt;System.out.println(str));</span><br></pre></td></tr></table></figure>

<p><strong>跳过前几个元素：skip</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream2 = stream1.skip(<span class="number">3</span>);</span><br><span class="line">stream2.forEach(str-&gt;System.out.println(str));</span><br></pre></td></tr></table></figure>
<p><strong>组合：concat</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;美羊羊&quot;</span>,<span class="string">&quot;懒羊羊&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream2 = Stream.of(<span class="string">&quot;灰太狼&quot;</span>,<span class="string">&quot;红太狼&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream3 = Stream.concat(stream1, stream2);</span><br><span class="line">stream3.forEach(str-&gt;System.out.println(str));</span><br></pre></td></tr></table></figure>

<h2 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h2><p><strong>逐一处理：forEach</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">	stream.forEach(name-&gt;System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>统计个数：count</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stream.count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>


<h1 id="Stream流属于管道流"><a href="#Stream流属于管道流" class="headerlink" title="Stream流属于管道流"></a>Stream流属于管道流</h1><p>Stream流属于管道流，只能被消费（使用）一次，第一个Stream流调用完毕方法，数据就会流转到下一个Stream上，而这时第一个Stream流已经使用完毕，就会关闭流，所以第一个Stream流就不能调用方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">	Stream&lt;String&gt; stream2 = stream1.filter(name-&gt;name.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">	stream1.forEach(name-&gt;System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上代码编译通过，但是执行后爆出stream流已经关闭的异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8新特性之函数式接口</title>
    <url>/2020/03/14/java/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><ul>
<li><strong>JDK8更新了很多的新特性，其中函数式接口就是JDK8中最为受欢迎的新特性之一。</strong><span id="more"></span>

</li>
</ul>
<h2 id="什么是函数式接口？"><a href="#什么是函数式接口？" class="headerlink" title="什么是函数式接口？"></a>什么是函数式接口？</h2><ul>
<li>有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</li>
</ul>
<p>函数式接口是适用于函数式编程的接口，而JDK8中的函数式编程就是Lambda，所以函数式接口就是可以使用于Lambda表达式使用的接口，只有确保接口中只有一个抽象方法，Java中的Lambda才可以顺利进行推导。</p>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionInterface</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h2><p>@FunctionalInterface注解是一个和函数式接口相关的注解，可以检测一个接口是否是一个函数式接口。如果是则编译成功，如果不是则编译失败。<br>编译失败的可能原因：接口中没有抽象方法或者有多个抽象方法。</p>
<p><strong>编译成功的情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>		<span class="comment">//编译成功</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionInterface</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译失败的情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>		<span class="comment">//编译失败</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionInterface</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda表达式的重要特征:</p>
<ul>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体只包含了一行代码，可以不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h2 id="Lambda表达式的使用"><a href="#Lambda表达式的使用" class="headerlink" title="Lambda表达式的使用"></a>Lambda表达式的使用</h2><p>我们平常面向接口编程的时候，都需要实现该接口，重写内部方法，我们可以使用匿名内部类的方式编写代码，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MyFunctionInterface myInterface)</span> &#123;</span><br><span class="line">	myInterface.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	show(<span class="keyword">new</span> <span class="title class_">MyFunctionInterface</span>() &#123;		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;使用匿名内部类的方式重写接口中的方法。&quot;</span>);				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>而如果这个接口是一个函数式接口，那么我们可以使用Lambda表达式来重写这个接口中的方法，简化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MyFunctionInterface myInterface)</span> &#123;</span><br><span class="line">	myInterface.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	show(()-&gt;&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;使用Lambda表达式的方式重写接口中的方法。&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda表达式的简化：如果这个重写的方法中有且仅有一行代码，那么我们可以省略方法体中的大括号和分号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MyFunctionInterface myInterface)</span> &#123;</span><br><span class="line">	myInterface.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	show(()-&gt;System.out.println(<span class="string">&quot;使用Lambda表达式的方式重写接口中的方法。&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类和Lambda表达式的区别？"><a href="#匿名内部类和Lambda表达式的区别？" class="headerlink" title="匿名内部类和Lambda表达式的区别？"></a>匿名内部类和Lambda表达式的区别？</h2><p>匿名内部类会生成一个匿名内部类的class文件，而Lambda表达式不会有class文件，节省了空间。</p>
<h2 id="Lambda表达式的延迟执行"><a href="#Lambda表达式的延迟执行" class="headerlink" title="Lambda表达式的延迟执行"></a>Lambda表达式的延迟执行</h2><p>有些场景的代码执行后，结果有不一定会被使用，从而造成了性能的浪费，而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。</p>
<p><strong>性能浪费的日志案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showLog</span><span class="params">(<span class="type">int</span> level, String message)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(level == <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(message);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg3</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		showLog(<span class="number">1</span>, msg1+msg2+msg3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，如果传入的level参数为2，那么message参数传入的拼接字符串就造成了性能浪费。</p>
<p><strong>使用Lambda表达式的延迟执行优化这段代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageBuilder</span> &#123;</span><br><span class="line">	String <span class="title function_">builderMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showLog</span><span class="params">(<span class="type">int</span> level, MessageBuilder mb)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(level == <span class="number">1</span>) &#123;</span><br><span class="line">		System.out.println(mb.builderMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msg3</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">	showLog(<span class="number">1</span>, ()-&gt;&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;当条件符合时才会执行这段方法！&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> msg1+msg2+msg3;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Lambda表达式作为参数传递，仅仅是把参数传递到showLog方法中。</p>
<ul>
<li>只有满足条件，参数level为1时，才会调用的MessageBuilder接口中的builderMessage方法，字符串才会进行拼接。</li>
<li>如果不满足条件，参数level不为1时，不会调用的MessageBuilder接口中的builderMessage方法，字符串也不会进行拼接。</li>
</ul>
<p>这就是Lambda表达式的延迟执行，避免了性能的浪费。</p>
<h2 id="Lambda表达式和线程"><a href="#Lambda表达式和线程" class="headerlink" title="Lambda表达式和线程"></a>Lambda表达式和线程</h2><p>线程中的Runnable接口就是一个函数式接口，其中有且仅有一个抽象方法run()方法。</p>
<p>我们就可以使用Lambda表达式来创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程启动了！&quot;</span>)</span><br><span class="line">	).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h1><ul>
<li><strong>JDK为我们提供了一些常用的函数式接口，这些接口全部放在java.util.function包中。</strong></li>
</ul>
<h2 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h2><p>Supplier是一个函数式接口，其中仅有一个无参的方法：T get()。用来获取一个泛型参数指定类型的对象数据。</p>
<ul>
<li>Supplier接口被称之为生产型接口，指定接口是什么泛型，就会生产什么类型的数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SupplierDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> supplier.get();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> getString(()-&gt;<span class="string">&quot;Supplier接口生产一个String类型的数据。&quot;</span>);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h2><ul>
<li>Consumer接口被称之为消费型接口，指定什么类型的泛型，就会消费什么类型的数据。</li>
</ul>
<p><strong>抽象方法：void accept(T t)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, Consumer&lt;String&gt; consumer)</span> &#123;</span><br><span class="line">		consumer.accept(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method(<span class="string">&quot;消费了这个字符串&quot;</span>, (t)-&gt;&#123;</span><br><span class="line">			<span class="comment">//消费方法的逻辑可以由设计者随便定义</span></span><br><span class="line">			System.out.println(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(t).reverse());</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认方法：default Consumer<T> andThen(Consumer&lt;? super T&gt; after)</strong></p>
<ul>
<li>andThen方法谁在前面，谁先消费！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, Consumer&lt;String&gt; consumer1, Consumer&lt;String&gt; consumer2)</span> &#123;</span><br><span class="line">		consumer1.andThen(consumer2).accept(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method(<span class="string">&quot;消费了这个字符串&quot;</span>, (t)-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;第一次消费：&quot;</span> + <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(t).reverse());</span><br><span class="line">		&#125;,(t)-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;第二次消费：&quot;</span> + <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(t).reverse());</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h2><ul>
<li>Predicate接口的作用是对数据类型的数据进行判断，结果返回一个boolean值。</li>
</ul>
<p><strong>抽象方法：test(T t)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String str, Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> predicate.test(str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> checkString(<span class="string">&quot;abcdefg&quot;</span>, (s)-&gt;s.length() &gt; <span class="number">5</span>);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认方法：default Predicate<T> and(Predicate&lt;? super T&gt; other)</strong></p>
<ul>
<li>相当于逻辑表达式&amp;&amp;（与）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String str, Predicate&lt;String&gt; predicate1, Predicate&lt;String&gt; predicate2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> predicate1.and(predicate2).test(str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> checkString(<span class="string">&quot;abcdefg&quot;</span>, (s)-&gt;s.length() &gt; <span class="number">5</span>,(s)-&gt;s.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认方法：default Predicate<T> or(Predicate&lt;? super T&gt; other)</strong></p>
<ul>
<li>相当于逻辑表达式||（或）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String str, Predicate&lt;String&gt; predicate1, Predicate&lt;String&gt; predicate2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> predicate1.or(predicate2).test(str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> checkString(<span class="string">&quot;abcdefg&quot;</span>, (s)-&gt;s.length() &gt; <span class="number">5</span>,(s)-&gt;s.contains(<span class="string">&quot;h&quot;</span>));</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认方法：default Predicate<T> negate()</strong></p>
<ul>
<li>相当于逻辑表达式!（非）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String str, Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> predicate.negate().test(str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> checkString(<span class="string">&quot;abcdefg&quot;</span>, (s)-&gt;s.length() &gt; <span class="number">5</span>);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h2><ul>
<li>Function接口用来根据一个类型的数据得到另一个类型的数据。</li>
</ul>
<p><strong>抽象方法：R apply(T t)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String s, Function&lt;String, Integer&gt; fun)</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> fun.apply(s);</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		change(<span class="string">&quot;56&quot;</span>, (s)-&gt;Integer.parseInt(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认方法：default <V> Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)</strong></p>
<ul>
<li>andThen方法谁在前面，谁先执行！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String s, Function&lt;String, Integer&gt; fun1, Function&lt;Integer, String&gt; fun2)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> fun1.andThen(fun2).apply(s);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		change(<span class="string">&quot;56&quot;</span>, (s)-&gt;Integer.parseInt(s),(i)-&gt;i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK源码-Object类解析</title>
    <url>/2020/01/07/java/JDK%E6%BA%90%E7%A0%81-Object%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、JDK源码"><a href="#一、JDK源码" class="headerlink" title="一、JDK源码"></a>一、JDK源码</h1><p>作为Java中所有Class的爸爸，Object类无疑是Java中非常重要的一个类，今天我们就直接来阅读以下JDK源码中的Object类，对其中的代码进行解析。</p>
<span id="more"></span>
<p>首先，废话不多说，我们直接上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> +Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、Object类"><a href="#二、Object类" class="headerlink" title="二、Object类"></a>二、Object类</h1><p>看到上面的代码，是不是非常惊讶，作为Java中的基类，Object的源码似乎也并不是太复杂。<br>是的，你没有感觉错误，其实只要你打开JDK的源码来看一看的话，就会发现，在Object类中，除去那些一大堆的看不懂的英文注释之外，所有的有效代码就是上面的那些。<br><strong>Object类</strong>是java.lang包下的一个Class，从写法上来看，它和我们平常自己写的类也没有太大的区别，那么Object类作为java中的基类有什么特殊之处呢，那就让我们来解析一下吧。</p>
<p><strong>1、所有的类都继承自Object类</strong><br>首先，Object类作为Java的基类，Java中所有的类（包含JDK中的和我们自己定义的）都会显式或隐式继承Object类，所以Object类是Java中所有类的父类，或者是超父类。故此，我们也将Object类称作基类，或者是超类。</p>
<p><strong>2、Object类中的方法</strong><br>既然Object类是基类，那么根据Java中继承的特性，也就是所Java中除了Object类之外的所有类都是Object类的子类，也就是说Object类中的所有的<strong>非私有</strong>方法都会被其子类继承。<br>所以，Java中的任意一个类，都可以调用Object类中的方法。</p>
<p><strong>Object类中的方法一共有13个，1个构造方法，1个私有方法，2个受保护方法，其余9个则是公有方法</strong>。</p>
<p>而今天需要详细解析的也就是这13个方法。</p>
<h1 id="三、Object中的方法"><a href="#三、Object中的方法" class="headerlink" title="三、Object中的方法"></a>三、Object中的方法</h1><h2 id="1、Object"><a href="#1、Object" class="headerlink" title="1、Object()"></a>1、Object()</h2><p>Object类的构造方法在JDK源码中并没有直接书写出来，是一个默认的无参构造方法，可以直接通过关键字<strong>new</strong>来进行创建一个Object类型的对象。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<h2 id="2、registerNatives"><a href="#2、registerNatives" class="headerlink" title="2、registerNatives()"></a>2、registerNatives()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法是private的，是私有的，所以这个方法是Object类独有的方法，不会被其子类继承。<br><strong>registerNatives()</strong> 方法独特的地方在于，使用了 <strong>native</strong>关键字进行修饰，在java中，使用native关键字进行修饰，那就说明这个方法的底层实现，并不是由Java代码来进行编写的，而是调用了其他语言编写的接口来进行实现的。<br>我们可以从源码中发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Object类中有一个静态代码块，直接调用了这个方法，也就是说，这个方法是所有的类进行实例化的时候都会执行的方法。<br>这个方法和Java语言的底层实现有关系，我们只需要了解即可，并不是今天的重点。</p>
<h2 id="3、clone"><a href="#3、clone" class="headerlink" title="3、clone()"></a>3、clone()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p>clone()方法是一个受保护的方法，作用是克隆一个对象，我们可以实例化一个Object类的对象，看看Object对象可以直接调用哪些方法：<br><img src="/images/2020/01/20200107225037605.png" alt="在这里插入图片描述"><br>从上面的图我们可以发现，其实Object类的实例对象竟然也无法调用clone()方法，那么Java中该怎么调用clone()方法呢？<br>方法很简单，实现Cloneable接口，并覆写clone()方法即可！<br>我们先来写一个User类，并让User类实现Cloneable接口，并覆写clone()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> username;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.username = username;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;User [id=&quot;</span> + id + <span class="string">&quot;, username=&quot;</span> + username + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们写好了User类，并让User类实现了Cloneable接口和覆写clone()方法，那么我们来实例化一个User对象。<br><img src="/images/2020/01/20200107230520425.png" alt="在这里插入图片描述"><br>从上面的图我们可以看见，除去User类自己的6个setter和getter方法之后，User类可以调用的方法有10个，其中就包括之前无法调用的clone()方法。<br>说完了实现，我们在说说clone方法的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) user1.clone();</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，得到结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从这个结果我们可以看出，其中clone()方法克隆出来的对象，和原来的对象并不是同一个，而是从新创建了一个新的对象。</p>
<h2 id="4、finalize"><a href="#4、finalize" class="headerlink" title="4、finalize()"></a>4、finalize()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>finalize()方法是一个和Java的垃圾回收机制有关的方法。<br>这个方法会在Java的垃圾回收机制回收对象所占内存之前被调用，即当一个对象被Java虚拟机宣告死亡时会先调用它finalize()方法，让这个对象处理它被回收前的最后事情。<br>如果我们在Java类中覆写了该方法，可以通过覆写的方法，摆脱本身被Java垃圾回收机制回收的命运。<br>对于这个方法，我们只限于了解，并不深究。</p>
<h2 id="5、getClass"><a href="#5、getClass" class="headerlink" title="5、getClass()"></a>5、getClass()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>接下来要说的是9个公有方法，也是Java类中最为常用的9个方法。第一个就是getClass()。<br>通过这个方法，可以获取Java对象的字节码对象，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> user.getClass();</span><br></pre></td></tr></table></figure>
<h2 id="6、hashCode"><a href="#6、hashCode" class="headerlink" title="6、hashCode()"></a>6、hashCode()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>hashCode()方法，可以获取Java对象的哈希码值，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> user.hashCode();</span><br><span class="line">System.out.println(code);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">366712642</span></span><br></pre></td></tr></table></figure>
<h2 id="7、equals-Object-obj"><a href="#7、equals-Object-obj" class="headerlink" title="7、equals(Object obj)"></a>7、equals(Object obj)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>equals(Object obj)方法，其实从源码不难发现，equals方法最底层还是调用了==运算符来实现的，也就是说Object类的equals方法和双等号运算符并没有什么区别。<br>也就是<strong>基本数据类型比较值是否相等，应用数据类型比较内存地址是否相等</strong>。<br>而String类型的equals方法之所以可以比较应用数据类的值是否相等，那是因为String类中重写了equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> user1;</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="8、toString"><a href="#8、toString" class="headerlink" title="8、toString()"></a>8、toString()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toString()方法，在JavaBean中经常被覆写的方法，用于返回对象的字符串表示形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">System.out.println(user.toString());</span><br></pre></td></tr></table></figure>
<p>没有被覆写时结果为：（包名+引用内存地址）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.day01.object.User@15db9742</span><br></pre></td></tr></table></figure>
<p>当toString()方法被覆写时：（字符串形式为自己覆写的toString决定）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [id=<span class="literal">null</span>, username=<span class="literal">null</span>, password=<span class="literal">null</span>]</span><br></pre></td></tr></table></figure>
<p>可以一提的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(user.toString());</span><br></pre></td></tr></table></figure>
<p>这个两个书写方式都是一样的，打印一个对象时，默认就是调用该对象的toString()方法。</p>
<h2 id="9、notify"><a href="#9、notify" class="headerlink" title="9、notify()"></a>9、notify()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>唤醒正在等待对象监视器的单个线程。 </p>
<h2 id="10、notifyAll"><a href="#10、notifyAll" class="headerlink" title="10、notifyAll()"></a>10、notifyAll()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>唤醒正在等待对象监视器的所有线程。 </p>
<h2 id="11、wait"><a href="#11、wait" class="headerlink" title="11、wait()"></a>11、wait()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。 </p>
<h2 id="12、wait-long-timeout"><a href="#12、wait-long-timeout" class="headerlink" title="12、wait(long timeout)"></a>12、wait(long timeout)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>导致当前线程等待，直到另一个线程调用 notify()方法或该对象的 notifyAll()方法，或者指定的时间已过。</p>
<h2 id="13、wait-long-timeout-int-nanos"><a href="#13、wait-long-timeout-int-nanos" class="headerlink" title="13、wait(long timeout, int nanos)"></a>13、wait(long timeout, int nanos)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法，或者某些其他线程中断当前线程，或一定量的实时时间。 </p>
<h1 id="四、结束"><a href="#四、结束" class="headerlink" title="四、结束"></a>四、结束</h1><p>写到这里，Object类的JDK源码也就讲完了。<br>其实我们可以发现，即便是JDK源码，其实也和我们自己写的代码没有太大的区别，我们完全可以自己阅读JDK源码，理解JDK中各个Java类的具体实现，知道JDK源码中的具体运行原理，这对我们学习Java有很大的帮助。<br>JDK源码中，有很多的类都是JDK自己封装的Java类，这些类都是由最基础的Java知识衍生而来，万变不离其宗！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson解析Yaml文件报错</title>
    <url>/2023/02/09/java/Jackson%E8%A7%A3%E6%9E%90Yaml%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>今天在使用<code>jackson-dataformat-yaml</code>框架解析<code>Yaml</code>文件的时候，解析过程中爆出了这样一个错误。</p>
<span id="more"></span>
<p>错误信息大致如下：</p>
<blockquote>
<p>Exception in thread “main” java.lang.NoSuchMethodError: com.fasterxml.jackson.dataformat.yaml.YAMLFactory._createContentReference(Ljava/lang/Object;)Lcom/fasterxml/jackson/core/io/ContentReference;<br>    at com.fasterxml.jackson.dataformat.yaml.YAMLFactory.createParser(YAMLFactory.java:353)<br>    at com.fasterxml.jackson.dataformat.yaml.YAMLFactory.createParser(YAMLFactory.java:15)<br>    at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3413)</p>
</blockquote>
<p>这个错误产生的原因是因为，我们的项目同时引入了<code>jackson-databind</code>框架，而<code>jackson-databind</code>框架和<code>jackson-dataformat-yaml</code>框架同时引入了一些<code>jackson</code>相关的核心依赖，且这两个框架的核心依赖版本不一致，导致了报错。</p>
<p><img src="/images/2023/02/12ac822be492400a83ad7a73f0f525d7.png" alt="Maven依赖分析"></p>
<p>使用Maven进行依赖分析，我们可以看到：</p>
<ul>
<li>我们项目自己引入的<code>jackson-databind</code>框架，且版本较低。</li>
<li><code>jackson-dataformat-yaml</code>框架依赖了<code>jackson-core</code>、<code>jackson-databind</code>等依赖，且版本较高。</li>
<li>根据Maven依赖原则，<code>jackson-databind</code>框架的依赖被优先使用（<code>jackson-databind</code>框架在<code>pom.xml</code>文件中被先声明也是导致依赖被优先使用的原因）。</li>
</ul>
<p>根据以上的分析，我们可以得到两个解决方案：</p>
<ul>
<li><p>根据最少依赖原则，我们可以直接注释<code>pom.xml</code>文件中的<code>jackson-databind</code>框架依赖，这样项目就可以直接依赖<code>jackson-dataformat-yaml</code>框架，且<code>jackson-dataformat-yaml</code>框架中依赖了<code>jackson-databind</code>项目，所以完全不影响项目的正常使用。【推荐该方案】</p>
</li>
<li><p>在<code>pom.xml</code>文件中，将<code>jackson-databind</code>框架依赖声明在<code>jackson-dataformat-yaml</code>框架依赖之后。（这个方案本质上和注释<code>jackson-databind</code>依赖区别不大，因为根据Maven依赖原则，这个依赖完全不会被使用。）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jackson</tag>
        <tag>Yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>Java main方法中的String[] args</title>
    <url>/2021/01/10/java/Java%20main%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84String%5B%5D%20args/</url>
    <content><![CDATA[<blockquote>
<p>在每一个学习Java的同学，都应该写过下面的这一段代码。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java语言中，规定了入口函数是一个<code>main()</code>方法，该方法有一个<code>String[]</code>类型的参数，但是在很多时候，很多人都使用不上这个参数，也不关心为什么要写这个参数。</p>
<p>那么这个字符串数组类型的参数究竟是什么东西呢？</p>
<blockquote>
<p>其实很简单，main()方法中的字符串数组类型的参数就是java命令的参数，使用java命令的方式运行main()方法，会将java命令的参数入参到Java main()方法的字符串数组参数中。</p>
</blockquote>
<p>我们可以通过以下方式来进行验证：</p>
<ul>
<li>1、先编写一个Hello.java文件，文件内容如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;==============args start============&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			System.out.println(args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;==============args end============&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2、在<code>Hello.java</code>文件的路径下打开cmd命令提示符，运行<code>javac Hello.java</code>命令编译该文件，这将会在对应的文件路径下，得到一个<code>Hello.class</code>字节码文件。</p>
</li>
<li><p>3、使用<code>java Hello</code>命令运行Hello.class文件，我们将会得到如下的运行结果：<br><img src="/images/2021/01/20210110215255723.png" alt="在这里插入图片描述"></p>
<ul>
<li>4、我们这次在java命令后面添加一些参数，这些参数我们可以自己定义。<br>例如：<code>java Hello a b c d</code> ，我们将会得到如下的运行结果：<br><img src="/images/2021/01/20210110215501851.png" alt="在这里插入图片描述"><blockquote>
<p>正是因为Java main()方法的这个扩展性，使得每一个开发者，可以通过自己定义一些Java命令的参数，实现一些不同的功能。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>其中SpringBoot的启动类，其实也使用了这个特性，SpringApplication.run()方法有一个重载方法，其中第一个入参的是注解了<code>@SpringBootApplication</code>注解的类的字节码对象，而第二个参数，即为main()方法的字符串数组参数。</p>
<p>SpringBoot可以通过这个字符串数组参数，通过<code>java</code>命令参数的方式，在不同的环境下实现不同的应用配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算，Int类型存储用户的登录足迹</title>
    <url>/2021/08/23/java/Java%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8CInt%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E7%9A%84%E7%99%BB%E5%BD%95%E8%B6%B3%E8%BF%B9/</url>
    <content><![CDATA[<blockquote>
<p>今天接到一家公司的面试邀请，于是我来到了这家公司，前台的小姐姐面带微笑地把我请进会议室，等待了一会，一位面试官走了进来……</p>
<p>在进行了简单的自我介绍之后，面试官开始发问了……</p>
</blockquote>
<span id="more"></span>



<p>面试官：你好，请你使用最少的存储空间，记录一个用户在一个月内的登录记录，只需要知道用户在某一日是否登录即可。</p>
<p>我（略作沉思）：好的，我们可以建立一张登录日志表，在用户登录的时候，记录一条登录日志数据，这张表和用户表是一对多的关系，有用户主键、登录类型、登录时间等等，如果有需要，我们还可以记录用户的登录 IP、登录国家、城市等等信息……</p>
<p>面试官（面无表情）：……好的，请你回去等我们的通知吧……</p>
<p>我：……开玩笑的，既然要使用最少的存储空间来实现这个需求，使用传统的数据库记录登录日志的方式自然是难以达到这个条件的，所以我们需要打破传统的存储方式来实现这个需求。</p>
<p>面试官（略有兴趣）：哦，那你要怎么实现呢？</p>
<p>我：总所周知，在 Java 中，一个 int 类型所占的内存空间是 4 个字节，而一个字节是 8 个 bit，所以一个 int 类型的数据，所占用的内存空间是 32 个 bit 位，而我的想法就是，使用一个 int 类型的数据，也就是 32 个 bit 位记录用户在一个月内的登录记录。</p>
<p>面试官（点了点头）：32 个 bit 位，这个存储空间确实非常少，但是具体要怎么实现呢？你详细说说。</p>
<p>我：我之前也说了，一个 int 类型的数据，占用的内存空间是 32 个 bit 位，而 Java 中的 int 是一个有符号位的数据，除去最高位的符号位之外，在 Java 中一个 int 类型的数据，能够表达状态的一共有 31 个 bit 位。例如，一个值为 0 的 int 类型数据，转换为二进制的 bit 位，显示为 <code>00000000 00000000 00000000 00000000</code>。</p>
<p>面试官满意地点了点头……</p>
<p>我：一个 int 类型的 bit 为可以有 0 和 1 两个状态，而且恰好有 31 个 bit 位可用，我们完全可以使用这 31 个 bit 位来记录用户当日是否登录。比如一个用户在 3 号登录了，使用 bit 位表示为： <code>00000000 00000000 00000000 00000100</code> 。而后这个用户在 5 号也登录，使用 bit 位可以表示为： <code>00000000 00000000 00000000 00010100</code> 。依次类推，一个月最多也就 31 天，假如一个用户在一个大月中每天都登录，使用 bit 位可以表示为： <code>01111111 11111111 11111111 11111111</code> 。最后，我们将这个二进制的 bit 数据转换为 int 类型即可。</p>
<p>面试官：思路不错，但是具体要怎么实现呢？如果将一个 int 类型的数据转换为二进制的 bit 位数据，具体的算法实现会不会非常麻烦呢？程序的执行效率会不会很慢呢？</p>
<p>我（面带自信）：我的实现很简单，而且程序的执行效率也非常快，甚至要比 Java 中的其他运算都要快！</p>
<p>面试官：哦……</p>
<p>我：我的实现方式，就是使用 Java 中的位运算来实现，使用位运算，不仅实现简单，而且运行效率远比其他符号运算快！</p>
<p>面试官（递过来一张纸）：请你在草稿纸上简单实现一下吧。</p>
<p>我：……</p>
<p>我：首先定义一个私有的 int 类型的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">login</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>我：其次，我们需要两个公有的方法，用来操作这个 int 类型的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setBit</span><span class="params">(<span class="type">int</span> bitIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitIndex &lt; <span class="number">0</span> || bitIndex &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超过 int 类型 bit 位的有效范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    login |= <span class="number">1</span> &lt;&lt; bitIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getBit</span><span class="params">(<span class="type">int</span> bitIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitIndex &lt; <span class="number">0</span> || bitIndex &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;超过 int 类型 bit 位的有效范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (login &amp; <span class="number">1</span> &lt;&lt; bitIndex) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我：最后，我们可以测试一下这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    setBit(<span class="number">0</span>);</span><br><span class="line">    setBit(<span class="number">3</span>);</span><br><span class="line">    setBit(<span class="number">4</span>);</span><br><span class="line">    setBit(<span class="number">16</span>);</span><br><span class="line">    setBit(<span class="number">30</span>);</span><br><span class="line">    System.out.println(Integer.toBinaryString(login));  <span class="comment">// 1000000 00000001 00000000 00011001</span></span><br><span class="line">    System.out.println(getBit(<span class="number">0</span>));   <span class="comment">// true</span></span><br><span class="line">    System.out.println(getBit(<span class="number">1</span>));   <span class="comment">// false</span></span><br><span class="line">    System.out.println(getBit(<span class="number">2</span>));   <span class="comment">// false</span></span><br><span class="line">    System.out.println(getBit(<span class="number">3</span>));   <span class="comment">// true</span></span><br><span class="line">    System.out.println(getBit(<span class="number">30</span>));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我：在这段代码中，我没有对日期进行一个真实数据的维护，比如 1 号对应的是 0 位的 bit 位，31 号对应的是 30 位的 bit 位，所以在正式使用的时候，需要手动对真实的日期数据进行 -1 维护。</p>
<p>面试官（面露微笑）：精彩！精彩啊！很好，我们公司就需要你这也的人才，明天来我们公司报道吧！</p>
<p>我（激动）：好的，请问我的薪资是……</p>
<p>面试官（沉吟片刻）：就 3k 吧。</p>
<p>我：……&amp;#￥$@@*&amp;^%……</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——File类和IO</title>
    <url>/2020/03/09/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94File%E7%B1%BB%E5%92%8CIO/</url>
    <content><![CDATA[<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File是Java中的文件类，用于处理和文件相关的一些操作，例如文件的创建，删除等等。</p>
<span id="more"></span>
<p><strong>构造方法</strong></p>
<ul>
<li>File(File parent, String child)<br>从父抽象路径名和子路径名字符串创建新的 File实例。 </li>
<li>File(String parent, String child)<br>从父路径名字符串和子路径名字符串创建新的 File实例。 </li>
<li>File(String pathname)<br>通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 </li>
<li>File(URI uri)<br>通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。 </li>
</ul>
<p><strong>常用方法</strong></p>
<ul>
<li>boolean mkdir()<br>创建由此抽象路径名命名的目录。  </li>
<li>boolean mkdirs()<br>创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。  </li>
<li>boolean delete()<br>删除由此抽象路径名表示的文件或目录。  </li>
<li>boolean exists()<br>测试此抽象路径名表示的文件或目录是否存在。  </li>
<li>String getName()<br>返回由此抽象路径名表示的文件或目录的名称。</li>
<li>String getPath()<br>将此抽象路径名转换为路径名字符串。</li>
<li>boolean isDirectory()<br>测试此抽象路径名表示的文件是否为目录。  </li>
<li>boolean isFile()<br>测试此抽象路径名表示的文件是否为普通文件。  </li>
<li>String[] list()<br>返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录。  </li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>所谓IO流，便是Input和Output，即输入流和输出流，具体是指文件的输入流和输出流。<br>IO流分为很多类，其中最为常用的就是IO字节流和IO字符流，除此之外，还有缓冲流，转换流，序列化流，打印流等等。</p>
<p><strong>IO字节流</strong><br>IO字节流有两个上层接口，分别是InputStream和OutputStream接口，我们常用的具体实现类有FileInputStream和FileOutputStream，即文件输入字节流和文件输出字节流。</p>
<ul>
<li>FileInputStream</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int read(byte[] b)</td>
<td>从输入流读取一些字节数，并将它们存储到缓冲区 b 。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此输入流并释放与流相关联的任何系统资源。</td>
</tr>
</tbody></table>
<ul>
<li>FileOutputStream</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void write(byte[] b, int off, int len)</td>
<td>从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制任何缓冲的输出字节被写出。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此输出流并释放与此流相关联的任何系统资源。</td>
</tr>
</tbody></table>
<p><strong>IO字节流代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">	<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">	<span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">		fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	fos.flush();</span><br><span class="line">	fos.close();</span><br><span class="line">	fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IO字符流</strong><br>IO字符流有两个上层接口，分别是Reader和Writer接口，我们常用的具体实现类有FileReader和FileWriter，即文件输入字符流和文件输出字符流。</p>
<ul>
<li>FileReader</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int read(char ch)</td>
<td>从输入流读取一些字符数，并将它们存储到缓冲区 b 。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此输入流并释放与流相关联的任何系统资源。</td>
</tr>
</tbody></table>
<ul>
<li>FileWriter</li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void write(char[] b, int off, int len)</td>
<td>从指定的字符数组写入 len个字节，从偏移 off开始输出到此输出流。</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新此输出流并强制任何缓冲的输出字符被写出。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此输出流并释放与此流相关联的任何系统资源。</td>
</tr>
</tbody></table>
<p><strong>IO字符流代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">	<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">	<span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = fr.read(ch)) != -<span class="number">1</span>) &#123;</span><br><span class="line">		fw.write(ch,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	fw.flush();</span><br><span class="line">	fw.close();</span><br><span class="line">	fr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p><strong>缓冲字节流</strong></p>
<ul>
<li>BufferedInputStream(InputStream in)<br>创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int read(byte[] b, int off, int len)</td>
<td>从给定的偏移开始，将字节输入流中的字节读入指定的字节数组。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此输入流并释放与流相关联的任何系统资源。</td>
</tr>
</tbody></table>
<ul>
<li>BufferedOutputStream(OutputStream out)<br>创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void write(byte[] b, int off, int len)</td>
<td>从指定的字节数组写入 len个字节，从偏移 off开始到缓冲的输出流。</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新缓冲输出流。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此输出流并释放与流相关联的任何系统资源。</td>
</tr>
</tbody></table>
<p><strong>缓冲字节流代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">	<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">	<span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">		bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	bos.flush();</span><br><span class="line">	bos.close();</span><br><span class="line">	bis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缓冲字符流</strong></p>
<ul>
<li>BufferedReader(Reader in)<br>创建使用默认大小的输入缓冲区的缓冲字符输入流。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int read(char[] cbuf, int off, int len)</td>
<td>将字符读入数组的一部分。</td>
</tr>
<tr>
<td>String readLine()</td>
<td>读一行文字。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流并释放与之相关联的任何系统资源。</td>
</tr>
</tbody></table>
<ul>
<li>BufferedWriter(Writer out)<br>创建使用默认大小的输出缓冲区的缓冲字符输出流。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void write(char[] cbuf, int off, int len)</td>
<td>写入字符数组的一部分。</td>
</tr>
<tr>
<td>void newLine()</td>
<td>写一行行分隔符。</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流，先刷新。</td>
</tr>
</tbody></table>
<p><strong>缓冲字符流代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">	<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b.txt&quot;</span>));</span><br><span class="line">	<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">		bw.write(line);</span><br><span class="line">		bw.newLine();</span><br><span class="line">	&#125;</span><br><span class="line">	bw.close();</span><br><span class="line">	br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul>
<li>InputStreamReader(InputStream in, String charsetName)<br>创建一个使用命名字符集的InputStreamReader。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int read(char[] cbuf, int offset, int length)</td>
<td>将字符读入数组的一部分。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流并释放与之相关联的任何系统资源。</td>
</tr>
<tr>
<td>String getEncoding()</td>
<td>返回此流使用的字符编码的名称。</td>
</tr>
</tbody></table>
<ul>
<li>OutputStreamWriter(OutputStream out, String charsetName)<br>创建一个使用命名字符集的OutputStreamWriter。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void write(char[] cbuf, int off, int len)</td>
<td>写入字符数组的一部分。</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新流。</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭流，先刷新。</td>
</tr>
<tr>
<td>String getEncoding()</td>
<td>返回此流使用的字符编码的名称。</td>
</tr>
</tbody></table>
<p><strong>转换流代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = isr.read(ch)) != -<span class="number">1</span>) &#123;</span><br><span class="line">		osw.write(ch,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	osw.close();</span><br><span class="line">	isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><ul>
<li>ObjectInputStream(InputStream in)<br>反序列化流：创建从指定的InputStream读取的ObjectInputStream。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Object readObject()</td>
<td>从ObjectInputStream读取一个对象。</td>
</tr>
<tr>
<td>int read(byte[] buf, int off, int len)</td>
<td>读入一个字节数组。</td>
</tr>
</tbody></table>
<ul>
<li>ObjectOutputStream(OutputStream out)<br>序列化流：创建一个写入指定的OutputStream的ObjectOutputStream。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void writeObject(Object obj)</td>
<td>将指定的对象写入ObjectOutputStream。</td>
</tr>
<tr>
<td>void write(byte[] buf, int off, int len)</td>
<td>写入一个子字节数组。</td>
</tr>
</tbody></table>
<p>【注意】需要序列化的对象，必须要实现Serializable接口。</p>
<p><strong>序列化流代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">	<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">	<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">	oos.writeObject(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;123&quot;</span>));</span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">	System.out.println(user);</span><br><span class="line">	oos.close();</span><br><span class="line">	ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><ul>
<li>PrintStream(File file)<br>使用指定的文件创建一个新的打印流，而不需要自动换行。 </li>
<li>PrintStream(String fileName)<br>使用指定的文件名创建新的打印流，无需自动换行。 </li>
</ul>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void print(String s)</td>
<td>打印字符串。</td>
</tr>
</tbody></table>
<p><strong>System.out的本质就是一个打印流</strong></p>
<p><strong>打印流代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">	<span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">	out.print(<span class="string">&quot;打印流&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/images/2020/03/20200309001534514.png" alt="在这里插入图片描述"><br><img src="/images/2020/03/20200309002348424.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——GC机制</title>
    <url>/2020/03/10/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94GC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java语言的一大特点就是，Java有自动回收内存的GC机制，程序不需要手动释放内存空间，这样一来就使得程序员在代码设计的时候省去了很多的事情，而且也不需要再考虑内存泄露的问题。</p>
<span id="more"></span>

<h2 id="JavaGC机制原理"><a href="#JavaGC机制原理" class="headerlink" title="JavaGC机制原理"></a>JavaGC机制原理</h2><ul>
<li>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</li>
<li>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</li>
<li>程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</li>
</ul>
<p><strong>【注意】JavaGC机制表明，Java程序一定是一个多线程程序，最起码运行了main线程和GC线程。</strong></p>
<h2 id="Java的四种引用类型"><a href="#Java的四种引用类型" class="headerlink" title="Java的四种引用类型"></a>Java的四种引用类型</h2><ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>
</ul>
<h2 id="JVM永久代"><a href="#JVM永久代" class="headerlink" title="JVM永久代"></a>JVM永久代</h2><ul>
<li>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发<strong>完全垃圾回收(Full GC)</strong>。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</li>
</ul>
<p><strong>【注意】Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区。</strong></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul>
<li><strong>标记-清除算法：</strong> 标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li><strong>复制算法：</strong> 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>
<li><strong>标记-整理算法：</strong> 标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>
<li><strong>分代收集算法：</strong> 根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，<code>新生代基本采用复制算法，老年代采用标记整理算法</code>。</li>
</ul>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/images/2020/03/20200310105337178.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——JDK，JRE，JVM</title>
    <url>/2020/03/04/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JDK%EF%BC%8CJRE%EF%BC%8CJVM/</url>
    <content><![CDATA[<h2 id="JDK，JRE，JVM是什么"><a href="#JDK，JRE，JVM是什么" class="headerlink" title="JDK，JRE，JVM是什么"></a>JDK，JRE，JVM是什么</h2><p><strong>JDK</strong>全称为Java Development Kit（Java开发工具包），提供了Java语言开发的一系列工具，可以用来运行，编译Java程序。<br><strong>JRE</strong>全称为Java Runtime Environment（Java运行环境），是Java语言的运行环境。<br><strong>JVM</strong>全称为Java Virtual Machine（Java虚拟机），是一种计算机平台的规范，是一种虚拟的计算机，JVM是专门用来运行Java程序的，不同的操作系统中，可以安装与操作系统适应的JVM。</p>
<span id="more"></span>
<p>【<strong>注意</strong>】</p>
<ul>
<li>JDK和JRE并不是包含与被包含的关系，因为JDK是Java开发工具包，而JRE是Java运行环境。如果我们只需要进行Java开发，那么只需要安装JDK即可，同理，如果我们只是需要进行Java程序的运行，那么只安装JRE即可。<strong>但是，在一般的JDK中，都会包含JRE，所以我们日常所说的JDK，其实也都是指包含了JRE的JDK</strong>。</li>
<li>不同的操作系统需要安装相对应的JVM，这也是Java程序为什么可以跨平台运行的原因，因为<strong>不同操作系统的JVM屏蔽了Java程序与操作系统之间的联系</strong>。</li>
</ul>
<h2 id="JVM的组成"><a href="#JVM的组成" class="headerlink" title="JVM的组成"></a>JVM的组成</h2><p>Java虚拟机一共由两部分组成，分别是两个子系统和两个组件。</p>
<p><strong>两个子系统</strong></p>
<ul>
<li><strong>类加载</strong>（Class loader）：根据给定的全限定名类名来装载class文件到Runtime data area中的method area。</li>
<li><strong>执行引擎</strong>（Execution engine）：执行classes中的指令。执行引擎包含即时编译器和垃圾回收器。</li>
</ul>
<p><strong>两个组件</strong></p>
<ul>
<li><strong>本地接口</strong>（Native Interface）：与native libraries交互，是其它编程语言交互的接口。</li>
<li><strong>运行时数据区</strong>（Runtime data area）：这就是我们常说的JVM的内存。</li>
</ul>
<h2 id="JVM的内存"><a href="#JVM的内存" class="headerlink" title="JVM的内存"></a>JVM的内存</h2><p>JVM的内存，即运行时数据区，分为两个区域，分别是<strong>线程隔离数据区</strong>和<strong>线程共享数据区</strong>。</p>
<p><strong>线程隔离数据区</strong></p>
<ul>
<li><strong>程序计数器</strong>：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。</li>
<li><strong>本地方法栈</strong>：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。</li>
<li><strong>Java虚拟机栈</strong>：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
</ul>
<p><strong>线程共享数据区</strong></p>
<ul>
<li><strong>Java堆</strong>：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存。</li>
<li><strong>方法区</strong>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>
</ul>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><table>
<thead>
<tr>
<th>JVM调优参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms2g</td>
<td>初始化推大小为 2g</td>
</tr>
<tr>
<td>-Xmx2g</td>
<td>堆最大内存为 2g</td>
</tr>
<tr>
<td>-XX:NewRatio=4</td>
<td>设置年轻的和老年代的内存比例为 1:4</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>设置新生代 Eden 和 Survivor 比例为 8:2</td>
</tr>
<tr>
<td>–XX:+UseParNewGC</td>
<td>指定使用 ParNew + Serial Old 垃圾回收器组合</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>指定使用 ParNew + ParNew Old 垃圾回收器组合</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>指定使用 CMS + Serial Old 垃圾回收器组合</td>
</tr>
<tr>
<td>-XX:+PrintGC</td>
<td>开启打印 gc 信息</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印 gc 详细信息</td>
</tr>
</tbody></table>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/images/2020/03/20200304165045887.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——Java数据类型</title>
    <url>/2020/03/03/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Java语言中数据类型主要分为两大类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p>
<span id="more"></span>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型，顾名思义，这是Java中最为基本的数据类型，Java中所有的数据都是以基本数据类型为底层基础而进行存储或保存的。<br>Java中基本数据类型有四类八种，四类分别是整数型，浮点型，字符型，布尔型。<br>八种数据类型中，整数型有四种，浮点型有两种，字符型一种，布尔型一种。</p>
<p><strong>整数型</strong>：默认初始化值为0。</p>
<ul>
<li>byte：字节型，长度大小为1个字节。</li>
<li>short：短整型，长度大小为2个字节。</li>
<li>int：整型，长度大小为4个字节。</li>
<li>long：长整型，长度大小为8个字节。</li>
</ul>
<p><strong>浮点型</strong>：默认初始化值为0.0。</p>
<ul>
<li>float：单精度浮点型，长度大小为4个字节。</li>
<li>double：双精度浮点型，长度大小为8个字节。</li>
</ul>
<p><strong>字符型</strong>：默认初始化值为” “。</p>
<ul>
<li>char：字符型，长度大小为2个字节。</li>
</ul>
<p><strong>布尔型</strong>：默认初始化值为false。</p>
<ul>
<li>boolean：布尔型，长度大小为1/8个字节，即1位二进制。</li>
</ul>
<h2 id="基本数据类型的包装类型"><a href="#基本数据类型的包装类型" class="headerlink" title="基本数据类型的包装类型"></a>基本数据类型的包装类型</h2><p>Java中为每一个基本数据类型都设计了一个包装类型，八种基本数据类型和它们各自的包装类型对应如下：</p>
<table>
<thead>
<tr>
<th>数据类型名称</th>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>基本数据类型与包装类型的区别：</p>
<ul>
<li>包装类型的初始化值为null，而基本数据类型不可以为null。</li>
<li>包装类型可以运用在泛型上，而基本数据类型不可以。</li>
<li>基本数据类型的执行效率比包装类型要快。</li>
<li>基本数据类型转换为包装类型叫装箱，而包装类型转换为基本数据类型叫拆箱。</li>
</ul>
<p>【<strong>注意</strong>】包装类型是引用数据类型。<br>【<strong>注意</strong>】整型的包装类型，在进行装箱的过程中，如果数据在-128至127之间，那么会使用包装类型中的缓存，而不会重新创建新对象。</p>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>引用数据类型分为三种，分别是类，接口，数组。<br>它们的初始化值均为null。</p>
<ul>
<li><strong>类</strong>：关键字为class。</li>
<li><strong>接口</strong>：关键字为interface。</li>
<li><strong>数组</strong>：关键字为[]。</li>
</ul>
<h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h2><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>基本数据类型不可以为null值</td>
<td>引用数据类型的初始化值为null</td>
</tr>
<tr>
<td>基本数据类型指向的是内存中的具体的值</td>
<td>引用数据类型指向的是内存地址的引用</td>
</tr>
<tr>
<td>基本数据类型使用==比较是值</td>
<td>引用数据类型使用==比较是内存地址的引用</td>
</tr>
</tbody></table>
<p><img src="/images/2020/03/20200303221136577.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——多线程</title>
    <url>/2020/03/10/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p><strong>进程：</strong> 是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。</p>
<p><strong>线程：</strong> 单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。</p>
<span id="more"></span>
<p><strong>进程和线程的区别</strong></p>
<table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>资源分配的基本概念，调度运行的基本单位，系统中并发执行的单位</td>
<td>执行运算的最小单位，是程序运行的最小单位</td>
</tr>
<tr>
<td>一个进程可以有很多个线程</td>
<td>一个线程只能属于一个进程</td>
</tr>
<tr>
<td>切换进程系统开销大，创建进程比较消耗性能</td>
<td>切换线程系统开销小，创建线程性能消耗较小</td>
</tr>
<tr>
<td>进程有独立的内存空间和系统资源</td>
<td>所有线程共享进程中的内存空间和系统资源</td>
</tr>
<tr>
<td>父子进程之间使用进程通信机制进行通信</td>
<td>同一进程的线程使用进程变量来进行通信</td>
</tr>
<tr>
<td>进程死亡之后，不会影响其它进程</td>
<td>线程死掉，会导致整个进程死亡</td>
</tr>
</tbody></table>
<h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><p>在Java中，线程的创建方式一共有4中。</p>
<p><strong>1、继承Thread类，并重写run方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建线程，并开启线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">	myThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【注意】在开启线程的时候，我们必须要调用线程的start方法，因为start方法才会开辟一条线程通道，而如果调用run方法的话，那么就只是一个普通方法而已。</strong></p>
<p><strong>2、实现Runnable接口。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">50</span>; i ++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建线程，并开启线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(myThread).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】由于Runnable接口是一个函数式接口，所以我们可以使用Lombda表达式来创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p><strong>3、实现Callable接口。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;mythread&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建线程，并开启线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】由于Callable接口也是一个函数式接口，所以我们也可以使用Lombda表达式来创建线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;mythread&quot;</span>;</span><br><span class="line">	&#125;)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、线程池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">	es.submit(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【注意】这里直接使用的是Lambda表达式，submit的方法参数可以是Runnable接口和Callable接口的实现类。</strong></p>
<h2 id="Java的线程状态"><a href="#Java的线程状态" class="headerlink" title="Java的线程状态"></a>Java的线程状态</h2><p>在Java中，java.lang.Thread包中有一个内部枚举类State，里面列举了Java线程的6中状态。</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NEW（新建）</td>
<td>刚刚new出来的线程就处于新建状态。</td>
</tr>
<tr>
<td>RUNNABLE（运行）</td>
<td>线程调用start方法，并获得CPU的执行时间片。</td>
</tr>
<tr>
<td>BLOCKED（锁阻塞）</td>
<td>在使用同步机制的时候，线程没有获取到同步锁，进入锁阻塞。</td>
</tr>
<tr>
<td>WAITING（等待）</td>
<td>线程调用wait方法。</td>
</tr>
<tr>
<td>TIMED_WAITING（定时等待）</td>
<td>线程调用sleep方法，或者wait和join带时间参数的方法。</td>
</tr>
<tr>
<td>TERMINATED（终止）</td>
<td>线程代码执行完毕，线程终止运行。在已终止的线程上调用start方法，会抛出IllegalThreadStateException异常。</td>
</tr>
</tbody></table>
<h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><p>Java中的线程常用方法主要在两个类中，分别是Thread类和Object类。</p>
<p><strong>Thread类</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>返回此线程的名称。</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>将此线程的名称更改为等于参数 name</td>
</tr>
<tr>
<td>long getId()</td>
<td>返回此线程的标识符</td>
</tr>
<tr>
<td>Thread.State getState()</td>
<td>返回此线程的状态</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>返回对当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td>static void sleep(long millis)</td>
<td>使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）</td>
</tr>
<tr>
<td>void join(long millis)</td>
<td>等待这个线程死亡最多 millis毫秒</td>
</tr>
<tr>
<td>void start()</td>
<td>导致此线程开始执行; Java虚拟机调用此线程的run方法</td>
</tr>
<tr>
<td>void run()</td>
<td>如果这个线程使用单独的Runnable运行对象构造，则调用该Runnable对象的run方法; 否则，此方法不执行任何操作并返回</td>
</tr>
</tbody></table>
<p><strong>Object类</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。</td>
</tr>
<tr>
<td>void wait(long timeout)</td>
<td>导致当前线程等待，直到另一个线程调用 notify()方法或该对象的 notifyAll()方法，或者指定的时间已过。</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器的单个线程。</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程。</td>
</tr>
</tbody></table>
<p><strong>sleep和wait方法的区别</strong></p>
<table>
<thead>
<tr>
<th>sleep</th>
<th>wait</th>
</tr>
</thead>
<tbody><tr>
<td>Thread类中的静态方法</td>
<td>Object类中的普通方法，由锁对象调用</td>
</tr>
<tr>
<td>sleep方法不会释放锁</td>
<td>wait方法会释放锁</td>
</tr>
<tr>
<td>sleep不需要被唤醒</td>
<td>无参的wait方法需要被唤醒</td>
</tr>
<tr>
<td>sleep不依赖synchronized关键字</td>
<td>wait方法依赖synchronized关键字</td>
</tr>
</tbody></table>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>在多线程环境下，会有可以发送线程安全问题，导致一些共享数据产生错误，这个时候，我们为了避免线程安全问题，就需要对线程代码进行同步。<br>synchronized关键字是Java线程中用来保证代码同步的关键字。</p>
<p><strong>原理：</strong> synchronized关键字是JVM层面的同步，可以保证在同一时刻，只有一个被synchronized关键字修饰的代码块或方法进入临界区。</p>
<p><strong>synchronized关键字的锁对象</strong></p>
<ul>
<li>同步方法块：锁对象为括号内的对象。</li>
<li>普通方法：锁对象为当前实例对象。</li>
<li>静态方法，锁对象为该类的字节码对象。</li>
</ul>
<p><strong>synchronized和Lock的区别</strong></p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td>Java关键字，JVM层面实现</td>
<td>Java中的一个类，代码实现</td>
</tr>
<tr>
<td>只有当synchronized关键字修饰的代码全部执行完毕，才会释放锁。代码发生异常，JVM自动释放锁</td>
<td>使用unlock释放锁，否则会造成死锁</td>
</tr>
<tr>
<td>无法判断锁状态</td>
<td>可以判断锁状态</td>
</tr>
<tr>
<td>可重入、不可中断、非公平</td>
<td>可重入、可判断、可公平（两者皆可）</td>
</tr>
<tr>
<td>适合少量同步代码</td>
<td>适合大量同步代码</td>
</tr>
</tbody></table>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/images/2020/03/20200310093845950.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——类装载的执行过程</title>
    <url>/2020/03/08/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="什么是类装载？"><a href="#什么是类装载？" class="headerlink" title="什么是类装载？"></a>什么是类装载？</h2><p>我们都知道，Java代码有三个阶段，分别是源代码阶段，类加载阶段，运行阶段。</p>
<span id="more"></span>
<p><img src="/images/2020/03/20200308151655161.png" alt="在这里插入图片描述"></p>
<p>我们所说的类装载其实就指的就是类加载阶段的Java代码在JVM中的加载过程。</p>
<h2 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h2><p>类装载大致可以分为三个阶段，分别是加载，连接，初始化。<br>其中连接阶段最为复杂，又可以分为验证，准备，解析三个小阶段。</p>
<p><strong>加载</strong></p>
<ul>
<li>根据查找路径找到相应的 class 文件然后导入内存中。</li>
</ul>
<p><strong>验证</strong></p>
<ul>
<li>检查加载的 class 文件的正确性。</li>
</ul>
<p><strong>准备（重要）</strong></p>
<ul>
<li>给类中的静态变量分配内存空间，并赋予默认初始值，给常量赋值。</li>
</ul>
<p>准备阶段是类装载的一个重要阶段，在这个阶段中，JVM会给静态变量赋给默认值，而常量则会直接赋值。<br>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;			<span class="comment">//准备阶段静态变量赋予默认值i=0;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">I</span> <span class="operator">=</span> <span class="number">10</span>;	<span class="comment">//准备阶段常量赋值I=10;</span></span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<ul>
<li>虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。</li>
</ul>
<p><strong>初始化（重要）</strong></p>
<ul>
<li>对静态变量和静态代码块执行初始化工作。类变量（static变量）的赋值语句、静态代码块，最终组成类初始化方法。</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>什么时候会发生类的初始化？</strong></p>
<ul>
<li>Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是<strong>Main方法</strong>的类会首先被初始化。</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值（在编译器把结果放入常量池的静态字段除外）。</li>
<li>初始化某个类的子类，则其父类也会被初始化。</li>
<li>创建类的实例，也就是new的方式。</li>
<li>反射生成该类的字节码对象。</li>
<li>调用类的静态方法 。</li>
</ul>
<p><strong>对象初始化</strong></p>
<ul>
<li>实例化一个对象的时候，会发生对象的初始化。</li>
<li>如果一个类有父类，在实例化子类的时候，会先执行父类的构造函数，然后执行子类的构造函数。</li>
</ul>
<p><strong>类的初始化和对象初始化的区别</strong></p>
<table>
<thead>
<tr>
<th>类的初始化</th>
<th>对象初始化</th>
</tr>
</thead>
<tbody><tr>
<td>执行静态变量的赋值语句，静态代码块</td>
<td>执行成员变量的赋值语句，普通代码块，构造函数代码</td>
</tr>
</tbody></table>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/images/2020/03/20200308160223597.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——运行时异常和非运行时异常</title>
    <url>/2020/02/02/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="Java中异常机制的体系结构"><a href="#Java中异常机制的体系结构" class="headerlink" title="Java中异常机制的体系结构"></a>Java中异常机制的体系结构</h2><p>在Java中，万物皆对象，异常也不例外。<br>Exception（异常）是Java的一个类，它和它的兄弟类Error一起继承自它的父类——Throwable（可抛出的）。</p>
<span id="more"></span>
<p>它们的详细的体系结构如下图所示：<br><img src="/images/2020/02/20200202200144534.png" alt="在这里插入图片描述"></p>
<h2 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h2><p>Error一般是指和虚拟机有关的一些问题，一般是由于虚拟机运行错误，系统崩溃而引起的，这些问题不能被程序自动修复或着捕获，所以在Java代码中也无法对这些问题进行处理。Error一般不会出现，但是一旦出现了，就运行发生了重大错误。<br>对于初学者而言，最为常见的错误，应该就是<strong>StackOverflowError</strong>（栈溢出错误），一般发生在递归调用方法的时候，没有设置方法return的条件，导致过多的方法进入虚拟机栈中，造成栈空间溢出，从而使虚拟机线程终止运行。</p>
<h2 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h2><p>Exception一般分为两类，也就是<strong>运行时异常</strong>和<strong>非运行时异常</strong>。</p>
<p><strong>运行时异常</strong>，也被称作unchecked exception（不可查异常），它只包含一类，就是Exception的子类——RuntimeException，凡是该类或者该类的子类，都被称作运行时异常。<br>运行时异常，一般是由于程序的设计漏洞，代码逻辑错误而造成的，一旦发生，就会直接由虚拟机终止正在运行的程序。<br>常见的运行时异常有：</p>
<ul>
<li>NullPointerException(空指针异常)</li>
<li>IndexOutOfBoundsException(数组下标越界异常)   </li>
<li>ClassCastException(类型转换异常)</li>
<li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li>
</ul>
<p><strong>非运行时异常</strong>，也被称作checked exception（可查异常，也被称作编译异常），Exception的子类中，除了RuntimeException之外的其它异常，都是非运行时异常，也就是编译异常。<br>如果是使用Eclipse或者IDEA等IDE开发工具进行开发Java代码的话，如果发生了编译异常，那么IDE会自动爆红提示。这个时候，开发者要么使用try{}catch(){}进行捕获，要么就使用throws关键字进行抛出，抛给调用该方法的那个方法，如果是main方法，则会直接由JVM处理该异常，处理机制为中断运行并打印异常信息。<br>常见的非运行时异常有：</p>
<ul>
<li>IOException（IO异常）</li>
<li>SQLException（SQL异常）</li>
<li>ClassNotFoundException（类没有找到异常）</li>
</ul>
<p>【注意】值得一提的是，Exception是可以被避免的，只要代码设计得足够完美，那么就可以避免异常的发生。</p>
<h2 id="运行时异常和非运行时异常的区别"><a href="#运行时异常和非运行时异常的区别" class="headerlink" title="运行时异常和非运行时异常的区别"></a>运行时异常和非运行时异常的区别</h2><p>【处理机制】</p>
<ul>
<li>运行时异常直接由JVM进行处理，处理机制为中断运行并打印异常信息。</li>
<li>非运行时异常由程序设计者进行处理，处理机制为try{}catch(){}或者throws。</li>
</ul>
<p>【编译】</p>
<ul>
<li><p>运行时异常可以直接通过编译。</p>
</li>
<li><p>非运行时异常如果不进行处理，那么编译无法通过，这也是我们为什么把非运行时异常称为编译异常的原因。</p>
<p>【异常发生之后】</p>
<ul>
<li>运行时异常发生之后，调用代码就不能再继续执行了。</li>
<li>非运行时异常发生之后，代码依然可以继续执行，比如finally中的代码。</li>
</ul>
</li>
</ul>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>Throwable家族中，大致分为三大类：Error，RuntimeException，以及其它的Exception的子类。<br>这三种的问题的严重程度也是由深及浅，其中异常应该是我们尽量避免的，这是作为一个优秀的程序员应该思考是事情。</p>
<p><strong>最后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Lucky <span class="title function_">In2020</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;祝您好运！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——集合框架</title>
    <url>/2020/03/08/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>集合是用来存放数据的，大部分集合底层都是使用数组来进行实现的。但是数组有一个缺点，就是数组一旦初始化后，就无法改变数组的长度，那么我们在存放未知个数的数据的时候，数组就已经无法满足我们的需求了。<br>于是就有了集合，它的底层虽然是数组实现，但是却对底层数组进行了动态维护，使得集合可以动态进行扩容操作，而且提供公有的操作数组的方法，免去了使用索引下标在操作数组时而引起的各种问题。</p>
<span id="more"></span>
<h2 id="Java集合框架结构"><a href="#Java集合框架结构" class="headerlink" title="Java集合框架结构"></a>Java集合框架结构</h2><p><img src="/images/2020/03/20200307175007919.png" alt="在这里插入图片描述"></p>
<p><strong>为什么要有集合？</strong></p>
<p>集合主要有Collection和Map两种体系。</p>
<p><strong>Collection</strong><br>Collection是java.util包下的集合类的顶级接口，它的子类有List和Set。Java中的集合框架都是围绕这一个接口标准而设计实现的。</p>
<p><strong>Map</strong><br>Map是Java.util包下的集合类顶级接口，和Collection同级，它的实现类主要有HashMap，HashTable，ConcurrentHashMap。它存放的数据是key-value形式的。</p>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>List是Collection接口下的一个集合接口，是所有List类的规范接口，它的实现类主要有ArrayList，LinkedList，Vector等实现类。</p>
<ul>
<li><strong>List集合存放元素有顺序，可以存放重复的元素。</strong></li>
</ul>
<p><strong>ArrayList</strong></p>
<ul>
<li>ArrayList是最为常用的集合之一，底层使用数组实现，线程不安全，查找效率快，增删效率慢。</li>
<li>扩容机制：ArrayList扩容后的容量为原来的容量的1.5倍。</li>
<li>ArrayList在使用无参构造创建对象的时候，不会开辟数组空间，在进行第一次添加操作的时候，才进行数组空间的开辟，默认初始化值为10。</li>
</ul>
<p><strong>LinkedList</strong></p>
<ul>
<li>LinkedList底层使用的是Node节点的链表实现，线程不安全，查找效率慢，增删效率快。</li>
</ul>
<p><strong>Vector</strong></p>
<ul>
<li>Vector的功能和ArrayList基本相似，不过Vector是线程安全的集合，底层使用synchronized关键字进行同步。</li>
<li>扩容机制：Vector扩容后的容量为原来的容量的2倍。</li>
</ul>
<p><strong>List集合实现类的区别</strong></p>
<table>
    <tr>
        <td></td>
        <td>ArrayList</td>        
        <td>Vector</td>
        <td>LinkedList</td>
    </tr>
    <tr>
        <td>相同之处</td>
        <td colspan="3">存放元素有顺序，元素可重复 </td>
    </tr>
    <tr>
        <td>底层实现</td>
        <td>数组</td>
        <td>数组</td>
        <td>链表</td>
    </tr>
    <tr>
        <td>是否同步</td>
        <td>不同步，线程不安全</td>
        <td>同步，线程安全</td>
        <td>不同步，线程不安全</td>
    </tr>
    <tr>
        <td>效率</td>
        <td>查找快，增删慢</td>
        <td>查找快，增删慢</td>
        <td>查找慢，增删快</td>
    </tr>
    <tr>
        <td>扩容机制</td>
        <td>扩容后的容量为原来的容量的1.5倍</td>
        <td>扩容后的容量为原来的容量的2倍</td>
        <td>链表，不需要扩容</td>
    </tr>
</table>

<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set接口的实现类主要有HashSet和TreeSet。</p>
<p><strong>HashSet</strong></p>
<ul>
<li>HashSet底层使用的是HashMap实现，元素存取无顺序，元素不可重复，可以存放null值。</li>
</ul>
<p><strong>TreeSet</strong></p>
<ul>
<li>TreeSet底层使用的是二叉树实现。</li>
</ul>
<p><strong>List集合和Set集合的区别</strong></p>
<table>
<thead>
<tr>
<th>List</th>
<th>Set</th>
</tr>
</thead>
<tbody><tr>
<td>元素可重复</td>
<td>元素不可重复</td>
</tr>
<tr>
<td>元素存取有顺序</td>
<td>元素存取无顺序</td>
</tr>
</tbody></table>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>Map集合是哈希类型的集合，也就是散列表结构，用于存放key-value类型的键值对，保证key唯一性。</p>
<p><strong>HashMap（重点）</strong></p>
<ul>
<li>HashMap存放key-value键值对，可以存放null值 ，线程不安全。</li>
<li>HashMap默认初始化容量大小为16，默认负载因子为0.75。</li>
<li>HashMap第一次创建的时候不会开辟数组空间，只有第一次进行put操作的时候，才会进行数组空间的开辟。</li>
<li>HashMap的链表长度大于等于8，会转换为红黑树，红黑树长度小于等于6，会转换为链表。</li>
<li>HashMap在扩容的时候，JDK7及以前的版本先扩容再插入元素，JDK8之后先插入元素再扩容。</li>
<li>HashMap在JDK7及以前版本的时候，使用数组+链表实现，JDK8之后使用数组+链表+红黑树实现。</li>
<li>HashMap在JDK7及以前版本，在发生哈希碰撞的时候，使用头插法插入元素，JDK8之后，使用尾插法插入元素。</li>
</ul>
<p><strong>HashTable</strong></p>
<ul>
<li>HashTable的功能基本和HashMap相似，不过HashTable是线程安全的，使用了synchronized关键字进行同步，HashTable的key-value值不可以存放null值。</li>
</ul>
<p><strong>ConcurrentHashMap</strong></p>
<ul>
<li>ConcurrentHashMap是HashTable的替代类，扩展性和性能比HashTable较好，线程安全。</li>
</ul>
<p><strong>HashMap和HashTable的区别</strong></p>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashTable</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.2出现的集合类</td>
<td>JDK1.1出现的集合类</td>
</tr>
<tr>
<td>线程不安全，不同步</td>
<td>线程安全，底层使用synchronized关键字同步</td>
</tr>
<tr>
<td>key和value可以存放null值</td>
<td>key和value不可以存放null值</td>
</tr>
</tbody></table>
<p><strong>HashMap不同版本的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>JDK7及以前的版本</th>
<th>JDK8</th>
</tr>
</thead>
<tbody><tr>
<td>底层实现</td>
<td>数组+链表</td>
<td>数组+链表+红黑树</td>
</tr>
<tr>
<td>扩容</td>
<td>先扩容再插入键值对</td>
<td>先插入键值对，再进行扩容</td>
</tr>
<tr>
<td>链表插入的方法</td>
<td>头插法</td>
<td>尾插法</td>
</tr>
</tbody></table>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/images/2020/03/20200308121631677.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础——面向对象：抽象，封装，继承，多态</title>
    <url>/2020/03/02/java/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%8A%BD%E8%B1%A1%EF%BC%8C%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>Java是一门面向对象的语言，那什么是面向对象？</p>
<p><strong>面向对象</strong><br>面向对象，也被称作OOP(Object Oriented Programming)，面向对象是一种思想，是指将世界上的所有事物都看作是一个对象。</p>
<span id="more"></span>
<p>面向对象有以下的优点：</p>
<ul>
<li>代码开发模块化，便于维护。</li>
<li>代码具有可复用性，灵活性。</li>
<li>代码可读性强。</li>
</ul>
<p>面向对象的主要思想是抽象，封装，继承，多态。</p>
<ul>
<li><strong>抽象</strong>：把一类事物的公有属性和行为提取出来，封装成一个物理模型，这种研究问题的方法就叫做抽象</li>
<li><strong>封装</strong>：封装就是把抽象的数据和对数据的操作封装在一个类的内部，并提供对外的公有方法用于访问数据。</li>
<li><strong>继承</strong>：继承是从已有类的中派生出新的类，新的类能够吸收已有类的数据属性和行为，并能拓展新的能力。</li>
<li><strong>多态</strong>：多态就是一个引用数据类型，在不同的情况下可以有多种状态，指向父类的指针，来调用不同子类中的实现。</li>
</ul>
<p><img src="/images/2020/03/2020030209492748.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现PDF文件转换为图片</title>
    <url>/2020/09/02/java/Java%E5%AE%9E%E7%8E%B0PDF%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>前几天写了一篇博客<a href="/2020/08/05/java/Java实现图片转换PDF文件/">Java实现图片转换PDF文件</a>，在博客下方有同学评论是否能够将PDF文件转换为图片，所以今天就在这里写了一个将PDF文件转换为图片的简单系统。</p>
</blockquote>
<span id="more"></span>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--SpringMVC的依赖，方便我们可以获取前端传递过来的文件信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--icepdf，用来将pdf文件转换为图片的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.icepdf.os<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>icepdf-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>PDf转换图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.submitButton</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#e37e10</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ff8300</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>PDF转换图片工具<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/pdf/to/image&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return allowFileType()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请选择PDF文件&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;allowFileType()&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid black;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;一键转换图片&quot;</span> <span class="attr">class</span>=<span class="string">&quot;submitButton&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">allowFileType</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file&quot;</span>).<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> fileName = file.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> suffix = fileName.<span class="title function_">substring</span>(fileName.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>),fileName.<span class="property">length</span>).<span class="title function_">toLowerCase</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="string">&#x27;.pdf&#x27;</span> != suffix) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;只允许传入PDF格式的文件！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="控制层接口"><a href="#控制层接口" class="headerlink" title="控制层接口"></a>控制层接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hrp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hrp.util.ImageUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用于处理Pdf相关的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;pdf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;to/image&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pdfToImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,HttpServletResponse response)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ImageUtils.pdfToImage(file,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Image工具类"><a href="#Image工具类" class="headerlink" title="Image工具类"></a>Image工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hrp.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.icepdf.core.pobjects.Document;</span><br><span class="line"><span class="keyword">import</span> org.icepdf.core.pobjects.Page;</span><br><span class="line"><span class="keyword">import</span> org.icepdf.core.util.GraphicsRenderingHints;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: PDF转换为图片的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片文件格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FORMAT_NAME</span> <span class="operator">=</span> <span class="string">&quot;png&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片文件后缀名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PNG_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.png&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩文件后缀名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ZIP_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外的开放接口，用于将PDF文件转换为图片文件压缩包进行下载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file SpringMVC获取的图片文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pdfToImage</span><span class="params">(MultipartFile file, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">zipFile</span> <span class="operator">=</span> generateImageFile(file);</span><br><span class="line">        downloadZipFile(zipFile, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将PDF文件转换为多张图片并放入一个压缩包中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file SpringMVC获取的图片文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 图片文件压缩包</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">generateImageFile</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">        document.setByteArray(file.getBytes(), <span class="number">0</span>, file.getBytes().length, fileName);</span><br><span class="line"></span><br><span class="line">        List&lt;File&gt; fileList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; document.getNumberOfPages(); i++) &#123;</span><br><span class="line">            <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> (BufferedImage) document.getPageImage(i, GraphicsRenderingHints.SCREEN,</span><br><span class="line">                    Page.BOUNDARY_CROPBOX, <span class="number">0F</span>, <span class="number">2.5F</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">imageFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>((i + <span class="number">1</span>) + PNG_SUFFIX);</span><br><span class="line">            ImageIO.write(image, FORMAT_NAME, imageFile);</span><br><span class="line">            image.flush();</span><br><span class="line">            fileList.add(imageFile);</span><br><span class="line">        &#125;</span><br><span class="line">        document.dispose();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">directoryName</span> <span class="operator">=</span> fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="type">File</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directoryName + ZIP_SUFFIX);</span><br><span class="line">        <span class="type">ZipOutputStream</span> <span class="variable">zos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(zipFile));</span><br><span class="line">        zipFile(fileList, zos);</span><br><span class="line">        zos.close();</span><br><span class="line">        <span class="keyword">return</span> zipFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载zip文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile  zip压缩文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">downloadZipFile</span><span class="params">(File zipFile, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[fis.available()];</span><br><span class="line">        fis.read(bytes);</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        response.reset();</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-msdownload&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + URLEncoder.encode(zipFile.getName(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        out.write(bytes);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        zipFile.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFiles 具体需要压缩的文件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zos        ZipOutputStream对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(List&lt;File&gt; inputFiles, ZipOutputStream zos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">for</span> (File file : inputFiles) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">                    zos.putNextEntry(<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(file.getName()));</span><br><span class="line">                    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((size = bis.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        zos.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">                    &#125;</span><br><span class="line">                    zos.closeEntry();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    file.delete();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    File[] files = file.listFiles();</span><br><span class="line">                    List&lt;File&gt; childrenFileList = Arrays.asList(files);</span><br><span class="line">                    zipFile(childrenFileList, zos);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h2><p><img src="/images/2020/09/20200902230305119.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>作者简单测试了一下，该系统是可以顺利运行的，而且作者将后台生成的图片文件和压缩文件都进行了删除，这样就不会对后台系统产生不必要的资源浪费，节约了磁盘空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现图片转换PDF文件</title>
    <url>/2020/08/25/java/Java%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2PDF%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>最近因为一些事情，需要将一张简单的图片转换为PDF的文件格式，在网上找了一些工具，但是这些工具不是需要注册账号，就是需要下载软件。<br>而对于只是转换一张图片的情况下，这些操作显然是非常繁琐的，所以作者就直接使用Java写了一个图片转换PDF的系统，现在将该系统分享在这里。</p>
</blockquote>
<span id="more"></span>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--该项目以SpringBoot为基础搭建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--SpringMVC的依赖，方便我们可以获取前端传递过来的文件信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ITextPdf，操作PDF文件的工具类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图片转换Pdf<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.submitButton</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#e37e10</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ff8300</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>图片转换pdf工具<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/pdf/image/to&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return allowFileType()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请选择图片&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;allowFileType()&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid black;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;一键转换pdf文件&quot;</span> <span class="attr">class</span>=<span class="string">&quot;submitButton&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">allowFileType</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file&quot;</span>).<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> fileName = file.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> fileSize = file.<span class="property">size</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> suffix = fileName.<span class="title function_">substring</span>(fileName.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>),fileName.<span class="property">length</span>).<span class="title function_">toLowerCase</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="string">&#x27;.jpg&#x27;</span> != suffix &amp;&amp; <span class="string">&#x27;.png&#x27;</span> != suffix) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;目前只允许传入.jpg或者.png格式的图片！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(fileSize &gt; <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;上传图片不允许超过2MB!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="控制层接口"><a href="#控制层接口" class="headerlink" title="控制层接口"></a>控制层接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hrp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hrp.util.PdfUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 用于处理Pdf相关的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;pdf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;image/to&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">imageToPdf</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,HttpServletResponse response)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        PdfUtils.imageToPdf(file,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="PDF工具类"><a href="#PDF工具类" class="headerlink" title="PDF工具类"></a>PDF工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hrp.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Document;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.DocumentException;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.Image;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.PageSize;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: pdf相关的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片转换PDF的公共接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file     SpringMVC获取的图片文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException       IO异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DocumentException PDF文档异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">imageToPdf</span><span class="params">(MultipartFile file, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, DocumentException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">pdfFile</span> <span class="operator">=</span> generatePdfFile(file);</span><br><span class="line">        downloadPdfFile(pdfFile, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将图片转换为PDF文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file SpringMVC获取的图片文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PDF文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException       IO异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DocumentException PDF文档异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File <span class="title function_">generatePdfFile</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException, DocumentException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">pdfFileName</span> <span class="operator">=</span> fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>)) + <span class="string">&quot;.pdf&quot;</span>;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>(PageSize.A4, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">        PdfWriter.getInstance(doc, <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(pdfFileName));</span><br><span class="line">        doc.open();</span><br><span class="line">        doc.newPage();</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> Image.getInstance(file.getBytes());</span><br><span class="line">        <span class="type">float</span> <span class="variable">height</span> <span class="operator">=</span> image.getHeight();</span><br><span class="line">        <span class="type">float</span> <span class="variable">width</span> <span class="operator">=</span> image.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">percent</span> <span class="operator">=</span> getPercent(height, width);</span><br><span class="line">        image.setAlignment(Image.MIDDLE);</span><br><span class="line">        image.scalePercent(percent);</span><br><span class="line">        doc.add(image);</span><br><span class="line">        doc.close();</span><br><span class="line">        <span class="type">File</span> <span class="variable">pdfFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pdfFileName);</span><br><span class="line">        <span class="keyword">return</span> pdfFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用于下载PDF文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pdfFile  PDF文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">downloadPdfFile</span><span class="params">(File pdfFile, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(pdfFile);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[fis.available()];</span><br><span class="line">        fis.read(bytes);</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        response.reset();</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/pdf&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + URLEncoder.encode(pdfFile.getName(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        out.write(bytes);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等比压缩，获取压缩百分比</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 图片的高度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图片的宽度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压缩百分比</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getPercent</span><span class="params">(<span class="type">float</span> height, <span class="type">float</span> weight)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">percent</span> <span class="operator">=</span> <span class="number">0.0F</span>;</span><br><span class="line">        <span class="keyword">if</span> (height &gt; weight) &#123;</span><br><span class="line">            percent = PageSize.A4.getHeight() / height * <span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            percent = PageSize.A4.getWidth() / weight * <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.round(percent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h2><p><img src="/images/2020/08/20200825195615602.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>这就是系统启动之后的页面效果，虽然页面比较简陋，但是功能却没有任何折扣，有兴趣或者有需要的同学可以自己搭建一下，试一试图片转换PDF文件的效果。</p>
</blockquote>
<blockquote>
<p><strong>注意：作者自己测试了一下，普通图片基本是没有问题的，但是遇到一些特殊的图片可能会出现异常，毕竟只是一个比较简单的图片转换PDF系统，难以兼容所有图片。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常try{}catch{}中的return机制</title>
    <url>/2020/03/27/java/Java%E5%BC%82%E5%B8%B8try%7B%7Dcatch%7B%7D%E4%B8%AD%E7%9A%84return%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>什么是Java的异常体系？参考博客：<a href="https://blog.csdn.net/qq_45193304/article/details/104146056">Java基础——运行时异常和非运行时异常</a></p>
</blockquote>
<span id="more"></span>
<h1 id="Java异常的处理方式"><a href="#Java异常的处理方式" class="headerlink" title="Java异常的处理方式"></a>Java异常的处理方式</h1><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ul>
<li><code>throw</code>是Java中的一个关键字，可以在方法上声明抛出一个异常，如果方法体中发生了异常，那么方法会通过<code>throw</code>关键字将异常抛出。</li>
<li>Java使用throw关键字抛出异常后，会抛给调用该方法的上一层方法，如果该异常是非运行时异常，那么调用该方法的上一层方法，也需要进行异常处理，<code>throw</code>或者<code>try&#123;&#125;catch&#123;&#125;</code>。</li>
<li>如果该方法声明抛出后，方法中发生了异常，而且该方法是最顶层的方法，没有其他方法调用该方法，那么异常就会被抛给JVM，由JVM进行异常处理。</li>
</ul>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try{}catch{}"></a>try{}catch{}</h2><ul>
<li>在Java的异常体系之中，除了使用<code>throw</code>关键字将异常声明抛出之外，还可以使用<code>try&#123;&#125;catch&#123;&#125;</code>的方式将异常捕获。</li>
<li>Java的异常中，非运行时异常，Java代码编译规定必须进行显式处理的，要么使用<code>throw</code>进行抛出，要么就使用<code>try&#123;&#125;catch&#123;&#125;</code>进行异常的捕获。</li>
</ul>
<h1 id="try-catch-的执行顺序"><a href="#try-catch-的执行顺序" class="headerlink" title="try{}catch{}的执行顺序"></a>try{}catch{}的执行顺序</h1><h2 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h2><ul>
<li>如果是正常情况，代码中没有异常发生，那么代码只会执行try{}中的代码，而catch{}中的代码不会执行。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码正常执行......&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码发生异常后执行......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
正常情况下，以上代码的执行结果是：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码正常执行......</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="发生异常"><a href="#发生异常" class="headerlink" title="发生异常"></a>发生异常</h2><ul>
<li>如果try{}中的代码发生了异常，那么发生异常前的代码会正常执行，而try{}中发生异常后的代码将不会再执行（除了<code>return</code>之外），而是执行catch{}中的代码。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码正常执行......&quot;</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码发生异常了......&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码发生异常后执行......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
发生异常的情况下，以上代码的执行结果是：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码正常执行......</span><br><span class="line">代码发生异常后执行......</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h2></li>
<li><code>finally</code>是<code>try&#123;&#125;catch&#123;&#125;</code>体系中的一部分，全部代码书写为<code>try&#123;&#125;catch&#123;&#125;finally&#123;&#125;</code>。</li>
<li>finally代码块的特点是，无论try{}中是否发生了异常，最后都会执行finally中的代码。</li>
</ul>
<p><strong>正常情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码正常执行......&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码发生异常后执行......&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;finally代码块中的代码一定会执行......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下，以上代码的执行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码正常执行......</span><br><span class="line"><span class="keyword">finally</span>代码块中的代码一定会执行......</span><br></pre></td></tr></table></figure>
<p><strong>发生异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码正常执行......&quot;</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码发生异常了......&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;代码发生异常后执行......&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;finally代码块中的代码一定会执行......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生异常的情况下，以上代码的执行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码正常执行......</span><br><span class="line">代码发生异常后执行......</span><br><span class="line"><span class="keyword">finally</span>代码块中的代码一定会执行......</span><br></pre></td></tr></table></figure>

<h1 id="try-catch-finally-中的return"><a href="#try-catch-finally-中的return" class="headerlink" title="try{}catch{}finally{}中的return"></a>try{}catch{}finally{}中的return</h1><blockquote>
<p>以上的情况都是方法是无返回值的情况，如果方法是有返回值的，并且在try{}catch{}finally{}中都有return，那么方法该return那个返回值呢？</p>
</blockquote>
<h2 id="return的位置"><a href="#return的位置" class="headerlink" title="return的位置"></a>return的位置</h2><p>在探索<code>try&#123;&#125;catch&#123;&#125;finally&#123;&#125;</code>中<code>return</code>的时机之前，我们先根据return的位置，定义一下<code>return</code>的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;try ruturn&quot;</span>;			<span class="comment">//这里定义为正常return</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;catch ruturn&quot;</span>;		<span class="comment">//这里定义为异常return</span></span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;finally ruturn&quot;</span>;		<span class="comment">//这里定义为最终return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;method return&quot;</span>;					<span class="comment">//这里定义为方法return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="return的规则"><a href="#return的规则" class="headerlink" title="return的规则"></a>return的规则</h2><ul>
<li><code>最终return</code>和<code>方法return</code>是互斥的，即在一个方法中，<code>最终return</code>和<code>方法return</code>只能写一个，否则编译无法通过（或者IDE会报错）。</li>
<li>当<code>正常return</code>和<code>异常return</code>都有的时候，<code>最终return</code>可有可无，但是<code>方法return</code>一定不能有，否则报错。</li>
<li>当有<code>最终return</code>的时候，<code>正常return</code>和<code>异常return</code>可有可无。</li>
<li>当没有<code>最终return</code>的时候，要么一定要有<code>正常return</code>和<code>异常return</code>，要么一定要有<code>方法return</code>。</li>
</ul>
<h2 id="return的执行顺序"><a href="#return的执行顺序" class="headerlink" title="return的执行顺序"></a>return的执行顺序</h2><p><strong>当方法中return的时候，那么<code>try&#123;&#125;catch&#123;&#125;finally&#123;&#125;</code>中的代码顺序又该怎么执行呢？</strong></p>
<p>首先，我们来看一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;main:&quot;</span>+test());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;try:&quot;</span> + str);</span><br><span class="line">		System.out.println(<span class="string">&quot;try is running......&quot;</span>);</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> str + <span class="string">&quot;-&gt;try return&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;catch:&quot;</span> + str);</span><br><span class="line">		System.out.println(<span class="string">&quot;catch is running......&quot;</span>);</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> str + <span class="string">&quot;-&gt;catch return&quot;</span>;</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;finally:&quot;</span> + str);</span><br><span class="line">		str = <span class="string">&quot;finally:&quot;</span> + str;</span><br><span class="line">		System.out.println(<span class="string">&quot;finally is running......&quot;</span>);</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;-&gt;finally return&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该段代码的执行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:start</span><br><span class="line"><span class="keyword">try</span> is running......</span><br><span class="line"><span class="keyword">finally</span>:start-&gt;<span class="keyword">try</span> <span class="keyword">return</span>	#这里是System.out.println(<span class="string">&quot;finally:&quot;</span> + str);的输出结果，我们发现str变成了start-&gt;<span class="keyword">try</span> <span class="keyword">return</span></span><br><span class="line"><span class="keyword">finally</span> is running......</span><br><span class="line">main:-&gt;<span class="keyword">finally</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>如果我们去掉finally中的return的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;main:&quot;</span>+test());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;try:&quot;</span> + str);</span><br><span class="line">		System.out.println(<span class="string">&quot;try is running......&quot;</span>);</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> str + <span class="string">&quot;-&gt;try return&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;catch:&quot;</span> + str);</span><br><span class="line">		System.out.println(<span class="string">&quot;catch is running......&quot;</span>);</span><br><span class="line">		<span class="type">return</span> <span class="variable">str</span> <span class="operator">=</span> str + <span class="string">&quot;-&gt;catch return&quot;</span>;</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;finally:&quot;</span> + str);</span><br><span class="line">		str = <span class="string">&quot;finally:&quot;</span> + str;</span><br><span class="line">		System.out.println(<span class="string">&quot;finally is running......&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:start</span><br><span class="line"><span class="keyword">try</span> is running......</span><br><span class="line"><span class="keyword">finally</span>:start-&gt;<span class="keyword">try</span> <span class="keyword">return</span> #这里是System.out.println(<span class="string">&quot;finally:&quot;</span> + str);的输出结果，我们发现str变成了start-&gt;<span class="keyword">try</span> <span class="keyword">return</span></span><br><span class="line"><span class="keyword">finally</span> is running......</span><br><span class="line">main:start-&gt;<span class="keyword">try</span> <span class="keyword">return</span>	#这里执行了<span class="keyword">finally</span>的代码，但是<span class="keyword">return</span>的结果依然是<span class="keyword">try</span>中的返回结果。</span><br></pre></td></tr></table></figure>

<h2 id="return的执行顺序分析图"><a href="#return的执行顺序分析图" class="headerlink" title="return的执行顺序分析图"></a>return的执行顺序分析图</h2><p><img src="/images/2020/03/20200327214558729.png" alt="在这里插入图片描述"><br><img src="/images/2020/03/20200327215517426.png" alt="在这里插入图片描述"><br><strong>如果try中发生异常，代码跳转至<code>catch&#123;&#125;</code>中执行，那么<code>return</code>的执行顺序和原理是和<code>try&#123;&#125;</code>中是一致的。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程</title>
    <url>/2020/04/01/java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><p><strong>软件结构一般分为C/S和B/S结构。</strong></p>
<ul>
<li>C/S结构：全称为Client/Server结构，是指客户端和服务器端结构，常见程序有：QQ、微信等等。</li>
<li>B/S结构：全称为Browser/Server结构，是指浏览器和服务器结构，常见的浏览器有：谷歌、火狐。<span id="more"></span></li>
</ul>
<p><strong>两种架构各有优势，但是无论是哪种架构，都离不开网络的支持，网络编程，就是在一定的协议下，实现两台计算机的通信的程序。</strong></p>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><ul>
<li>网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时一定要遵守一定的规则。在计算机网络中，这些连接和通信的规则被称为网络通信协议。它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
<li>TCP/IP协议：传输控制协议/因特网互联协议，是Internet最基本的、最广泛的协议，它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准，它的内部包含了一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的请求。</li>
</ul>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p><strong>UDP</strong></p>
<ul>
<li>用户数据报协议，UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据的时候，发送端不会确认接收端是否存在，就会发出数据，同时接收端在收到数据时，也不会向发送端反馈是否收到数据。</li>
<li>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输。例如视频会议都是用UDP协议，因为这种情况即使是丢失一两个包，也不会对接收结果产生太大的影响。</li>
<li>但是在使用UPD协议传送数据的时候，由于UDP协议的面向无连接特性，不能保证数据的完整性，因此在传输重要数据时，不建议使用UDP协议。</li>
<li>特点：数据被限制在64kb以内，超出这个范围就不能发送了。</li>
</ul>
<p><strong>TCP</strong></p>
<ul>
<li>传输数据协议，TCP是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</li>
<li>在TCP连接中必须要明确客户端和服务器端，由客户端向服务器端发出连接请求，每次连接的创建都需要经过三次握手。</li>
<li>TCP协议可以参考博客：<a href="/2020/03/22/computer/TCP协议的三次握手和四次挥手/">TCP协议的三次握手和四次挥手</a>。</li>
</ul>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p><strong>IP地址：指互联网协议地址，IP地址是用来给一个网络中的计算机设备的唯一编号。</strong></p>
<p><strong>IPv4：</strong> 指一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d的形式，其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
<p><strong>IPv6：</strong> 由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张，为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制。IPv6号称可以给全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不足的问题。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>端口号是一个逻辑端口，我们无法直接看到，可以使用一些软件查看端口号。</p>
<p>端口号是由两个字节组成的，取值范围在0-65535之间。</p>
<p><strong>【注意】1024之前的端口号不允许使用，因为这些端口号已经被系统分配给已知道的网络软件了。</strong><br><strong>【注意】端口号不能重复。</strong></p>
<p><strong>常用端口号</strong></p>
<ul>
<li>80：网络端口</li>
<li>8080：Tomcat</li>
<li>3306：MySQL</li>
</ul>
<h2 id="Java程序实现TCP通信"><a href="#Java程序实现TCP通信" class="headerlink" title="Java程序实现TCP通信"></a>Java程序实现TCP通信</h2><p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">		</span><br><span class="line">		os.write(<span class="string">&quot;您好，服务器&quot;</span>.getBytes());</span><br><span class="line">		</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">		<span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">		</span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>服务器端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">		<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">		</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">		<span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">		</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">		os.write(<span class="string">&quot;收到，谢谢&quot;</span>.getBytes());</span><br><span class="line">		</span><br><span class="line">		socket.close();</span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java自定义异常</title>
    <url>/2020/03/23/java/Java%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>在Java中，异常是Java的一个类，所有的异常都是以Java对象的形式存在Java程序中，异常最顶层的类是Exception，Exception和它的所有子类构成了Java的异常体系。</p>
</blockquote>
<span id="more"></span>

<h1 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h1><p>如果不了解Java的异常体系，可以参考我以前写的博客<a href="/2020/02/02/java/运行时异常和非运行时异常/">Java基础——运行时异常和非运行时异常</a>。</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>在Java中，JDK已经帮我们定义了很多异常，例如IOException，SQLException等等，但是这并不意味着JDK已经把所有的异常囊括其中了，对于开发环境的各种需要，很多时候，可能需要我们自定义一些异常，以帮我们完成开发。</p>
<h2 id="怎么自定义异常？"><a href="#怎么自定义异常？" class="headerlink" title="怎么自定义异常？"></a>怎么自定义异常？</h2><p>刚刚已经说过了，Exception类和它的子类构成了Java语言的异常体系。所以，如果我们想要自定义一个异常，那么就直接继承Exception类或者它的子类就可以了，凡是由Exception类和它的子类派生出来的类，都是一个异常类。</p>
<h2 id="自定义异常的区别"><a href="#自定义异常的区别" class="headerlink" title="自定义异常的区别"></a>自定义异常的区别</h2><p>在Java的异常体系中，分为运行时异常和非运行时异常，所以我们自定义的异常也被区分在这两种异常类别中。</p>
<ul>
<li>其中凡是继承自RuntimeException的异常，都是运行时异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">	<span class="comment">//运行时异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承Exception或者Exception的子类（非RuntimeException异常）的异常都是非运行时异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">	<span class="comment">//非运行时异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义的异常同样符合Java异常体系的所有特点，运行时异常我们可以不需要捕获，非运行时异常需要我们手动抛出或者捕获异常。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>在自定义异常中，我们为了便于管理和实例化自定义异常类，一般会将异常信息定义在枚举类。</p>
<h2 id="什么是枚举？"><a href="#什么是枚举？" class="headerlink" title="什么是枚举？"></a>什么是枚举？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">ExceptionEnum</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类使用<code>enum</code>作为关键字，声明这是一个枚举类。</p>
<p>枚举类其实就是一个普通的Java类，但是这个类默认继承了<code>java.lang.Enum</code>类，所以比起Java中的普通类，有了一些其他的特征，这就是枚举类的特征。</p>
<ul>
<li>非抽象的枚举类，默认使用<code>final</code>修饰，所以枚举类不能派生子类。</li>
<li>枚举类只能定义一个<code>public</code>修饰的类，而且类名必须与文件名相同（和普通的Java类规则相同）。</li>
<li>枚举类的构造器默认是<code>private</code>，所以外部无法创建枚举类的实例对象，只能由枚举类自身创建。</li>
<li>枚举类的实例对象必须在枚举类的第一行显示标识出来，这些实例对象默认是<code>public static final</code>修饰的属性。</li>
<li>枚举对象默认提供了一个<code>values()</code>方法，用于遍历该枚举类的所有实例对象，返回值是一个枚举类数组。</li>
</ul>
<h2 id="使用枚举定义异常信息"><a href="#使用枚举定义异常信息" class="headerlink" title="使用枚举定义异常信息"></a>使用枚举定义异常信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">ExceptionEnum</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码错误异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CODE_ERROR(<span class="number">500</span>,<span class="string">&quot;代码错误&quot;</span>),</span><br><span class="line">    REQUEST_ERROR(<span class="number">400</span>,<span class="string">&quot;请求错误&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义异常实战"><a href="#自定义异常实战" class="headerlink" title="自定义异常实战"></a>自定义异常实战</h1><h2 id="自定义运行时异常"><a href="#自定义运行时异常" class="headerlink" title="自定义运行时异常"></a>自定义运行时异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExceptionEnum exceptionEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(ExceptionEnum.CODE_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong><br><img src="/images/2020/03/20200323003301480.png" alt="在这里插入图片描述"></p>
<h2 id="自定义非运行时异常"><a href="#自定义非运行时异常" class="headerlink" title="自定义非运行时异常"></a>自定义非运行时异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExceptionEnum exceptionEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(ExceptionEnum.REQUEST_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong><br><img src="/images/2020/03/20200323003410442.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven项目pom.xml project标签爆红解决方法</title>
    <url>/2020/08/19/java/Maven%E9%A1%B9%E7%9B%AEpom.xml%20project%E6%A0%87%E7%AD%BE%E7%88%86%E7%BA%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天在打开项目的时候，发现了一个Maven项目的问题，在Maven项目的pom.xml文件中，project标签爆出了一个错误。</p>
<span id="more"></span>

<p><img src="/images/2020/08/20200819081650697.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>‘parent.relativePath’ of POM com.hrp:springboot_jpa:1.0-SNAPSHOT (F:\IdeaCode\java-web\springboot_jpa\pom.xml) points at com.hrp:java-web instead of org.springframework.boot:spring-boot-starter-parent, please verify your project structure</p>
</blockquote>
<blockquote>
<p>POM com.hrp：springboot_jpa：1.0-SNAPSHOT（F：\ IdeaCode \ java-web \ springboot_jpa \ pom.xml）的’parent.relativePath’指向com.hrp：java-web而不是org.springframework.boot：spring -boot-starter-parent，请验证您的项目结构</p>
</blockquote>
<p>总而言之，这个问题是说在project标签下的parent.relativePath标签指向的路径出现了错误，所以导致报错。</p>
<p><strong>要解决这个问题的方法也很简单，在parent标签下添加一个<code>&lt;relativePath/&gt;</code>标签即可。</strong></p>
<p><img src="/images/2020/08/20200819082030419.png" alt="在这里插入图片描述"><br><strong>添加该标签之后，我们重新更新Maven项目，爆错就会消失了</strong></p>
<p><img src="/images/2020/08/20200819082324299.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus升级3.4.3.1版本报错：MybatisConfiguration$StrictMap$Ambiguity cannot be cast to ResultMap</title>
    <url>/2021/06/29/java/MyBatisPlus%E5%8D%87%E7%BA%A73.4.3.1%E7%89%88%E6%9C%AC%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>SpringBoot 版本：2.5.2<br>项目原本的 MyBatisPlus 版本为：3.4.0，项目可以正常启动运行，但是在将 MyBatisPlus 的版本升级至 3.4.3.1之后，项目启动 MyBatisPlus 就开始报错了。</p>
</blockquote>
<span id="more"></span>

<p>报错信息较多，在这里截取其中比较重要的几段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">29</span> <span class="number">23</span>:<span class="number">25</span>:<span class="number">42.015</span> [main] ERROR org.mybatis.spring.mapper.MapperFactoryBean - Error <span class="keyword">while</span> adding the mapper <span class="string">&#x27;interface com.zero.auth.mapper.UserMapper&#x27;</span> to configuration.</span><br><span class="line">org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is <span class="string">&#x27;com/zero/auth/mapper/UserMapper.xml&#x27;</span>. Cause: java.lang.ClassCastException: <span class="keyword">class</span> <span class="title class_">com</span>.baomidou.mybatisplus.core.MybatisConfiguration$StrictMap$Ambiguity cannot be cast to <span class="keyword">class</span> <span class="title class_">org</span>.apache.ibatis.mapping.ResultMap (com.baomidou.mybatisplus.core.MybatisConfiguration$StrictMap$Ambiguity and org.apache.ibatis.mapping.ResultMap are in unnamed <span class="keyword">module</span> of loader <span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:<span class="number">123</span>)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.parse(XMLMapperBuilder.java:<span class="number">95</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.loadXmlResource(MybatisMapperAnnotationBuilder.java:<span class="number">172</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.parse(MybatisMapperAnnotationBuilder.java:<span class="number">93</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.core.MybatisMapperRegistry.addMapper(MybatisMapperRegistry.java:<span class="number">83</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.core.MybatisConfiguration.addMapper(MybatisConfiguration.java:<span class="number">119</span>)</span><br><span class="line">	at org.mybatis.spring.mapper.MapperFactoryBean.checkDaoConfig(MapperFactoryBean.java:<span class="number">80</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.ClassCastException: <span class="keyword">class</span> <span class="title class_">com</span>.baomidou.mybatisplus.core.MybatisConfiguration$StrictMap$Ambiguity cannot be cast to <span class="keyword">class</span> <span class="title class_">org</span>.apache.ibatis.mapping.ResultMap (com.baomidou.mybatisplus.core.MybatisConfiguration$StrictMap$Ambiguity and org.apache.ibatis.mapping.ResultMap are in unnamed <span class="keyword">module</span> of loader <span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.core.MybatisConfiguration.checkGloballyForDiscriminatedNestedResultMaps(MybatisConfiguration.java:<span class="number">318</span>)</span><br><span class="line">	at com.baomidou.mybatisplus.core.MybatisConfiguration.addResultMap(MybatisConfiguration.java:<span class="number">222</span>)</span><br><span class="line">	at org.apache.ibatis.builder.MapperBuilderAssistant.addResultMap(MapperBuilderAssistant.java:<span class="number">209</span>)</span><br><span class="line">	at org.apache.ibatis.builder.ResultMapResolver.resolve(ResultMapResolver.java:<span class="number">47</span>)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:<span class="number">289</span>)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:<span class="number">254</span>)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElements(XMLMapperBuilder.java:<span class="number">246</span>)</span><br><span class="line">	at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:<span class="number">119</span>)</span><br><span class="line">	... <span class="number">39</span> common frames omitted</span><br></pre></td></tr></table></figure>

<h2 id="报错信息分析"><a href="#报错信息分析" class="headerlink" title="报错信息分析"></a>报错信息分析</h2><p>在报错信息中，报告了一个 <code>java.lang.ClassCastException</code> 异常，这是 Java 中的类型转换异常。<br>具体的信息为<code>class com.baomidou.mybatisplus.core.MybatisConfiguration$StrictMap$Ambiguity cannot be cast to class org.apache.ibatis.mapping.ResultMap</code>。<br>一个 <code>MybatisConfiguration$StrictMap$Ambiguity</code> 类型的对象无法转换为 <code>ResultMap</code> 对象。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>经过一段时间的 Debug，最终还是定位到了原因。具体的原因可以看 MyBatisPlus 中的 <code>com.baomidou.mybatisplus.core.MybatisConfiguration#checkGloballyForDiscriminatedNestedResultMaps</code> 方法。</p>
<p><strong>以下是 MyBatisPlus 中该方法的源代码：</strong></p>
<h3 id="MyBatisPlus-3-4-0"><a href="#MyBatisPlus-3-4-0" class="headerlink" title="MyBatisPlus 3.4.0"></a>MyBatisPlus 3.4.0</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">checkGloballyForDiscriminatedNestedResultMaps</span><span class="params">(ResultMap rm)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rm.hasNestedResultMaps()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, ResultMap&gt; entry : resultMaps.entrySet()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResultMap) &#123;</span><br><span class="line">                <span class="type">ResultMap</span> <span class="variable">entryResultMap</span> <span class="operator">=</span> (ResultMap) value;</span><br><span class="line">                <span class="keyword">if</span> (!entryResultMap.hasNestedResultMaps() &amp;&amp; entryResultMap.getDiscriminator() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Collection&lt;String&gt; discriminatedResultMapNames = entryResultMap.getDiscriminator().getDiscriminatorMap().values();</span><br><span class="line">                    <span class="keyword">if</span> (discriminatedResultMapNames.contains(rm.getId())) &#123;</span><br><span class="line">                        entryResultMap.forceNestedResultMaps();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MyBatisPlus-3-4-3-1"><a href="#MyBatisPlus-3-4-3-1" class="headerlink" title="MyBatisPlus 3.4.3.1"></a>MyBatisPlus 3.4.3.1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">checkGloballyForDiscriminatedNestedResultMaps</span><span class="params">(ResultMap rm)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rm.hasNestedResultMaps()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, ResultMap&gt; entry : resultMaps.entrySet()) &#123;</span><br><span class="line">            <span class="type">ResultMap</span> <span class="variable">entryResultMap</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (entryResultMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!entryResultMap.hasNestedResultMaps() &amp;&amp; entryResultMap.getDiscriminator() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Collection&lt;String&gt; discriminatedResultMapNames = entryResultMap.getDiscriminator().getDiscriminatorMap().values();</span><br><span class="line">                    <span class="keyword">if</span> (discriminatedResultMapNames.contains(rm.getId())) &#123;</span><br><span class="line">                        entryResultMap.forceNestedResultMaps();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看到，在 <code>3.4.0</code> 版本中，Map 循环里面 getValue() 方法获取的是 Object 对象，而后有一层 <code>instanceof</code> 的安全类型检查。<br>而在 <code>3.4.3.1</code> 版本中，Map 循环直接获取的就是 <code>ResultMap</code> 对象，但是在该 Map 中存放的并不全是 <code>ResultMap</code> 对象，最终导致类型转换异常。</p>
<h3 id="泛型检查？"><a href="#泛型检查？" class="headerlink" title="泛型检查？"></a>泛型检查？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> <span class="title class_">StrictMap</span>&lt;&gt;(<span class="string">&quot;Result Maps collection&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码中 <code>resultMaps</code>的就是<code>checkGloballyForDiscriminatedNestedResultMaps</code> 方法中循环的 <code>resultMaps</code> 对象，可以看到该 Map 对象声明了泛型，但是最终在存放元素的时候还是绕过了泛型检查。</p>
<p><code>resultMaps</code> 使用的是 MyBatisPlus 自己实现了一个 Map 类型 <code>StrictMap</code>，可以去检查一下这个类型的 <code>put</code> 方法。</p>
<h3 id="StrictMap"><a href="#StrictMap" class="headerlink" title="StrictMap"></a>StrictMap</h3><p><strong>com.baomidou.mybatisplus.core.MybatisConfiguration.StrictMap</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">StrictMap</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;String, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4950446264854982944L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BiFunction&lt;V, V, String&gt; conflictMessageProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StrictMap</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StrictMap&lt;V&gt; <span class="title function_">conflictMessageProducer</span><span class="params">(BiFunction&lt;V, V, String&gt; conflictMessageProducer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conflictMessageProducer = conflictMessageProducer;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(String key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(name + <span class="string">&quot; already contains value for &quot;</span> + key</span><br><span class="line">                + (conflictMessageProducer == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : conflictMessageProducer.apply(<span class="built_in">super</span>.get(key), value)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (useGeneratedShortKey) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">shortKey</span> <span class="operator">=</span> getShortName(key);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">super</span>.get(shortKey) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">super</span>.put(shortKey, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">super</span>.put(shortKey, (V) <span class="keyword">new</span> <span class="title class_">Ambiguity</span>(shortKey));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.get(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(name + <span class="string">&quot; does not contain value for &quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (useGeneratedShortKey &amp;&amp; value <span class="keyword">instanceof</span> StrictMap.Ambiguity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(((StrictMap.Ambiguity) value).getSubject() + <span class="string">&quot; is ambiguous in &quot;</span> + name</span><br><span class="line">                + <span class="string">&quot; (try using the full name including the namespace, or rename one of the entries)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Ambiguity</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String subject;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Ambiguity</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getSubject</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> subject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getShortName</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] keyParts = key.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> keyParts[keyParts.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>StrictMap</code> 重写的 <code>put</code> 方法中，有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.put(shortKey, (V) <span class="keyword">new</span> <span class="title class_">Ambiguity</span>(shortKey));</span><br></pre></td></tr></table></figure>
<p>将 <code>com.baomidou.mybatisplus.core.MybatisConfiguration.StrictMap.Ambiguity</code> 类型的对象强转为 Value 泛型。<br>于是，一个原本就不是 <code>ResultMap</code> 类型的对象，就这么绕过泛型检查，直接存放进入 Map 集合中。</p>
<p>然后在 MyBatisPlus 3.4.3.1 版本中，不知道哪位同学将 <code>instanceof</code> 类型检查的代码去掉了，最终导致 MyBatisPlus 在升级至 3.4.3.1 版本中之后开始报错。</p>
<h2 id="源码提交日志"><a href="#源码提交日志" class="headerlink" title="源码提交日志"></a>源码提交日志</h2><p>我去 GiHub 上查看了 MyBatisPlus 3.4.0 版本至 3.4.3.1 版本之间的升级日志，没有一条更新日志提到这个问题，我个人觉得这是一个 BUG。</p>
<h3 id="6月3号"><a href="#6月3号" class="headerlink" title="6月3号"></a>6月3号</h3><p>一位 MyBatisPlus 的维护者提交了代码，对 <code>com.baomidou.mybatisplus.core.MybatisConfiguration#checkGloballyForDiscriminatedNestedResultMaps</code> 方法进行了优化，去掉了该方法中的  <code>instanceof</code> 的安全类型检查，具体如下：</p>
<p><img src="/images/2021/06/20210630082030289.png" alt="在这里插入图片描述"></p>
<p>从这位开发者的角度我觉得这段优化完全没有问题，毕竟这个 Map 容器使用了泛型，完全可以直接返回泛型类型对象，不需要多此一举使用   <code>instanceof</code> 进行安全类型检查。<br>但是这位开发者不知道的是，在这个 Map 容器里面，重写的 put 方法完全不讲武德，对非泛型类型的对象进行强转，放入 Map 容器中。</p>
<p>这位开发者完全是遭受了无妄之灾，这应该是当初设置这个 Map 容器的这位大神的问题，既然使用了泛型进行类型编译检查，就不应该在 put 的时候进行类型强制转行。或者说，既然需要存放不一致的类型，当初设计的时候就应该将泛型设置为 <code>Object</code> 类型。</p>
<h3 id="6月15日"><a href="#6月15日" class="headerlink" title="6月15日"></a>6月15日</h3><p>MyBatisPlus 发布了 <code>3.4.3.1</code> 版本，也就是包含这个 BUG 的版本。<br><img src="/images/2021/06/20210630082559561.png" alt="在这里插入图片描述"></p>
<h3 id="6月16日"><a href="#6月16日" class="headerlink" title="6月16日"></a>6月16日</h3><p>另外一位维护者似乎意识到了这个 BUG，提交了代码对该问题进行了修复，也就是将原始代码进行了还原。</p>
<p><img src="/images/2021/06/20210630082700362.png" alt="在这里插入图片描述"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>根据 GitHub 上的提交记录，很明显发现，这个问题是一个版本 BUG，虽然在最新的 GiHub 仓库中问题已经被修复了，但是 <code>3.4.3.1</code> 版本中依然存在该 BUG。</p>
<p>如果你在项目中使用 MyBatisPlus 3.4.3.1 版本，出现了我博客中描述的相关问题，那就只能通过修改版本来解决了。</p>
<p>要么降回原来的版本，或者等 MyBatisPlus 发布更新的版本，解决该 BUG。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty4入门教程，搭建简单的Netty服务端和客户端</title>
    <url>/2021/08/25/java/Netty4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="什么是-Netty"><a href="#什么是-Netty" class="headerlink" title="什么是 Netty?"></a>什么是 Netty?</h1><blockquote>
<p>Netty 是 jboss 提供的一个 Java 开源框架，Netty 提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可用性的网络服务器和客户端程序。也就是说 Netty 是一个基于 NIO 的编程框架，使用 Netty 可以快速的开发出一个网络应用。<br>由于 Java 自带的 NIO API 使用起来非常复杂，并且还可能出现 Epoll Bug，这使得我们使用原生的 NIO 来进行网络编程存在很大的难度且非常耗时。但是 Netty 良好的设计可以使开发人员快速高效的进行网络应用开发。</p>
</blockquote>
<span id="more"></span>
<h1 id="Netty-入门"><a href="#Netty-入门" class="headerlink" title="Netty 入门"></a>Netty 入门</h1><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><p>首先需要搭建一个普通的 Maven 项目，JDK 版本为 JDK8。</p>
<h2 id="引入-Netty-依赖"><a href="#引入-Netty-依赖" class="headerlink" title="引入 Netty 依赖"></a>引入 Netty 依赖</h2><blockquote>
<p>由于 Netty5 已经被废弃，目前最新的 Netty 版本是 Netty4。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.67.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="搭建-Netty-服务端"><a href="#搭建-Netty-服务端" class="headerlink" title="搭建 Netty 服务端"></a>搭建 Netty 服务端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NettyServer</span> <span class="variable">nettyServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServer</span>();</span><br><span class="line">        nettyServer.start(<span class="number">12345</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.定义执行线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.定义服务类</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">// 3.设置线程池</span></span><br><span class="line">            serverBootstrap.group(group);</span><br><span class="line">            <span class="comment">// 4.设置通道</span></span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">// 5.绑定端口</span></span><br><span class="line">            serverBootstrap.localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">            <span class="comment">// 6.添加Handler</span></span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;StringDecoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;StringEncoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;ServerHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">                            System.out.println(<span class="string">&quot;server receive UserToken[&quot;</span> + channel.id().asLongText() + <span class="string">&quot;] msg ==&gt; &quot;</span> + msg);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">                            System.out.println(<span class="string">&quot;UserToken[&quot;</span> + channel.id().asLongText() + <span class="string">&quot;] 创建链接&quot;</span>);</span><br><span class="line">                            <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="string">&quot;The server created a link!&quot;</span>, StandardCharsets.UTF_8));</span><br><span class="line">                            ctx.writeAndFlush(buf.duplicate());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">                            System.out.println(<span class="string">&quot;UserToken[&quot;</span> + channel.id().asLongText() + <span class="string">&quot;] 断开链接&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">                            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">                            System.out.println(<span class="string">&quot;UserToken[&quot;</span> + channel.id().asLongText() + <span class="string">&quot;] 发生异常&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind().sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭建-Netty-客户端"><a href="#搭建-Netty-客户端" class="headerlink" title="搭建 Netty 客户端"></a>搭建 Netty 客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NettyClient</span> <span class="variable">nettyClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClient</span>();</span><br><span class="line">        nettyClient.start(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">12345</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.定义执行线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.定义客户端类</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">clientBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">// 3.设置线程池</span></span><br><span class="line">            clientBootstrap.group(group);</span><br><span class="line">            <span class="comment">// 4.设置通道</span></span><br><span class="line">            clientBootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            <span class="comment">// 5.添加Handler</span></span><br><span class="line">            clientBootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;StringDecoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;StringEncoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    pipeline.addLast(<span class="string">&quot;ClientHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;client receive msg ==&gt; &quot;</span> + msg.toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.建立连接</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> clientBootstrap.connect(host, port);</span><br><span class="line">            <span class="comment">// 7.测试输入</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Please enter:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">                channelFuture.channel().writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 8.关闭连接</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p>分别启动 NettyServer 和 NettyClient 的 main 方法，服务器和客户端即可进行简单的通讯。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>ProtoBuf入门</title>
    <url>/2022/02/14/java/ProtoBuf%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="什么是-ProtoBuf"><a href="#什么是-ProtoBuf" class="headerlink" title="什么是 ProtoBuf"></a>什么是 ProtoBuf</h2><p><code>protocol buffers</code> 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。</p>
<p><code>Protocol Buffers</code> 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 <code>XML</code>，但是比 <code>XML</code>更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。</p>
<p>你可以定义数据的结构，然后使用特殊生成的源代码轻松的在各种数据流中使用各种语言进行编写和读取结构数据。你甚至可以更新数据结构，而不破坏由旧数据结构编译的已部署程序。</p>
<span id="more"></span>

<blockquote>
<p><code>ProtoBuf</code> 是一种结构数据序列化的方法，类似于 <code>XML</code>、<code>Json</code> 等数据序列化格式，具有语言无关、平台无关、可扩展、灵活高效等特点。</p>
</blockquote>
<h2 id="怎么使用-ProtoBuf"><a href="#怎么使用-ProtoBuf" class="headerlink" title="怎么使用 ProtoBuf"></a>怎么使用 ProtoBuf</h2><h3 id="下载-protoc-编译器"><a href="#下载-protoc-编译器" class="headerlink" title="下载 protoc 编译器"></a>下载 protoc 编译器</h3><p>在使用 <code>ProtoBuf</code> 之前，需要先下载 <code>ProtoBuf</code> 编译器</p>
<p><strong>下载地址：</strong><a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>
<p><img src="/images/2023/02/300001.png" alt=""></p>
<p>下载之后将压缩包放置到工作目录下，并解压到当前文件夹，将 <code>bin</code> 目录下的 <code>protoc</code> 可执行文件复制到工作目录下即可。</p>
<h3 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h3><p><code>ProtoBuf</code> 使用 <code>.proto</code> 文件来进行数据结构的定义。</p>
<p>在 <code>protoc</code> 可执行文件的同级别目录下创建一个 <code>.proto</code> 文件，并在文件中定义数据结构。</p>
<p>例如：编写一个 <code>user.proto</code> 文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> user;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译生成的Java可读写文件是否多文件生成</span></span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 编译生成的Java文件的目录，该目录可以由protoc编译器自动生成</span></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.herenpeng.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 编译生成的Java可读写文件名称，最终Java文件路径为 com.herenpeng.proto.UserProto</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;UserProto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个User数据结构</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>;     <span class="comment">// 定义一个int32类型的id属性</span></span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;  <span class="comment">// 定义一个string类型的name属性</span></span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>; <span class="comment">// 定义一个string类型的email属性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个枚举类型</span></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个手机号数据结构</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="type">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个PhoneNumber集合类型的phones属性</span></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="protoc-编译可以读写的接口文件"><a href="#protoc-编译可以读写的接口文件" class="headerlink" title="protoc 编译可以读写的接口文件"></a>protoc 编译可以读写的接口文件</h3><p>进入当前工作目录下的命令行界面，直接 <code>protoc</code> 编译命令，即可生成 <code>ProtoBuf</code> 可读写的Java接口文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc ./user.proto --java_out=./</span><br></pre></td></tr></table></figure>



<ul>
<li>第一个参数：<code>protoc</code> 编译器可编译的 <code>.proto</code> 文件的路径。</li>
<li>第二个参数 <code>--java_out=</code>：为 <code>protoc</code> 编译器编译之后，生成的 <code>Java</code> 可读写文件的路径。（该路径需要手动创建，<code>protoc</code>无法自动创建）</li>
</ul>
<blockquote>
<p>如果在开发中需要频繁进行编译生成工作，可以考虑将命令写成一个 <code>.bat</code> 或<code>.sh</code>脚本，将输出如今直接指向项目中的包路径。如果编译输出的路径不是在项目的包下，则需要自己手动将编译生成的接口文件复制到项目对应的目录下。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc ./*.proto --java_out=../src/main/java</span><br></pre></td></tr></table></figure>



<h3 id="引入-ProtoBuf-依赖"><a href="#引入-ProtoBuf-依赖" class="headerlink" title="引入 ProtoBuf 依赖"></a>引入 ProtoBuf 依赖</h3><p>在项目中使用 <code>ProtoBuf</code> ，需要引入 <code>ProtoBuf</code>相关的依赖。</p>
<p>在引入依赖的时候需要注意一点，引入的 <code>ProtoBuf</code> 依赖的版本尽量与 <code>protoc</code> 编译器的版本保持一致，如果版本不同，可能会出现一些不兼容的情况。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.19.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="调用接口序列化数据"><a href="#调用接口序列化数据" class="headerlink" title="调用接口序列化数据"></a>调用接口序列化数据</h3><p><code>ProtoBuf</code>可以调用 <code>Builder</code> 接口进行属性设置，属性设置完成之后则使用 <code>build()</code> 方法进行数据构造，最后使用 <code>toByteArray()</code> 生成字节数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserProto.User.<span class="type">Builder</span> <span class="variable">user</span> <span class="operator">=</span> UserProto.User.newBuilder();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">user.setEmail(<span class="string">&quot;xiaoming@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">UserProto.User.PhoneNumber.<span class="type">Builder</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> UserProto.User.PhoneNumber.newBuilder();</span><br><span class="line">phoneNumber.setNumber(<span class="string">&quot;18478524512&quot;</span>);</span><br><span class="line">phoneNumber.setType(UserProto.User.PhoneType.HOME);</span><br><span class="line">user.addPhones(phoneNumber);</span><br><span class="line"></span><br><span class="line">System.out.println(user.build());</span><br><span class="line">System.out.println(Arrays.toString(user.build().toByteArray()));</span><br></pre></td></tr></table></figure>



<h2 id="ProtoBuf-的优缺点"><a href="#ProtoBuf-的优缺点" class="headerlink" title="ProtoBuf 的优缺点"></a>ProtoBuf 的优缺点</h2><p><code>ProtoBuf</code>与 <code>XML</code>、<code>Json</code>都是序列化数据的方式，但是这三者直接还是有一些差异的，所使用的场景也各不相同。</p>
<ul>
<li><p><code>ProtoBuf</code> 更加注重效率，序列化之后是字节数组，数据更小、传输速率更快，但是人类可读性差。</p>
</li>
<li><p><code>XML</code> 和 <code>Json</code> 序列化之后的数据人类可读性强。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ProtoBuf</tag>
      </tags>
  </entry>
  <entry>
    <title>ServiceLoader加载接口的所有实现</title>
    <url>/2021/06/27/java/ServiceLoader%E5%8A%A0%E8%BD%BD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="什么是ServiceLoader？"><a href="#什么是ServiceLoader？" class="headerlink" title="什么是ServiceLoader？"></a>什么是ServiceLoader？</h1><p>ServiceLoader 是由 JDK 提供的，在 <code>java.util</code> 包下的一个工具类，使用该工具类，可以加载一个接口的所有实现类。</p>
<span id="more"></span>
<h1 id="getBeansOfType"><a href="#getBeansOfType" class="headerlink" title="getBeansOfType()"></a>getBeansOfType()</h1><p>在 Spring 框架中，<code>ApplicationContext</code> 类提供了 <code>getBeansOfType()</code> 方法，同样可以启到和 <code>ServiceLoader</code> 相同的效果，可以获取同一类接口的所有实现类。<br>不过这个方法仅限于被 Spring 管理的项目，如果一个项目没有被 Spring 管理，也就无法使用该方法，这时就可以考虑使用 <code>ServiceLoader</code>。</p>
<h1 id="ServiceLoader的使用"><a href="#ServiceLoader的使用" class="headerlink" title="ServiceLoader的使用"></a>ServiceLoader的使用</h1><h2 id="接口和实现类"><a href="#接口和实现类" class="headerlink" title="接口和实现类"></a>接口和实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户服务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色服务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcesServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;资源服务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置META-INF-services"><a href="#配置META-INF-services" class="headerlink" title="配置META-INF/services"></a>配置META-INF/services</h2><p>在项目的 <code>resources</code> 目录下，创建目录 <code>META-INF/services</code>，该目录为固定目录，<code>ServiceLoader</code>会默认读取该目录下的资源和文件。</p>
<p>在 <code>META-INF/services</code> 目录下创建一个文件，文件名为接口的全限定类名。<br>例如上述的 <code>IService</code>接口，应该在 <code>META-INF/services</code> 目录下创建 <code>com.loader.IService</code> 文件。</p>
<blockquote>
<p>其中 <code>com.loader</code> 为自定义的包名称，并非定式包名。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resources</span><br><span class="line">	|_META-INF</span><br><span class="line">		|_services</span><br><span class="line">			|_com.loader.IService</span><br></pre></td></tr></table></figure>

<p><strong>com.loader.IService</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 注释</span><br><span class="line">com.loader.UserServiceImpl</span><br><span class="line">com.loader.RoleServiceImpl</span><br><span class="line">com.loader.ResourcesServiceImpl</span><br></pre></td></tr></table></figure>

<h2 id="load-方法"><a href="#load-方法" class="headerlink" title="load()方法"></a>load()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;IService&gt; services = ServiceLoader.load(IService.class);</span><br><span class="line">        <span class="keyword">for</span> (IService item : services) &#123;</span><br><span class="line">            item.service();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ServiceLoader的缺点"><a href="#ServiceLoader的缺点" class="headerlink" title="ServiceLoader的缺点"></a>ServiceLoader的缺点</h1><ul>
<li><p>ServiceLoader 虽然可以加载一个接口的所有实现类，但是本质上还是通过 <code>META-INF/services</code> 目录下配置文件，通过 Java 反射功能进行加载的，并无法实现动态加载的效果。</p>
</li>
<li><p>ServiceLoader 因为是通过反射进行加载的，所有的接口实现类必须拥有一个无参构造函数，否则实现类无法被反射实例化。</p>
</li>
</ul>
<h1 id="Spring和ServiceLoader"><a href="#Spring和ServiceLoader" class="headerlink" title="Spring和ServiceLoader"></a>Spring和ServiceLoader</h1><p>Spring 的 <code>getBeansOfType()</code> 方法和 JDK 的 <code>ServiceLoader</code> 都可以实现类似的功能，那么在项目中应该优先使用哪个呢？</p>
<p>如果项目中使用了 Spring 框架，项目中的接口实现都已被 Spring 核心容器管理，那么建议优先使用 Spring 的 <code>getBeansOfType()</code> 方法，因为所有实现类被 Spring 核心容器管理的情况下，使用 <code>getBeansOfType()</code> 方法可以达到一种“伪动态”加载的效果，而且代码更具有扩展性。</p>
<p>如果项目只是一个普通的项目，那么可以使用 <code>ServiceLoader</code> 来进行接口实现类的加载。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置虚拟路径映射访问磁盘中的文件</title>
    <url>/2020/02/24/java/SpringBoot%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84%E8%AE%BF%E9%97%AE%E7%A3%81%E7%9B%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>在我们使用SpringBoot搭建项目的时候，我们可能会把一些项目的文件放在其他服务器或者硬盘中，这样可以更好的存储和管理系统的文件。<br>但是如果放在其他服务器或者硬盘中，那么我们应该如何通过项目的路径来访问这些文件呢？</p>
<span id="more"></span>
<p>很简单，我们直接在SpringBoot中配置一个虚拟路径，将硬盘的路径映射到项目路径下，这样就可以通过项目路径来访问硬盘中的资源了。</p>
<ul>
<li>项目环境请参考博文<a href="https://blog.csdn.net/qq_45193304/article/details/104443373">SpringBoot+MyBatis+通用Mapper</a>。</li>
</ul>
<p><strong>第一步</strong>：我们在G:\temp\images目录下，放置一个图片资源。<br><img src="/images/2020/02/20200224233637858.png" alt="在这里插入图片描述"></p>
<p><strong>第二步</strong>：我们在application.yml文件中配置虚拟路径的映射。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">resources:</span></span><br><span class="line">    	<span class="attr">static-locations:</span> <span class="string">file:G:\temp\images</span>   <span class="comment">#访问系统外部资源，将该目录下的文件映射到系统下</span></span><br><span class="line">    <span class="attr">mvc:</span>			</span><br><span class="line">   		<span class="attr">static-path-pattern:</span> <span class="string">/**</span>		<span class="comment">#如果你没有配置这个属性，也可以选择不配置，因为该属性的默认值就是/**</span></span><br></pre></td></tr></table></figure>
<p><strong>第三步</strong>：我们启动项目，直接通过http请求访问资源。<br><img src="/images/2020/02/202002242343056.png" alt="在这里插入图片描述"></p>
<p>我们可以在浏览器上，通过<a href="http://localhost:8080/79830b68-3936-4953-adcd-3bf39d4cb1941582526908297.jpg请求路径访问G:\temp\images下的图片资源。">http://localhost:8080/79830b68-3936-4953-adcd-3bf39d4cb1941582526908297.jpg请求路径访问G:\temp\images下的图片资源。</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger报错：Unable to interpret the implicit parameter configuration with dataType</title>
    <url>/2021/01/10/java/Swagger%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>在项目中使用了Swagger作为项目接口API说明文档，但是在启动项目的时候，启动日志中报了一个警告信息，虽然最终并不影响项目功能的使用，但是却依旧让人看得不舒服。</p>
<span id="more"></span>
<p>项目在启动的时候报错：</p>
<blockquote>
<p>Unable to interpret the implicit parameter configuration with dataType: , dataTypeClass: class java.lang.Void。</p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>无法使用dataType：，dataTypeClass：class java.lang.Void解释隐式参数配置</p>
</blockquote>
<p>这是因为Swagger中的注解<code>@ApiImplicitParam</code>有一个属性为dataTypeClass，该属性的默认值为Void.class，因为没有指定dataTypeClass属性的值，所以报该警告信息。</p>
<p><strong>解决方法：</strong></p>
<p>在<code>@ApiImplicitParam</code>注解上加上dataTypeClass属性的值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">        @ApiImplicitParam(name = &quot;username&quot;, value = &quot;用户名&quot;, dataTypeClass = String.class, required = true)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/15/java/hello-world/</url>
    <content><![CDATA[<p>欢迎来到我的博客！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【小剧场】Java注解：斩颜良诛文丑，插标卖首尔</title>
    <url>/2021/08/03/java/%E3%80%90%E5%B0%8F%E5%89%A7%E5%9C%BA%E3%80%91Java%E6%B3%A8%E8%A7%A3%EF%BC%9A%E6%96%A9%E9%A2%9C%E8%89%AF%E8%AF%9B%E6%96%87%E4%B8%91%EF%BC%8C%E6%8F%92%E6%A0%87%E5%8D%96%E9%A6%96%E5%B0%94/</url>
    <content><![CDATA[<blockquote>
<p>关公举目一望，谓操曰：”吾观颜良，如插标卖首耳！”</p>
</blockquote>
<span id="more"></span>
<p>Java 注解并不是程序，只是 Java 程序中的一个标识，Java 程序可以通过这个标识进行一些判断，执行不同的计算和流程。</p>
<p>在 <code>三国演义</code>中，关公说颜良是插标卖首，这个所谓的 <code>标</code> 其实和 Java 中的注解有异曲同工之意，都是在人或者代码的头上标注一个东西。</p>
<p>现在，我们就用 Java 注解的功能模拟一下关公斩颜良诛文丑的过程吧。</p>
<h2 id="人"><a href="#人" class="headerlink" title="人"></a>人</h2><p>首先，先创建一个 Person 类，该类代表了所有人，这个类的实例对象，可能是关公，也可能是颜良文丑，也可能只是一个普通的小兵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已死亡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">die</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否死亡</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否死亡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.die;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被杀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beKilled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.die = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 杀人</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person 被杀的人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">killed</span><span class="params">(Person... persons)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            <span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">                person.beKilled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="标（注解）"><a href="#标（注解）" class="headerlink" title="标（注解）"></a>标（注解）</h2><p>其次，应该创建一个 Java 注解，这个注解也就是关公所谓的 <code>标</code> ，可以在这个标上添加姓名属性，这样就可以通过这个 <code>标</code> 找到对应的角色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;- <span class="doctag">@Target</span>(ElementType.FIELD) 该注解只允许在类属性上标注&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;- <span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME) 该注解保留到运行时&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;- <span class="doctag">@Inherited</span> 该注解会被子类继承&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;- <span class="doctag">@Documented</span> 该类会被 javadoc 生成的文档显示出来&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Name &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;小兵&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="战场"><a href="#战场" class="headerlink" title="战场"></a>战场</h2><p>既然一切准备就绪，那就可以布置战场了，创建一个战争 Java 类表示战场。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关公举目一望，谓操曰：&quot;吾观颜良，如插标卖首耳！&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">War</span> &#123;</span><br><span class="line">	<span class="comment">// 战场中的角色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="type">War</span> <span class="variable">war</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">War</span>();</span><br><span class="line">        war.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 战争开始了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        Person 关羽 = findPerson(<span class="string">&quot;关羽&quot;</span>);</span><br><span class="line">        Person 颜良 = findPerson(<span class="string">&quot;颜良&quot;</span>);</span><br><span class="line">        Person 文丑 = findPerson(<span class="string">&quot;文丑&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        checkStatus();</span><br><span class="line">        <span class="keyword">if</span> (关羽 != <span class="literal">null</span>) &#123;</span><br><span class="line">            关羽.killed(颜良, 文丑);</span><br><span class="line">            checkStatus();</span><br><span class="line">            System.out.println(<span class="string">&quot;关羽&quot;</span> + (颜良 == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;斩颜良&quot;</span>) + (文丑 == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;诛文丑&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过姓名找到注解标识了姓名的对应角色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 姓名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注解标识了姓名的对应角色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">findPerson</span><span class="params">(String name)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        Field[] fields = War.class.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Name.class)) &#123;</span><br><span class="line">                <span class="type">Name</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Name.class);</span><br><span class="line">                <span class="keyword">if</span> (annotation.value().equals(name)) &#123;</span><br><span class="line">                    System.out.print(name + <span class="string">&quot;在战场上\t&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> (Person) field.get(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(name + <span class="string">&quot;不在在战场上\t&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查当前战场上使用注解标注了姓名的角色的生死</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkStatus</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        Field[] fields = War.class.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Name.class)) &#123;</span><br><span class="line">                <span class="type">Name</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Name.class);</span><br><span class="line">                <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) field.get(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (person.isDie()) &#123;</span><br><span class="line">                    System.out.print(annotation.value() + <span class="string">&quot;死了\t&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(annotation.value() + <span class="string">&quot;活着\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="开战"><a href="#开战" class="headerlink" title="开战"></a>开战</h2><h3 id="战争开始"><a href="#战争开始" class="headerlink" title="战争开始"></a>战争开始</h3><p>模拟战争开始，直接先执行 <code>main</code> 方法。</p>
<p>战争结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关羽不在在战场上	颜良不在在战场上	文丑不在在战场上	</span><br></pre></td></tr></table></figure>



<h3 id="颜良进入战场"><a href="#颜良进入战场" class="headerlink" title="颜良进入战场"></a>颜良进入战场</h3><p>在 <code>War</code> 类的某个 Person 类型的属性上，注解上 <code>@Name(&quot;颜良&quot;)</code>注解，标注姓名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Name(&quot;颜良&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>战争结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关羽不在在战场上	颜良在战场上	文丑不在在战场上	</span><br><span class="line">颜良活着	</span><br></pre></td></tr></table></figure>



<h3 id="关羽进入战场"><a href="#关羽进入战场" class="headerlink" title="关羽进入战场"></a>关羽进入战场</h3><p>在 <code>War</code> 类的某个 Person 类型的属性上，注解上 <code>@Name(&quot;关羽&quot;)</code>注解，标注姓名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Name(&quot;关羽&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>战争结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关羽在战场上	颜良在战场上	文丑不在在战场上	</span><br><span class="line">颜良活着	关羽活着	</span><br><span class="line">颜良死了	关羽活着	</span><br><span class="line">关羽斩颜良</span><br></pre></td></tr></table></figure>



<h3 id="文丑进入战场"><a href="#文丑进入战场" class="headerlink" title="文丑进入战场"></a>文丑进入战场</h3><p>在 <code>War</code> 类的某个 Person 类型的属性上，注解上 <code>@Name(&quot;文丑&quot;)</code>注解，标注姓名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Name(&quot;文丑&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Person</span> <span class="variable">person5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>战争结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关羽在战场上	颜良在战场上	文丑在战场上	</span><br><span class="line">颜良活着	文丑活着	关羽活着	</span><br><span class="line">颜良死了	文丑死了	关羽活着	</span><br><span class="line">关羽斩颜良诛文丑</span><br></pre></td></tr></table></figure>



<h2 id="战争结束"><a href="#战争结束" class="headerlink" title="战争结束"></a>战争结束</h2><blockquote>
<p>关公纵马上山，众将尽皆称贺。公献首级于操前。操曰：“将军真神人也！”</p>
</blockquote>
<p>在这段 Java 程序中，Java 代码始终没有任何改变，仅仅只是添加了一些注解，最后的运行结果就完全不一样。这就是 Java 注解的功能，虽然本身不是程序代码的一部分，但是却是代码的标识，可以在程序运行的时候，通过这个标识进行一些判断，执行不同的计算和流程。</p>
<p>现在的大部分的 Java 框架，都有基于 Java 注解的使用版本，原理都是一样的。</p>
<p>本身就是在框架中对框架自定义的注解进行了一些程序判断和处理，使用者只需要在一些代码上标识一些注解，程序就可以按照框架的处理逻辑对这些代码进行处理。</p>
<p>Spring、MyBatis、Hibernate 等框架尽皆如此。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇博客教会你写序列化工具</title>
    <url>/2023/02/18/java/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%95%99%E4%BC%9A%E4%BD%A0%E5%86%99%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>总所周知，在Java语言中，所有的数据都是以对象的形式存在Java堆中。</p>
<p>但是Java对象如果要存储在别的地方，那么单纯的Java对象就无法满足了，必须要将Java对象转为一种可以存储的格式，这个转换的过程就是序列化。</p>
<p>同理而言，将一种存储的格式转换为Java对象的过程，就是反序列化。</p>
<span id="more"></span>

<h2 id="序列化格式"><a href="#序列化格式" class="headerlink" title="序列化格式"></a>序列化格式</h2><p>序列化是一种通用的称呼，对于序列化之后转成的数据格式并没有硬性的要求，但是一般都会将格式定为字节数组，或者字符串之类通用的数据格式。</p>
<p>例如在Java中存在这样一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String username, String password, <span class="type">float</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get、set、toString等方法省略……</span></span><br></pre></td></tr></table></figure>

<p>使用JDK自带的序列化工具，可以将这样一个Java对象转为字节数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;次时代小羊&quot;</span>, <span class="string">&quot;222222&quot;</span>, <span class="number">99.44F</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">oos.writeObject(user);</span><br><span class="line"><span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">System.out.println(<span class="string">&quot;length:&quot;</span> + bytes.length);</span><br><span class="line">System.out.println(<span class="string">&quot;bytes:&quot;</span> + Arrays.toString(bytes));</span><br></pre></td></tr></table></figure>

<p>Java对象序列化后得到的字节数组可以写入数据库，或者文件系统中，以后如果需要使用这个Java对象，可以从数据库或者文件中将字节数组读取出来，重新反序列化为Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">System.out.println(<span class="string">&quot;object:&quot;</span> + object);</span><br></pre></td></tr></table></figure>

<p>但是JDK自带的序列化工具虽然可以将Java对象转换为字节数组，但是这个字节数组是完全按照Java的格式来序列化的，反序列化也需要使用JDK的工具才行。</p>
<p>所以这种序列化方式只能在Java语言中通用。</p>
<p>（虽然理论上别的语言平台也可以按照JDK反序列化的方式实现这个工具，但是别人可不会惯着你！）</p>
<p>即便是在Java平台内部，这种序列化方式也非常笨重，因为在这个序列化得到的字节数组中序列化了非常多的与用户数据无关的对象数据。</p>
<p>例如上述的<code>user</code>对象中，用户真正关心的数据只有四个，分别是<code>id</code>、<code>username</code>、<code>password</code>、<code>money</code>，至于Java对象内部是一些数据，并不是用户真正关心的。</p>
<p>这个时候，我们就追求一种简洁明了，而且跨平台通用的序列化格式。</p>
<h2 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h2><p>在Java的早起，XML作为一种可扩展标记语言，因为它的平台无关性、可扩展性、数据遵循严格的格式，人类可读等优点，得到了Java开发者的青睐。</p>
<p>早期XML在Java中大行其道，很多Java对象最终都会被序列化为XML文本存储或者转发。</p>
<p>因为其具有平台无关性，很多语言平台或第三方库也纷纷实现了XML的标准。</p>
<p>不过伴随着JSON格式的数据的崛起，JSON很快就取代了XML的地位，XML具有的优点JSON都具有，而且比XML更加简洁，文本更小。</p>
<p>使用第三方类库Jackson，将一个Java对象序列化为字符串或者字节数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;次时代小羊&quot;</span>, <span class="string">&quot;222222&quot;</span>, <span class="number">99.44F</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">byte</span>[] bytes1 = objectMapper.writeValueAsBytes(user);</span><br><span class="line">System.out.println(<span class="string">&quot;length:&quot;</span> + bytes1.length);</span><br><span class="line">System.out.println(<span class="string">&quot;bytes:&quot;</span> + Arrays.toString(bytes1));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">System.out.println(<span class="string">&quot;length:&quot;</span> + json.length());</span><br><span class="line">System.out.println(<span class="string">&quot;json:&quot;</span> + json);</span><br></pre></td></tr></table></figure>

<p>Jackson序列化得到的字符串或者字节数组，同样可以存储到数据库，或者通过网络转发出去，并被支持JSON格式的语言平台解析。</p>
<blockquote>
<p>Jackson序列化为字符串和字节数组本质上并没有区别，序列化为字节数组，其实就是将序列化得到的字符串转为字节数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> objectMapper.readValue(bytes1, User.class);</span><br><span class="line">System.out.println(<span class="string">&quot;user1:&quot;</span> + user1);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> objectMapper.readValue(json, User.class);</span><br><span class="line">System.out.println(<span class="string">&quot;user2:&quot;</span> + user2);</span><br></pre></td></tr></table></figure>

<p>JSON序列化是目前一种比较理想的序列化方式，各种语言平台，甚至是数据库都对JSON格式的数据有支持。</p>
<h2 id="精简序列化数据"><a href="#精简序列化数据" class="headerlink" title="精简序列化数据"></a>精简序列化数据</h2><p>我们先来看一下使用Jackson序列化得到的字符串和字节数组数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;次时代小羊&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;222222&quot;</span><span class="punctuation">,</span><span class="attr">&quot;money&quot;</span><span class="punctuation">:</span><span class="number">99.44</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <td>123</td>
        <td>34</td>
        <td>105</td>
        <td>100</td>
        <td>34</td>
        <td>58</td>
        <td>49</td>
        <td>44</td>
        <td>34</td>
        <td>117</td>
    </tr>
    <tr>
        <td>{</td>
        <td>"</td>
        <td>i</td>
        <td>d</td>
        <td>"</td>
        <td>:</td>
        <td>1</td>
        <td>,</td>
        <td>"</td>
        <td>u</td>
    </tr>
    <tr>
        <td>115</td>
        <td>101</td>
        <td>114</td>
        <td>110</td>
        <td>97</td>
        <td>109</td>
        <td>101</td>
        <td>34</td>
        <td>58</td>
        <td>34</td>
    </tr>
    <tr>
        <td>s</td>
        <td>e</td>
        <td>r</td>
        <td>n</td>
        <td>a</td>
        <td>m</td>
        <td>e</td>
        <td>"</td>
        <td>:</td>
        <td>"</td>
    </tr>
    <tr>
        <td>-26</td>
        <td>-84</td>
        <td>-95</td>
        <td>-26</td>
        <td>-105</td>
        <td>-74</td>
        <td>-28</td>
        <td>-69</td>
        <td>-93</td>
        <td>-27</td>
    </tr>
    <tr>
        <td colspan="3">次</td>
        <td colspan="3">时</td>
        <td colspan="3">代</td>
        <td></td>
    </tr>
    <tr>
        <td>-113</td>
        <td>-84</td>
        <td>-25</td>
        <td>-66</td>
        <td>-118</td>
        <td>34</td>
        <td>44</td>
        <td>34</td>
        <td>112</td>
        <td>97</td>
    </tr>
    <tr>
        <td colspan="2">小</td>
        <td colspan="3">羊</td>
        <td>"</td>
        <td>,</td>
        <td>"</td>
        <td>p</td>
        <td>a</td>
    </tr>
    <tr>
        <td>115</td>
        <td>115</td>
        <td>119</td>
        <td>111</td>
        <td>114</td>
        <td>100</td>
        <td>34</td>
        <td>58</td>
        <td>34</td>
        <td>50</td>
    </tr>
    <tr>
        <td>s</td>
        <td>s</td>
        <td>w</td>
        <td>o</td>
        <td>r</td>
        <td>d</td>
        <td>"</td>
        <td>:</td>
        <td>"</td>
        <td>2</td>
    </tr>
    <tr>
        <td>50</td>
        <td>50</td>
        <td>50</td>
        <td>50</td>
        <td>50</td>
        <td>34</td>
        <td>44</td>
        <td>34</td>
        <td>109</td>
        <td>111</td>
    </tr>
    <tr>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>"</td>
        <td>,</td>
        <td>"</td>
        <td>m</td>
        <td>o</td>
    </tr>
    <tr>
        <td>110</td>
        <td>101</td>
        <td>121</td>
        <td>34</td>
        <td>58</td>
        <td>57</td>
        <td>57</td>
        <td>46</td>
        <td>52</td>
        <td>52</td>
    </tr>
    <tr>
        <td>n</td>
        <td>e</td>
        <td>y</td>
        <td>"</td>
        <td>:</td>
        <td>9</td>
        <td>9</td>
        <td>.</td>
        <td>4</td>
        <td>4</td>
    </tr>
    <tr>
        <td>125</td>
    </tr>
    <tr>
        <td>}</td>
    </tr>
</table>


<p>以上就是使用Jackson序列化得到的字符串，以及字节数组和字符串字符的对应表，其中中文字符使用三个字节表示。</p>
<p>按照上面的对照表，我们可以知道序列化为字节数组的时候，JSON格式的字符串都序列化了哪些内容。</p>
<p>而我们前面也说过，用户真正关心的数据只有四个，分别是<code>id</code>、<code>username</code>、<code>password</code>、<code>money</code>，而这四个数据的名称（字段名）对于数据本身而言，只是做一个定位的作用。</p>
<p>如果我们可以预先确定序列化数据的字段顺序，而后反序列化的时候也已同样的顺序进行解析，是否就能够抛弃JSON格式中的字段名称，只将数据本身进行序列化？</p>
<p>比如将JSON格式的字符串缩减成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>次时代小羊<span class="number">22222299.44</span></span><br></pre></td></tr></table></figure>

<p>但是这也有一个问题，那就是我们无法确定每个数据的长度，比如<code>username</code>这个字段，它对应的值到底是<code>次时代小羊</code>，还是<code>次时代小羊222222</code>，甚至可能还是<code>次时代小羊22222299.44</code>？</p>
<p>所以为了确定数据的长度，我们还必须加入数据的长度作为表示，因为数据的长度都可以使用整形类型的数据进行表示。</p>
<p>比如我们可以约定，字符开始的第一个小于等于9的数字为数据长度，我们这样就可以很清晰的定位并分隔数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">115</span>次时代小羊<span class="number">6222222599.44</span></span><br></pre></td></tr></table></figure>

<p>当然，这只是字符串可以这样表示，如果使用字节数组，那么我们可以根据单个数据的最大字节数，约定<code>byte</code>或者<code>int</code>类型的数据来表示长度。</p>
<blockquote>
<p><code>byte</code>支持单个数据的字节数组长度为255（2 ^ 8-1），<code>int</code>支持单个数据的字节数组长度为4294967295（2 ^ 32-1），因为数据长度只可能为正整数，所以使用无符号数可以最大程度支持。</p>
</blockquote>
<p>而且一些特定类型的数据长度我们可以不需要确定，一些语言平台已经规定了这些数据类型的字节长度，比如在Java语言中，<code>int</code>、<code>float</code>类型的数据长度为4，那么我们只需要规定一些不确定的数据的字节长度即可，比如字符串类型，字节数组类型等等。</p>
<p>我们可以重新设计简化格式：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>数据</th>
<th>类型</th>
<th>是否需要确定数据长度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>1</td>
<td>int</td>
<td>语言平台规定，不需要</td>
<td>int类型的数据字节长度为4</td>
</tr>
<tr>
<td>15</td>
<td>次时代小羊</td>
<td>字符串</td>
<td>需要</td>
<td>UTF-8编码下一个中文字节长度为3（或者4）</td>
</tr>
<tr>
<td>6</td>
<td>222222</td>
<td>字符串</td>
<td>需要</td>
<td>UTF-8编码兼容ASCII编码，所以长度为6</td>
</tr>
<tr>
<td>4</td>
<td>99.44</td>
<td>float</td>
<td>语言平台规定，不需要</td>
<td>float类型的数据字节长度为4</td>
</tr>
</tbody></table>
<p>数据总长度为29，加上一共四个数据，每个数据对应的字节数组长度各占一个<code>int</code>类型数据的字节长度，所以最终长度为37（29+4+4）。</p>
<p>最终得到序列化后的字节数组：</p>
<table>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>15</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td colspan="4">1</td>
        <td colspan="4">15</td>
    </tr>
    <tr>
        <td>-26</td>
        <td>-84</td>
        <td>-95</td>
        <td>-26</td>
        <td>-105</td>
        <td>-74</td>
        <td>-28</td>
        <td>-69</td>
    </tr>
    <tr>
        <td colspan="3">次</td>
        <td colspan="3">时</td>
        <td colspan="2">代</td>
    </tr>
    <tr>
        <td>-93</td>
        <td>-27</td>
        <td>-80</td>
        <td>-113</td>
        <td>-25</td>
        <td>-66</td>
        <td>-118</td>
        <td>6</td>
    </tr>
    <tr>
        <td></td>
        <td colspan="3">小</td>
        <td colspan="3">羊</td>
        <td>6</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>50</td>
        <td>50</td>
        <td>50</td>
        <td>50</td>
        <td>50</td>
    </tr>
    <tr>
        <td colspan="3"></td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
        <td>50</td>
        <td>72</td>
        <td>-31</td>
        <td>-58</td>
        <td>66</td>
    </tr>
    <tr>
        <td>2</td>
        <td colspan="4">99.44</td>
    </tr>
</table>

<p>得到序列化后的字节数组之后，反序列化只需要按照原定的顺序，即可正确读取数据。</p>
<p>比如：</p>
<ul>
<li><p>1、读取int类型的字段<code>id</code>数据，得到数据值：1</p>
</li>
<li><p>2、读取字符串类型的字段<code>username</code>数据对应的字节数组长度，得到数据值：15</p>
<ul>
<li>2.1、向后读取长度为15的字节数组，得到数据值：次时代小羊</li>
</ul>
</li>
<li><p>3、读取字符串类型的字段<code>password</code>数据对应的字节数组长度，得到数据值：6</p>
<ul>
<li>3.1、向后读取长度为6的字节数组，得到数据值：222222</li>
</ul>
</li>
<li><p>4、读取float类型的字段<code>money</code>数据，得到数据值：99.44</p>
</li>
</ul>
<p>至此，精简序列化数据的方式都可以正确序列化和反序列化，而且序列化得到的字节数组长度更小。</p>
<p>Google的<code>ProtoBuf</code>和开源的<code>MessagePack</code>其实都是使用了类似的精简序列化的方式，不过这些开源的序列化框架更加成熟可靠，内部的实现细节也更加全面。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上三种序列化方式，各有优点，也各有缺点，我们在这里总结一下：</p>
<table>
<thead>
<tr>
<th>序列化方式</th>
<th>JDK序列化</th>
<th>JSON序列化</th>
<th>精简序列化</th>
</tr>
</thead>
<tbody><tr>
<td>序列化结果</td>
<td>字节数组</td>
<td>字符串或者字节数组</td>
<td>字节数组</td>
</tr>
<tr>
<td>是否支持跨平台</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>是否需要额外约定</td>
<td>不需要</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>人类可读性</td>
<td>差</td>
<td>优秀</td>
<td>差</td>
</tr>
<tr>
<td>优点</td>
<td>JDK自带，无需第三方依赖，对Java语言开发者友好</td>
<td>全平台通用，序列化结果简洁工整，人类可读性强</td>
<td>全平台通用，序列化结果精简</td>
</tr>
<tr>
<td>缺点</td>
<td>只支持JDK平台，序列化结果笨重</td>
<td>一些语言平台不支持JSON格式，需要第三方库</td>
<td>扩展性较差，在需要改动序列化对象的时候，序列化和反序列化方式也需要同时改动</td>
</tr>
</tbody></table>
<p>以上三种序列化方式的优缺点已经一一列名，我们可以根据自身需要进行选择。</p>
<p>如果你进行的是一些通信软件、游戏等等对网络性能要求高，且通信格式并不会发生重大改变的开发工作，那么可以考虑选择第三种精简序列化的方式，开源平台上也有很多这种类型的序列化框架的实现，比如前面提到过的<code>ProtoBuf</code>和<code>MessagePack</code>等等。</p>
<p>如果你进行是一些Web网站等一些扩展性要求较高的开发工作，那么建议选择JSON序列化的方式，即便是一些不支持<code>JSON</code>格式的语言平台，同样有很多优秀的第三方库对其进行了支持，比如<code>Jackson</code>等等。</p>
<p>至于JDK序列化的方式，如果你有兴趣，或者开发的项目本身不支持其他序列化方式，那么也是一个不错的选择<del>~</del></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>在文章的最后，我在这里附上一个本人使用<code>Java</code>写的简单的序列化工具，有兴趣的同学可以参考一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bytes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ONE_LENGTH</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TWO_LENGTH</span> <span class="operator">=</span> ONE_LENGTH &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOUR_LENGTH</span> <span class="operator">=</span> ONE_LENGTH &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EIGHT_LENGTH</span> <span class="operator">=</span> ONE_LENGTH &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">BOOLEAN_TRUE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">BOOLEAN_FALSE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> readIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> writeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bytes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.readIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.writeIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bytes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = bytes;</span><br><span class="line">        <span class="built_in">this</span>.readIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.writeIndex = bytes.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">value</span> <span class="operator">=</span> data[readIndex];</span><br><span class="line">        readIndex += ONE_LENGTH;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">short</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TWO_LENGTH; i++) &#123;</span><br><span class="line">            value = (<span class="type">short</span>) (value | (data[i + readIndex] &amp; <span class="number">0xFF</span>) &lt;&lt; i * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        readIndex += TWO_LENGTH;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; FOUR_LENGTH; i++) &#123;</span><br><span class="line">            value = value | (data[i + readIndex] &amp; <span class="number">0xFF</span>) &lt;&lt; i * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readIndex += FOUR_LENGTH;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; EIGHT_LENGTH; i++) &#123;</span><br><span class="line">            value = value | (data[i + readIndex] &amp; <span class="number">0xFFL</span>) &lt;&lt; i * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readIndex += EIGHT_LENGTH;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">value</span> <span class="operator">=</span> data[readIndex];</span><br><span class="line">        readIndex += ONE_LENGTH;</span><br><span class="line">        <span class="keyword">return</span> value == BOOLEAN_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TWO_LENGTH; i++) &#123;</span><br><span class="line">            value += data[i + readIndex] &lt;&lt; i * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        readIndex += TWO_LENGTH;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> readInt();</span><br><span class="line">        <span class="keyword">return</span> Float.intBitsToFloat(intValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> readLong();</span><br><span class="line">        <span class="keyword">return</span> Double.longBitsToDouble(longValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] readBytes(<span class="type">int</span> length) &#123;</span><br><span class="line">        <span class="type">byte</span>[] tempBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        System.arraycopy(data, readIndex, tempBytes, <span class="number">0</span>, length);</span><br><span class="line">        readIndex += length;</span><br><span class="line">        <span class="keyword">return</span> tempBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeByte</span><span class="params">(<span class="type">byte</span> value)</span> &#123;</span><br><span class="line">        expansion(ONE_LENGTH);</span><br><span class="line">        data[writeIndex] = value;</span><br><span class="line">        writeIndex += ONE_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeShort</span><span class="params">(<span class="type">short</span> value)</span> &#123;</span><br><span class="line">        expansion(TWO_LENGTH);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TWO_LENGTH; i++) &#123;</span><br><span class="line">            data[i + writeIndex] = (<span class="type">byte</span>) (value &gt;&gt; i * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writeIndex += TWO_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        expansion(FOUR_LENGTH);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; FOUR_LENGTH; i++) &#123;</span><br><span class="line">            data[i + writeIndex] = (<span class="type">byte</span>) (value &gt;&gt; i * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writeIndex += FOUR_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLong</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">        expansion(EIGHT_LENGTH);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; EIGHT_LENGTH; i++) &#123;</span><br><span class="line">            data[i + writeIndex] = (<span class="type">byte</span>) (value &gt;&gt; i * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writeIndex += EIGHT_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeBoolean</span><span class="params">(<span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        expansion(ONE_LENGTH);</span><br><span class="line">        data[writeIndex] = value ? BOOLEAN_TRUE : BOOLEAN_FALSE;</span><br><span class="line">        writeIndex += ONE_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeChar</span><span class="params">(<span class="type">char</span> value)</span> &#123;</span><br><span class="line">        expansion(TWO_LENGTH);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TWO_LENGTH; i++) &#123;</span><br><span class="line">            data[i + writeIndex] = (<span class="type">byte</span>) (value &gt;&gt; i * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writeIndex += TWO_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFloat</span><span class="params">(<span class="type">float</span> value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> Float.floatToIntBits(value);</span><br><span class="line">        writeInt(intValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeDouble</span><span class="params">(<span class="type">double</span> value)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> Double.doubleToLongBits(value);</span><br><span class="line">        writeLong(longValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeBytes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        expansion(bytes.length);</span><br><span class="line">        System.arraycopy(bytes, <span class="number">0</span>, data, writeIndex, bytes.length);</span><br><span class="line">        writeIndex += bytes.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expansion</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.data == <span class="literal">null</span>) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] tempBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[data.length + length];</span><br><span class="line">            System.arraycopy(data, <span class="number">0</span>, tempBytes, <span class="number">0</span>, data.length);</span><br><span class="line">            data = tempBytes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再附带上一份序列化的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;次时代小羊&quot;</span>, <span class="string">&quot;222222&quot;</span>, <span class="number">99.44F</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Bytes</span> <span class="variable">bytes3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bytes</span>();</span><br><span class="line">bytes3.writeInt(user.getId());</span><br><span class="line"><span class="type">byte</span>[] usernameByte = user.getUsername().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">bytes3.writeInt(usernameByte.length);</span><br><span class="line">bytes3.writeBytes(usernameByte);</span><br><span class="line"><span class="type">byte</span>[] passwordByte = user.getPassword().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">bytes3.writeInt(passwordByte.length);</span><br><span class="line">bytes3.writeBytes(passwordByte);</span><br><span class="line">bytes3.writeFloat(user.getMoney());</span><br><span class="line">System.out.println(<span class="string">&quot;length:&quot;</span> + bytes3.getData().length);</span><br><span class="line">System.out.println(<span class="string">&quot;bytes:&quot;</span> + Arrays.toString(bytes3.getData()));</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user3.setId(bytes3.readInt());</span><br><span class="line"><span class="type">int</span> <span class="variable">usernameBytesLength</span> <span class="operator">=</span> bytes3.readInt();</span><br><span class="line">user3.setUsername(<span class="keyword">new</span> <span class="title class_">String</span>(bytes3.readBytes(usernameBytesLength)));</span><br><span class="line"><span class="type">int</span> <span class="variable">passwordBytesLength</span> <span class="operator">=</span> bytes3.readInt();</span><br><span class="line">user3.setPassword(<span class="keyword">new</span> <span class="title class_">String</span>(bytes3.readBytes(passwordBytesLength)));</span><br><span class="line">user3.setMoney(bytes3.readFloat());</span><br><span class="line">System.out.println(<span class="string">&quot;user3:&quot;</span> + user3);</span><br></pre></td></tr></table></figure>

<p>最后的最后，瑞思拜<del>~</del></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>上班聊天，摸鱼神器，手写一款即时通讯工具（附源码！！！）</title>
    <url>/2021/08/07/java/%E4%B8%8A%E7%8F%AD%E8%81%8A%E5%A4%A9%EF%BC%8C%E6%91%B8%E9%B1%BC%E7%A5%9E%E5%99%A8%EF%BC%8C%E6%89%8B%E5%86%99%E4%B8%80%E6%AC%BE%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%B7%A5%E5%85%B7%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>认真工作不叫做赚钱，那叫做用劳动换取报酬，上班摸鱼才是真的赚钱。</p>
</blockquote>
<span id="more"></span>

<p><img src="/images/2023/02/100002.gif" alt="img"></p>
<h1 id="即时通讯工具"><a href="#即时通讯工具" class="headerlink" title="即时通讯工具"></a>即时通讯工具</h1><p>如果上班有空闲时间，最喜欢做的事情自然是和熟悉的朋友一起聊聊天，互相吐槽工作中遇到的人和事，缓解工作的压力。</p>
<p>如果直接在桌面上打开 QQ 或者微信，那目标无疑是巨大的，QQ 和微信的桌面客户端明晃晃地占据整个电脑桌面，只要有同事或者领导从你身边经过，或是在你后面看一眼，就立刻能够知道你在上班摸鱼，那场面不亚于公开处刑…… (＠_＠)</p>
<blockquote>
<p>领导：看来工作还是不饱和啊 ┑(￣Д ￣)┍</p>
</blockquote>
<p>针对这种情况，技术人自然不甘落后，总是可以想出各种方法躲避同事和领导发现你在上班摸鱼 ≡ω≡</p>
<p>思量再三，最终还是放弃了 IDEA 的各种插件，转而决定还是自己手写一款简易的即时通信工具。</p>
<p>既然要自己动手，那自然也要先对这款即时通讯工具做个简单的规划。</p>
<ul>
<li>这款即时通讯工具分为客户端和服务端的，每个用户可以使用客户端进行即时通讯。</li>
<li>通讯工具尽可能简单，只依赖于 JDK，即完全使用 Java 网络编程功能实现，不依赖其他的第三方库。</li>
<li>通讯工具不需要桌面，使用 Java 自带的 Scanner 控制台输入即可。</li>
</ul>
<p>这样一款基于 Java 网络编程的即时通讯工具，只要在 IDEA 运行客户端代码，即可在控制台与其他朋友快乐地聊天。只要不是同事或者领导贴着你的电脑屏幕观看，他绝对想不到你是在使用 IDEA 上班摸鱼聊天。</p>
<p><img src="/images/2023/02/100001.jpg" alt="img"></p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>客户端是给使用这款即时通讯工具的用户使用的，从安全和用户体验的角度上来说，客户端应该尽可能精简，只负责发送和接受数据即可。</p>
<p>因为这是一款即时通讯工具，客户端需要做的有两件事：</p>
<ul>
<li>监听客户端的输入和发送。</li>
<li>监听服务端发送过来的消息。</li>
</ul>
<p>因为我们使用 JDK 自带的 Scanner 类来进行客户端的输入，而这个输入是一个阻塞的操作，所以我们需要创建一条额外的线程来进行服务端的监听工作。</p>
<p>客户端需要两条用户线程：</p>
<ul>
<li>main 线程用来监听客户端的输入和发送。</li>
<li>另外创建一条线程用来监听服务端的消息发送。</li>
</ul>
<p>思路已经设计好了，可以使用代码来实现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天室客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-09 12:00:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">12345</span>)) &#123;</span><br><span class="line">            <span class="comment">// 读取服务端发的消息</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; readMsg(socket)).start();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您的聊天室昵称：&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">chat</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">                os.write(chat.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;【系统消息】聊天室炸了，BUG之神降临了&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMsg</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;【系统消息】你已退出聊天室，开始认真工作吧&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>服务端的设计比客户端要困难很多，为了便于开发和理解，我直接使用了 Java 阻塞式的网络 IO 来进行实现，即每一个客户端连接都创建一个线程来进行处理。</p>
<p>这种阻塞式的网络 IO 的<strong>好处</strong>在于便于理解和开发，而<strong>缺点</strong>也非常明显，因为这是一个通讯工具，即每一个链接都是长链接。</p>
<p>即每个客户端用户链接服务端后，都会在服务端专门有一个线程处理这个客户端相关的网络 IO 操作。如果用户量少的情况下还比较好，但是用户一旦多了起来，服务端将会创建 N 多个线程，而且在客户端不主动断开的情况下，服务器这些线程会一直占用服务器资源，服务器将会消费非常大的资源，而且很容易崩溃。</p>
<blockquote>
<p>基于这种情况，我后面也实现了一个 Java NIO 版本的客户端和服务端，在文章末尾也会一起附上源码。</p>
</blockquote>
<p><img src="/images/2023/02/100003.jpg" alt="img"></p>
<p>我将服务端的操作分为两个步骤：</p>
<h2 id="1、链接"><a href="#1、链接" class="headerlink" title="1、链接"></a>1、链接</h2><p>服务端阻塞地等待客户端的链接请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天室服务端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-09 12:00:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 启动参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 抛出IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; start(server)).start();</span><br><span class="line">        <span class="comment">// 加载配置</span></span><br><span class="line">        CHAT_CFG_RELOAD_PASSWORD = UUID.randomUUID().toString();</span><br><span class="line">        logInfo(<span class="string">&quot;【系统消息】聊天室配置加载密钥：&quot;</span> + CHAT_CFG_RELOAD_PASSWORD);</span><br><span class="line">        reloadChatCfg(args.length == <span class="number">1</span> ? args[<span class="number">0</span>] : <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        logInfo(<span class="string">&quot;【系统消息】聊天室启动成功了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务开始方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server 服务对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(ServerSocket server)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 链接操作</span></span><br><span class="line">                <span class="type">ChatSocket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> connection(server);</span><br><span class="line">                <span class="comment">// 登录操作</span></span><br><span class="line">                login(chatSocket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logInfo(<span class="string">&quot;【系统消息】聊天室发生了异常……&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            logInfo(<span class="string">&quot;【系统消息】正在关闭聊天室资源……&quot;</span>);</span><br><span class="line">            close(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server 服务对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ChatSocket 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChatSocket <span class="title function_">connection</span><span class="params">(ServerSocket server)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">ChatSocket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatSocket</span>(socket);</span><br><span class="line">        userDB.add(chatSocket);</span><br><span class="line">        sendMsgToUser(socket, <span class="string">&quot;============================\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;1、本聊天室仅为娱乐，请勿在该聊天室内谈论敏感内容，比如涉政，涉黄，账号密码等等！\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;2、聊天室内容明文传输，聊天信息泄露本聊天室概不负责！\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;3、本聊天室内容后台不做任何存储，聊天信息如果需要请自行保留！\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;4、最终解释权归本聊天室所有！\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chatSocket;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存所有用户socket的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;ChatSocket&gt; userDB = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、登录"><a href="#2、登录" class="headerlink" title="2、登录"></a>2、登录</h2><p>服务端获取到客户端请求后，将 <code>Socket</code> 包装为我们自定义的 <code>ChatSocket</code>，便于我们进行登录操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chatSocket ChatSocket 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(ChatSocket chatSocket)</span> &#123;</span><br><span class="line">    <span class="comment">// 给每个用户一个线程处理</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> chatSocket.getSocket();</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> readMsg(is, bytes);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                logout(chatSocket);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            username = <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len);</span><br><span class="line">            chatSocket.setUsername(username);</span><br><span class="line">            <span class="comment">// 刷新配置</span></span><br><span class="line">            <span class="keyword">if</span> (CHAT_CFG_RELOAD_PASSWORD.equals(username)) &#123;</span><br><span class="line">                reloadChatCfg(is, bytes, socket);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            loginTip(username, socket);</span><br><span class="line">            <span class="comment">// 机器人欢迎</span></span><br><span class="line">            robotWelcome(username);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                len = readMsg(is, bytes);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    logout(chatSocket);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len);</span><br><span class="line">                sendMsgToOtherUser(username, socket, msg);</span><br><span class="line">                <span class="comment">// 机器人回复消息</span></span><br><span class="line">                randomRobotReply(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logout(chatSocket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                remove(socket);</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、其他方法"><a href="#3、其他方法" class="headerlink" title="3、其他方法"></a>3、其他方法</h2><h3 id="3-1、读取客户端的消息"><a href="#3-1、读取客户端的消息" class="headerlink" title="3.1、读取客户端的消息"></a>3.1、读取客户端的消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取消息的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> is    输入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes 字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 读取的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(InputStream is, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        len = is.read(bytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2、给客户端发送消息"><a href="#3-2、给客户端发送消息" class="headerlink" title="3.2、给客户端发送消息"></a>3.2、给客户端发送消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给所有的用户发送系统消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg 系统消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendSysMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (ChatSocket chatSocket : userDB) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sysMsg</span> <span class="operator">=</span> getCurrentTime() + <span class="string">&quot;\n&quot;</span> + msg + <span class="string">&quot;\n&quot;</span> + chatSeparate;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> chatSocket.getSocket();</span><br><span class="line">        sendMsgToUser(socket, sysMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息给其他用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username 消息发送用户名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> self     消息发送的用户socket</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg      消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMsgToOtherUser</span><span class="params">(String username, Socket self, String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (ChatSocket chatSocket : userDB) &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> chatSocket.getSocket();</span><br><span class="line">        <span class="keyword">if</span> (socket.equals(self)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sendMsg</span> <span class="operator">=</span> <span class="string">&quot;（&quot;</span> + username + <span class="string">&quot;） &quot;</span> + getCurrentTime() + <span class="string">&quot;\n&quot;</span> + msg + <span class="string">&quot;\n&quot;</span> + chatSeparate;</span><br><span class="line">        sendMsgToUser(socket, sendMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给指定的用户发送消息，文本消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socket  消息发送的用户socket</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sendMsg 消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMsgToUser</span><span class="params">(Socket socket, String sendMsg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(sendMsg.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-3、日志记录"><a href="#3-3、日志记录" class="headerlink" title="3.3、日志记录"></a>3.3、日志记录</h3><p>虽然服务端不需要记录用户的聊天信息，但是还是需要记录一些服务器的日志信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 日志信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">logInfo</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    System.out.println(getCurrentDateTime() + <span class="string">&quot; &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4、工具集合"><a href="#3-4、工具集合" class="headerlink" title="3.4、工具集合"></a>3.4、工具集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前在线的所有玩家名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前在线的所有玩家名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getLoginUsernames</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userDB.stream().map(ChatSocket::getUsername).filter(Objects::nonNull).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断时间是否是 11:00 - 04:59 晚上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">    <span class="keyword">return</span> hour &gt;= <span class="number">23</span> || hour &lt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间格式化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">timeSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">DateTimeSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前的时间的格式化字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前的时间的格式化字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> String <span class="title function_">getCurrentTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> timeSdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前的日期时间的格式化字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前的日期时间的格式化字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> String <span class="title function_">getCurrentDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DateTimeSdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个字符串是否为空</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 为空返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> string == <span class="literal">null</span> || string.length() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个字符串是否不为空</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 不为空返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNotEmpty</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !isEmpty(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5、ChatSocket"><a href="#3-5、ChatSocket" class="headerlink" title="3.5、ChatSocket"></a>3.5、ChatSocket</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装的 ChatSocket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChatSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatSocket</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Socket <span class="title function_">getSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h1><p>为了方便在服务器上运行服务端代码，我还特意写了一个 <code>Shell</code> 脚本用来处理服务端代码的运行、停止、重启、查找等操作。</p>
<p><img src="/images/2023/02/100005.gif" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CHAT_SERVER_DIR=/usr/app/chat</span><br><span class="line">CHAT_SERVER=ChatServer</span><br><span class="line">CHAT_LOG_FILE=$&#123;CHAT_SERVER_DIR&#125;/chat.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">聊天室启动参数</span></span><br><span class="line">CHAT_CFG=$&#123;2&#125;</span><br><span class="line"></span><br><span class="line">help() &#123;</span><br><span class="line">	echo &quot;==================&quot;</span><br><span class="line">	echo &quot;start 启动服务&quot;</span><br><span class="line">	echo &quot;stop 停止服务&quot;</span><br><span class="line">	echo &quot;restart 重启服务&quot;</span><br><span class="line">	echo &quot;find 查找服务&quot;</span><br><span class="line">	echo &quot;help 帮助&quot;</span><br><span class="line">	echo &quot;==================&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">	javac -encoding UTF-8 $&#123;CHAT_SERVER&#125;\.java</span><br><span class="line">	nohup java -Dfile.encoding=UTF-8 $&#123;CHAT_SERVER&#125; $&#123;CHAT_CFG&#125; &gt;&gt;$&#123;CHAT_LOG_FILE&#125; 2&gt;&amp;1 &amp;</span><br><span class="line">	echo &quot;服务$&#123;CHAT_SERVER&#125;已启动&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">	PID=$(ps -ef | grep java | grep ChatServer | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">	if [ &quot;$&#123;PID&#125;&quot; == &quot;&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;服务$&#123;CHAT_SERVER&#125;已停止&quot;</span><br><span class="line">	else</span><br><span class="line">		kill $&#123;PID&#125;</span><br><span class="line">		echo &quot;服务$&#123;CHAT_SERVER&#125;已停止&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart() &#123;</span><br><span class="line">  stop</span><br><span class="line">	sleep 3</span><br><span class="line">	start</span><br><span class="line">	echo &quot;服务$&#123;CHAT_SERVER&#125;已重启&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find() &#123;</span><br><span class="line">  PID=$(ps -ef | grep java | grep ChatServer | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">  if [ &quot;$&#123;PID&#125;&quot; == &quot;&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;服务$&#123;CHAT_SERVER&#125;已停止&quot;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;服务$&#123;CHAT_SERVER&#125;正在运行：PID=$&#123;PID&#125;&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case $&#123;1&#125; in</span><br><span class="line">	&quot;&quot;)</span><br><span class="line">		echo &quot;=== 参数错误 ===&quot;</span><br><span class="line">		;;</span><br><span class="line">	start)</span><br><span class="line">		start</span><br><span class="line">		;;</span><br><span class="line">	stop)</span><br><span class="line">		stop</span><br><span class="line">		;;</span><br><span class="line">	restart)</span><br><span class="line">		restart</span><br><span class="line">		;;</span><br><span class="line">	find)</span><br><span class="line">		find</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		help</span><br><span class="line">		;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>



<h1 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h1><p><strong>优点</strong></p>
<ul>
<li>简单便捷，无论是客户端还是服务端，都只依赖了 JDK 的环境，没有任何第三方依赖，客户端的代码只在复制到有 JDK 环境的电脑上即可运行，方便快捷。</li>
<li>足够隐蔽，客户端在 CMD 或者 IDEA 环境下都可以运行，这样你身边的同事只要不仔细观察你的电脑屏幕，绝对想不到你是在和朋友聊天，只以为你是在认真工作。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>服务端基于阻塞式网络 IO 开发，服务端只能够承受有限个的客户端链接。（Java NIO 版本可以解决这个缺点）</li>
<li>太过简陋，因为只是单纯地进行网络 IO 的写入和读取，所以对于一些复杂的网络环境问题都没有进行处理，比如网络黏包的问题，在客户端连接较多的情况下，可能会发生网络黏包的问题，导致一些消息粘黏在一起，发送给客户端。</li>
<li>需要一个服务器，因为这款即使通讯工具是 CS 模式，需要一个服务器运行服务端代码。</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>虽然这款即时通讯工具确实还不够完善，但是如果只是用于几个朋友之间简单地进行聊天，这款即时通讯工具还是非常给力的。</p>
<p>这款即时通讯工具的源代码已经被托管到了 GitHub 上，同时还附带了这款即时通讯工具的 Java NIO 版本，有兴趣的同学的可以访问我的 GitHub 下载源码。</p>
<blockquote>
<p>GitHub：<a href="https://github.com/herenpeng/chat.git">https://github.com/herenpeng/chat.git</a></p>
</blockquote>
<p>同时，我还在 Gitee 上提供了仓库镜像。</p>
<blockquote>
<p>Gitee：<a href="https://gitee.com/herenpeng/chat.git">https://gitee.com/herenpeng/chat.git</a></p>
</blockquote>
<p>如果你喜欢这款即时通讯工具，希望各位同学可以给我的 GitHub 或者 Gitee 仓库点一个 <code>Star</code>，非常感谢！</p>
<p><img src="/images/2023/02/100004.gif" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码开发，手写一款代码生成工具</title>
    <url>/2021/08/11/java/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%8C%E6%89%8B%E5%86%99%E4%B8%80%E6%AC%BE%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>低代码平台的一个核心就是，使用可视化的操作，生成项目系统中的非核心代码，从而大大降低了重复代码的编写工作，使开发者们可以更加专注于核心代码和业务功能的设计和开发工作。</p>
</blockquote>
<span id="more"></span>

<h1 id="低代码平台"><a href="#低代码平台" class="headerlink" title="低代码平台"></a>低代码平台</h1><p>低代码平台有很多，强大的低代码平台基本上可以通过可视化操作来编写简单的业务逻辑，而一些简单的低代码平台主要是用来生成一些通用的 CRUD 操作，我们今天要写的就是一款比较简单的低代码平台，主要生成一些通用的后端 CRUD 操作，当然，也可以生成一些简单的前端数据管理页面等等。</p>
<p>低代码平台的主要思路是，以数据库表结构为基础，获取数据库表的结构信息，从而生成后端对应的领域模型以及 CRUD 操作。</p>
<p>本篇博客中，所有的功能都是基于 SpringBoot 的，所以在最开始，我们需要引入 SpringBoot 相关的依赖，数据库使用 MySQL，数据库操作使用 MyBatisPlus，所以在阅读本篇博客之前，我希望阅读的朋友对于这些相关的知识已经有所了解。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringMVC的启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--MySQL数据库驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--MyBatis-Plus的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>其实低代码平台的本质就是一个模板操作，将数据库表的结构信息填入对应的模板中，即可根据模板内容生成对应的模板页面。</p>
<p>说到模板生成，其实 JSP 技术本质上就是一种模板，JavaEE 服务器将数据信息填入 JSP 模板中，从而生成对应的 HTML 静态页面，然后响应给前端。</p>
<p>当然，目前的 Java 技术生态圈中，JSP 是一种比较老旧的技术了，学习和使用价值都不算太高，所以今天的低代码平台并不使用 JSP 技术来作为通用模板，而是使用 FreeMarker 模板引擎作为模板工具。</p>
<h2 id="FreeMarker模板"><a href="#FreeMarker模板" class="headerlink" title="FreeMarker模板"></a>FreeMarker模板</h2><p>既然要使用 FreeMarker 模板引擎作为模板工具，自然需要对 FreeMarker 技术有所了解。</p>
<p>我们来看一下 FreeMarker 中文官方参考手册的描述：</p>
<blockquote>
<p>FreeMarker 是一款 <em>模板引擎</em>： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p>
</blockquote>
<p>简而言之，FreeMarker 就是一款类似于 JSP 的模板工具，但是比起 JSP 来，FreeMarker 效率更高，使用更加方便简单。</p>
<p>如果需要使用 FreeMarker 技术，SpringBoot 中已经为我们集成了 FreeMarker 模板引擎，我们在已经引入 SpringBoot 的前提下，只需要再引入 FreeMarker 的依赖即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>可以先简单封装一下 FreeMarker 模板引擎的模板生成功能，使得我们可以在后面更加简便地使用 FreeMarker 模板引擎。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreeMarkerUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板渲染并返回内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object             模板参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateLoaderPath FreeMarker模板文件加载路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ftlFileName        FreeMarker模板文件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> FreeMarker模板内容内容字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTemplateContent</span><span class="params">(<span class="keyword">final</span> Object object, <span class="keyword">final</span> String templateLoaderPath, <span class="keyword">final</span> String ftlFileName)</span> &#123;</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Configuration</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);</span><br><span class="line">            cfg.setClassForTemplateLoading(FreeMarkerUtils.class, templateLoaderPath);</span><br><span class="line">            cfg.setDefaultEncoding(EncodingEnums.UTF_8.getValue());</span><br><span class="line">            <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> cfg.getTemplate(ftlFileName);</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">            template.process(object, out);</span><br><span class="line">            <span class="keyword">return</span> out.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">&quot;[freemarker工具类]FreeMarker读取模板文件异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    log.error(<span class="string">&quot;[freemarker工具类]FreeMarker读取模板文件输出流关闭异常&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据库表结构信息"><a href="#数据库表结构信息" class="headerlink" title="数据库表结构信息"></a>数据库表结构信息</h2><p>表结构信息是低代码平台的基础信息，其他的信息都是从表结构信息延伸出来的。</p>
<p>在获取表结构信息上，需要解决几个问题。</p>
<ul>
<li>怎么获取数据库源对应的表信息。</li>
<li>怎么获取数据库表对应的字段信息。</li>
</ul>
<p>其实数据库的表结构信息，也是存储在数据库表中的。这些信息存储在 MySQL 数据库默认的数据库 <code>information_schema</code> 中，我们可以使用 SQL 语句查询出当前使用的数据库的所有表信息。</p>
<p><img src="/images/2023/02/200001.png" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name <span class="keyword">as</span> name,table_comment <span class="keyword">as</span> comment</span><br><span class="line"><span class="keyword">from</span> information_schema.tables</span><br><span class="line"><span class="keyword">where</span> table_schema <span class="operator">=</span> (<span class="keyword">select</span> database())</span><br></pre></td></tr></table></figure>

<ul>
<li>查询结果</li>
</ul>
<table>
<thead>
<tr>
<th>name</th>
<th>comment</th>
</tr>
</thead>
<tbody><tr>
<td>数据库表名称</td>
<td>数据库表注释信息</td>
</tr>
</tbody></table>
<p>同理，我们也可以用同样的方式获取数据库表字段的具体信息。</p>
<p><img src="/images/2023/02/200002.png" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">as</span> name, ordinal_position <span class="keyword">as</span> sort,</span><br><span class="line">column_comment <span class="keyword">as</span> comment, data_type <span class="keyword">as</span> database_type</span><br><span class="line"><span class="keyword">from</span> information_schema.columns</span><br><span class="line"><span class="keyword">where</span> table_schema <span class="operator">=</span> (<span class="keyword">select</span> database())</span><br><span class="line"><span class="keyword">AND</span> table_name <span class="operator">=</span> <span class="string">&#x27;auth_role&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ordinal_position;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询结果</li>
</ul>
<table>
<thead>
<tr>
<th>name</th>
<th>sort</th>
<th>comment</th>
<th>database_type</th>
</tr>
</thead>
<tbody><tr>
<td>表字段名称</td>
<td>表字段排序</td>
<td>表字段注释信息</td>
<td>表字段数据库类型</td>
</tr>
</tbody></table>
<h2 id="命名风格转换"><a href="#命名风格转换" class="headerlink" title="命名风格转换"></a>命名风格转换</h2><p>在 Java 代码中，我们一般会使用遵循 Java 代码规范的驼峰命名法，而在数据库中，则使用下划线命名法，即各个词语之间使用下划线隔开。驼峰命名法和下划线命名法都是遵循一定规范的命名方式，两者之间的命名风格可以相互转换。</p>
<p>如果数据库的命名和 Java 代码的命名都遵循一定的规范，那么可以使用命名风格转换工具，将数据库的名称信息自动转换为 Java 代码风格的名称。</p>
<p>当然，如果命名确实不具备相同的规范，无法自动转换，也可以考虑使用在可视化编程界面，由低代码平台的使用者自己对命名名称进行手动修正。</p>
<ul>
<li>命名风格转换工具</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命名风格转换工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-15 15:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CamelCaseUtils</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下划线分隔符 Underscore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">UNDERSCORE_SEPARATOR</span> <span class="operator">=</span> <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下划线命名，转换为小驼峰命名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 下划线命名名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 小驼峰命名名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toCamelCase</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(string)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string = string.toLowerCase();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(string.length());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">upperCase</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> string.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == UNDERSCORE_SEPARATOR) &#123;</span><br><span class="line">                upperCase = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (upperCase) &#123;</span><br><span class="line">                sb.append(Character.toUpperCase(ch));</span><br><span class="line">                upperCase = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>从数据库中只能获取数据库表字段的数据类型，而在 Java 代码中，我们使用的是 Java 数据类型，在 MyBatisPlus 中，我们一般还会使用 jdbcType，为了能够把数据库类型转换为 Java 类型和 jdbcType，需要我们在后台对这三者直接的关系进行映射，从而实现数据库类型转换为 Java 类型和 jdbcType 类型。</p>
<ul>
<li>数据库类型映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据类型常量，能够通过数据库类型映射为JDBC类型和JAVA类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-12 23:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataBaseTypeConst</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; jdbcTypeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; javaTypeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        initJdbcTypeMap();</span><br><span class="line">        initJavaTypeMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据库类型和Jdbc类型的映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initJdbcTypeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;int&quot;</span>, <span class="string">&quot;INTEGER&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;bigint&quot;</span>, <span class="string">&quot;BIGINT&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;char&quot;</span>, <span class="string">&quot;CHAR&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;varchar&quot;</span>, <span class="string">&quot;VARCHAR&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;datetime&quot;</span>, <span class="string">&quot;TIMESTAMP&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;TIMESTAMP&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;date&quot;</span>, <span class="string">&quot;DATE&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;time&quot;</span>, <span class="string">&quot;TIME&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;tinyint&quot;</span>, <span class="string">&quot;BOOLEAN&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;decimal&quot;</span>, <span class="string">&quot;DECIMAL&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;numeric&quot;</span>, <span class="string">&quot;NUMERIC&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;float&quot;</span>, <span class="string">&quot;FLOAT&quot;</span>);</span><br><span class="line">        jdbcTypeMap.put(<span class="string">&quot;double&quot;</span>, <span class="string">&quot;DOUBLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据库类型和Java类型的映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initJavaTypeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;bigint&quot;</span>, <span class="string">&quot;Long&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;char&quot;</span>, <span class="string">&quot;String&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;varchar&quot;</span>, <span class="string">&quot;String&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;datetime&quot;</span>, <span class="string">&quot;Date&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;Date&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;date&quot;</span>, <span class="string">&quot;Date&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;time&quot;</span>, <span class="string">&quot;Date&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;tinyint&quot;</span>, <span class="string">&quot;Boolean&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;decimal&quot;</span>, <span class="string">&quot;BigDecimal&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;numeric&quot;</span>, <span class="string">&quot;BigDecimal&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;float&quot;</span>, <span class="string">&quot;Double&quot;</span>);</span><br><span class="line">        javaTypeMap.put(<span class="string">&quot;double&quot;</span>, <span class="string">&quot;Double&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库类型对应的JDBC类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databaseType 数据库类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JDBC类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getJdbcType</span><span class="params">(String databaseType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTypeMap.get(databaseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库类型对应的Java类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databaseType 数据库类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Java类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getJavaType</span><span class="params">(String databaseType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> javaTypeMap.get(databaseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>代码生成需要两部分数据：</p>
<ul>
<li>第一部分是代码模板，代码模板是固定的代码，在后台以 FreeMarker 的形式存在后台中。</li>
<li>第二部分是代码模板参数，代码模板参数是可变的，在代码生成中，代码模板参数就是数据库表信息和数据库字段信息，以及由数据库延伸出来的 Java 名称信息。</li>
</ul>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>代码模板由 FreeMarker 技术开发，例如实体类的代码模板，名称是 <code>entity.ftlh</code>，模板内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> $&#123;javaPackageName&#125;.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.annotation.Excel;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.SqlCondition;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> com.zero.common.base.entity.BaseEntity;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">&lt;#<span class="type">assign</span> <span class="variable">HasBigDecimal</span> <span class="operator">=</span> <span class="literal">true</span>&gt;</span><br><span class="line">&lt;#<span class="type">assign</span> <span class="variable">HasDate</span> <span class="operator">=</span> <span class="literal">true</span>&gt;</span><br><span class="line">&lt;#list tableColumnList as column&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> column.javaType == <span class="string">&quot;BigDecimal&quot;</span> &amp;&amp; HasBigDecimal&gt;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line">    &lt;#<span class="type">assign</span> <span class="variable">HasBigDecimal</span> <span class="operator">=</span> <span class="literal">false</span>&gt;</span><br><span class="line">    &lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> column.javaType == <span class="string">&quot;Date&quot;</span> &amp;&amp; HasDate &amp;&amp; column.name != <span class="string">&quot;create_time&quot;</span> &amp;&amp; column.name != <span class="string">&quot;update_time&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">    &lt;#<span class="type">assign</span> <span class="variable">HasDate</span> <span class="operator">=</span> <span class="literal">false</span>&gt;</span><br><span class="line">    &lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $&#123;comment&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $&#123;codeAuthor&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $&#123;.now?string(&quot;yyyy-MM-dd HH:mm&quot;)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;$&#123;comment&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>&#123;entityName&#125; <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">&lt;#list tableColumnList as column&gt;</span><br><span class="line">&lt;#<span class="keyword">if</span> column.name != <span class="string">&quot;id&quot;</span> &amp;&amp; column.name != <span class="string">&quot;create_time&quot;</span> &amp;&amp; column.name != <span class="string">&quot;create_user_id&quot;</span> &amp;&amp; column.name != <span class="string">&quot;update_time&quot;</span> &amp;&amp; column.name != <span class="string">&quot;update_user_id&quot;</span> &amp;&amp; column.name != <span class="string">&quot;deleted&quot;</span>&gt;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * $&#123;column.comment&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;$&#123;column.comment&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Excel(name = &quot;$&#123;column.comment&#125;&quot;, width = 15, needMerge = true)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;$&#123;column.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> $&#123;column.javaType&#125; $&#123;column.javaName&#125;;</span><br><span class="line">&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码模板参数"><a href="#代码模板参数" class="headerlink" title="代码模板参数"></a>代码模板参数</h3><p>代码模板参数都是由数据库相关的信息延伸出来的，主要分为数据库表信息和数据库表字段信息。</p>
<ul>
<li>TableInfo</li>
</ul>
<blockquote>
<p>这里的 TableInfo 有一部分信息是和前端 vue 相关的，如果有不需要可以根据自己的需求进行代码改造。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统数据库表信息实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-08 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(&quot;dev_table_info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableInfo</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;comment&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String comment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表名对应的实体类名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;entity_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String entityName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表名对应的实体类Controller请求路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;request_mapping&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String requestMapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java包前缀名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;java_package_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String javaPackageName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java代码生成路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;java_code_path&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String javaCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Vue代码生成路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;vue_code_path&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String vueCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Vue包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;vue_package&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String vuePackage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码作者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;code_author&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String codeAuthor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库表的字段信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;TableColumn&gt; tableColumnList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>TableColumn</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统数据库表字段信息实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-11 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(&quot;dev_table_column&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableColumn</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库表字段名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java属性名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;java_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String javaName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库表字段注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;comment&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String comment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库表字段类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;database_type&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String databaseType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库表字段对应的JDBC类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;jdbc_type&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库表字段对应的JAVA类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;java_type&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String javaType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为查询字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;query&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库表字段排序顺序，数据库默认升序排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;sort&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表信息主键，关联dev_table_info表的主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;table_info_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer tableInfoId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板类型枚举"><a href="#模板类型枚举" class="headerlink" title="模板类型枚举"></a>模板类型枚举</h3><p>为了能够区分不同的模板，以及不同模板之前的一些固定参数，我们可以写一些枚举类型，对这些不同模板的固定参数进行定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码类型，后续可以添加一些其他类型的代码，比如 VUE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-29 20:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CodeTypeEnum</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    JAVA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FreeMarker模板文件相关枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-15 13:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TemplateEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实体类相关信息枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ENTITY(CodeTypeEnum.JAVA,</span><br><span class="line">            <span class="string">&quot;/templates/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;entity.ftlh&quot;</span>,</span><br><span class="line">            <span class="string">&quot;/src/main/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.entity&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.java&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mapper层接口相关信息枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MAPPER(CodeTypeEnum.JAVA,</span><br><span class="line">            <span class="string">&quot;/templates/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mapper.ftlh&quot;</span>,</span><br><span class="line">            <span class="string">&quot;/src/main/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.mapper&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Mapper&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.java&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mapper层XML文件相关信息枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MAPPER_XML(CodeTypeEnum.JAVA,</span><br><span class="line">            <span class="string">&quot;/templates/resources&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mapperXml.ftlh&quot;</span>,</span><br><span class="line">            <span class="string">&quot;/src/main/resources&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.mapper&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Mapper&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.xml&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service层接口相关信息枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SERVICE(CodeTypeEnum.JAVA,</span><br><span class="line">            <span class="string">&quot;/templates/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;service.ftlh&quot;</span>,</span><br><span class="line">            <span class="string">&quot;/src/main/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.service&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Service&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.java&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service层接口实现类相关信息枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SERVICE_IMPL(CodeTypeEnum.JAVA,</span><br><span class="line">            <span class="string">&quot;/templates/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;serviceImpl.ftlh&quot;</span>,</span><br><span class="line">            <span class="string">&quot;/src/main/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.service.impl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ServiceImpl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.java&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Controller层相关信息枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CONTROLLER(CodeTypeEnum.JAVA,</span><br><span class="line">            <span class="string">&quot;/templates/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;controller.ftlh&quot;</span>,</span><br><span class="line">            <span class="string">&quot;/src/main/java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.controller&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Controller&quot;</span>,</span><br><span class="line">            <span class="string">&quot;.java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CodeTypeEnum codeTypeEnum;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板文件加载路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String templateLoaderPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FreeMarker模板文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ftlTemplateFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件基本生成路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileBasePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String packageName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件后缀名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileSuffix;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>拥有代码模板和代码模板参数之后，就可以使用之前写的 FreeMarkerUtils 直接生成代码，不过为了方便使用，我们可以再一次包装一个 CodeGenerationUtils 工具类。后续我们只需要调用 CodeGenerationUtils  工具类的 <code>generation</code> 方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码生成工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> herenpeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-11-11 22:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerationUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TableInfoMapper tableInfoMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TableColumnMapper tableColumnMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FreeMarkerUtils freeMarkerUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码生成方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 表信息主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generation</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> tableInfoMapper.selectById(id);</span><br><span class="line">        List&lt;TableColumn&gt; tableColumnList = tableColumnMapper.getByTableInfoId(tableInfo.getId());</span><br><span class="line">        tableInfo.setTableColumnList(tableColumnList);</span><br><span class="line">        generationFile(tableInfo, TemplateEnum.ENTITY);</span><br><span class="line">        generationFile(tableInfo, TemplateEnum.MAPPER);</span><br><span class="line">        generationFile(tableInfo, TemplateEnum.SERVICE);</span><br><span class="line">        generationFile(tableInfo, TemplateEnum.SERVICE_IMPL);</span><br><span class="line">        generationFile(tableInfo, TemplateEnum.CONTROLLER);</span><br><span class="line">        generationFile(tableInfo, TemplateEnum.MAPPER_XML);</span><br><span class="line">        <span class="comment">// 生成前端代码</span></span><br><span class="line">        generationFile(tableInfo, TemplateEnum.VUE);</span><br><span class="line">        generationFile(tableInfo, TemplateEnum.API);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过模板文件生成对应的文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableInfo    表信息，需要在模板文件中渲染的内容信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateEnum 需要生成的文件类型枚举，其中含有对应的生成信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">generationFile</span><span class="params">(TableInfo tableInfo, TemplateEnum templateEnum)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 拼接文件的全路径</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">generationFilePath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">CodeTypeEnum</span> <span class="variable">codeTypeEnum</span> <span class="operator">=</span> templateEnum.getCodeTypeEnum();</span><br><span class="line">        <span class="keyword">switch</span> (codeTypeEnum) &#123;</span><br><span class="line">            <span class="keyword">case</span> JAVA:</span><br><span class="line">                <span class="comment">// 拼接文件的全路径</span></span><br><span class="line">                generationFilePath.append(tableInfo.getJavaCodePath()).append(templateEnum.getFileBasePath())</span><br><span class="line">                        .append(packageNameToPath(tableInfo.getJavaPackageName() + templateEnum.getPackageName()))</span><br><span class="line">                        .append(File.separator).append(tableInfo.getEntityName()).append(templateEnum.getSuffix())</span><br><span class="line">                        .append(templateEnum.getFileSuffix());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                log.error(<span class="string">&quot;[代码生成工具]系统当前不支持&#123;&#125;类型的代码生成功能&quot;</span>, codeTypeEnum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> freeMarkerUtils.getTemplateContent(tableInfo, templateEnum.getTemplateLoaderPath(), templateEnum.getFtlTemplateFile());</span><br><span class="line">        <span class="type">File</span> <span class="variable">generationFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(generationFilePath.toString());</span><br><span class="line">        generationFile.getParentFile().mkdirs();</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(generationFile), EncodingEnums.UTF_8.getValue());</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(out);</span><br><span class="line">        writer.write(content);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将包名转换为文件路径名，并在包文件路径的前后拼接上文件路径分隔符号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName 包名转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件路径名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">packageNameToPath</span><span class="params">(String packageName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> File.separator + packageName.replace(StringConst.POINT, File.separator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="可视化效果"><a href="#可视化效果" class="headerlink" title="可视化效果"></a>可视化效果</h2><ul>
<li>代码生成</li>
</ul>
<p><img src="/images/2023/02/200003.png" alt="img"></p>
<ul>
<li>表信息配置</li>
</ul>
<p><img src="/images/2023/02/200004.png" alt="img"></p>
<ul>
<li>表字段配置</li>
</ul>
<p><img src="/images/2023/02/200005.png" alt="img"></p>
<h1 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h1><p><strong>优点</strong></p>
<ul>
<li>使用便捷，开发者可以使用这款低代码工具生成简单重复的代码。</li>
<li>代码简单，开发者可以根据自己的需求，对这款低代码工具进行定制化的修改。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>功能单一，相比较其他成熟的低代码平台，这款低代码工具的功能还是比较单一的，无法承担比较复杂的业务场景。</li>
<li>不支持多表关联，这款低代码工具目前只支持单表代码生成。</li>
</ul>
<blockquote>
<p>有兴趣的小伙伴可以基于这个的基础上，对这款低代码工具进行扩展和升级，增加更多复杂，更加强大的功能。</p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这款低代码平台能够生成简单的 Java 和前端代码，对于基础的增删改查可以直接生成，开发者只需要在这个基础上进行一些简单的修改，这些代码就可以立即生效，从而大大节省开发者的时间，让开发者从无意义的重复代码中解放出来。</p>
<p>这款低代码工具其实是我的开源项目 <code>zero-admin</code> 下的一个子模块 <code>zero-dev</code> ，这款低代码工具的所有的源码都在该模块中，有兴趣的可以前往我的 GitHub 进行相关的了解。</p>
<blockquote>
<p>GitHub：<a href="https://github.com/herenpeng/zero-admin.git">https://github.com/herenpeng/zero-admin.git</a></p>
</blockquote>
<p>同时，我还在 Gitee 上提供了仓库镜像。</p>
<blockquote>
<p>Gitee：<a href="https://gitee.com/herenpeng/zero-admin.git">https://gitee.com/herenpeng/zero-admin.git</a></p>
</blockquote>
<p>如果你喜欢这款低代码工具，希望各位同学可以给我的 GitHub 或者 Gitee 仓库点一个 <code>Star</code>，非常感谢！</p>
<p><img src="/images/2023/02/200004.gif" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>守护线程和用户线程</title>
    <url>/2020/03/17/java/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>Java是一门多线程的语言，其中Java的线程中有守护线程的概念，其中最为常见的守护线程就是<code>GC线程</code>。</p>
</blockquote>
<span id="more"></span>
<h2 id="什么是守护线程"><a href="#什么是守护线程" class="headerlink" title="什么是守护线程"></a>什么是守护线程</h2><p>守护线程其实也是一个线程，不过它和普通的用户线程的区别在于，如果JVM中只存在守护线程正在运行，那么JVM不会等待守护线程运行完毕，直接会结束程序的运行。</p>
<h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><table>
<thead>
<tr>
<th>守护线程</th>
<th>用户线程</th>
</tr>
</thead>
<tbody><tr>
<td>JVM不会等待守护线程执行完毕</td>
<td>JVM会等待用户线程执行完毕</td>
</tr>
<tr>
<td>在守护线程里面创建的线程也是一个守护线程</td>
<td>在用户线程里面创建的线程是一个用户线程</td>
</tr>
<tr>
<td>守护线程依赖于用户线程的存在，如果用户线程全部退出，那么守护线程也会退出</td>
<td>用户线程不依赖于其他用户线程，用户线程的退出不会影响其他用户线程执行，同样其他用户线程退出也不会影响用户线程执行</td>
</tr>
</tbody></table>
<h2 id="创建守护线程"><a href="#创建守护线程" class="headerlink" title="创建守护线程"></a>创建守护线程</h2><p>在Java中创建的线程默认都是用户线程，如果需要把一个线程设置为守护线程，那么需要调用该线程的<code>public final void setDaemon(boolean on)</code>方法，参数传入<code>true</code>则为守护线程，默认为<code>false</code>，为用户线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程&quot;</span>));</span><br><span class="line">thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadTest</span> &#123;	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;		</span><br><span class="line">			<span class="keyword">try</span> &#123;		</span><br><span class="line">				System.out.println(<span class="string">&quot;用户线程正在运行……&quot;</span>);</span><br><span class="line">				Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;守护线程创建的线程同样也是一个守护线程……&quot;</span>);</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;守护线程正在守护……&quot;</span>);</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);	</span><br><span class="line">		daemonThread.setDaemon(<span class="literal">true</span>);		</span><br><span class="line">		daemonThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码执行结果为：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用户线程正在运行……</span><br><span class="line">守护线程正在守护……</span><br><span class="line">守护线程创建的线程同样也是一个守护线程……</span><br><span class="line">守护线程创建的线程同样也是一个守护线程……</span><br><span class="line">守护线程正在守护……</span><br><span class="line">守护线程创建的线程同样也是一个守护线程……</span><br><span class="line">守护线程正在守护……</span><br><span class="line">守护线程创建的线程同样也是一个守护线程……</span><br><span class="line">守护线程正在守护……</span><br><span class="line">守护线程创建的线程同样也是一个守护线程……</span><br><span class="line">守护线程正在守护……</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/03/10/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>我们可以通过这篇博客来学习 Linux 的常用命令。</p>
<span id="more"></span>

<h2 id="显示文件"><a href="#显示文件" class="headerlink" title="显示文件"></a>显示文件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>显示当前目录下的文件</td>
</tr>
<tr>
<td>ls –a</td>
<td>显示所有文件或目录（包括隐藏文件）</td>
</tr>
<tr>
<td>ls –l</td>
<td>缩写为ll，显示当前目录下文件的详细内容</td>
</tr>
</tbody></table>
<h2 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cd [路径]</td>
<td>进入或返回到该目录，可以使用tab键来补全目录的路径</td>
</tr>
<tr>
<td>cd . .</td>
<td>退回上一级目录</td>
</tr>
<tr>
<td>cd /</td>
<td>返回到根目录</td>
</tr>
<tr>
<td>cd ~</td>
<td>返回到root目录</td>
</tr>
<tr>
<td>cd -</td>
<td>返回到上一次所在的目录</td>
</tr>
<tr>
<td>pwd</td>
<td>显示当前所在目录的路径</td>
</tr>
</tbody></table>
<h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mkdir [文件夹名]</td>
<td>在当前目录下创建指定文件夹（只能创建一级目录，即空文件夹）</td>
</tr>
<tr>
<td>rmdir [文件夹名]</td>
<td>在当前目录下删除指定文件夹（只能删除空文件夹）</td>
</tr>
<tr>
<td>mkdir –help</td>
<td>查看mkdir命令的帮助</td>
</tr>
<tr>
<td>mkdir –p [文件夹/子文件夹]</td>
<td>可以创建多级目录，如果没有父目录，会帮你创建父目录，有父目录，也不会报错</td>
</tr>
</tbody></table>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><strong>文件的权限表示：</strong> - — — —</p>
<p>第一个位置表示文件类型。 </p>
<ul>
<li>-代表文件</li>
<li>d代表目录</li>
<li>l表示连接</li>
</ul>
<p>第二个位置表示当前用户所具有的文件的权限。<br>第三个位置表示组内其他用户具有的该文件的权限。<br>第四个位置表示其他组的用户具有该文件的权限。</p>
<ul>
<li>r：read读</li>
<li>w：write写</li>
<li>x：excute执行</li>
</ul>
<p><strong>变更文件或目录的权限</strong></p>
<ul>
<li>chmod u=rwx,g=rwx,o=rwx [文件或文件夹名]</li>
<li>chmod 777 [文件或文件夹名]（r=4,w=2,x=1）</li>
</ul>
<p><strong>创建文件</strong></p>
<ul>
<li>touch [文件名]：创建一个空文件</li>
</ul>
<h2 id="浏览文件"><a href="#浏览文件" class="headerlink" title="浏览文件"></a>浏览文件</h2><p>cat [文件名]：浏览文件的所有内容</p>
<p>more [文件名]：一屏幕一屏幕浏览文件内容</p>
<ul>
<li>按回车键一行一行浏览</li>
<li>按空格键一屏幕一屏幕浏览</li>
<li>按q退出浏览</li>
<li>ctrl+c也可以退出</li>
</ul>
<p>Less [文件名]：和more命令类似</p>
<ul>
<li>按回车键一行一行浏览</li>
<li>按空格键一屏幕一屏幕浏览</li>
<li>可以使用上下键进行滚动浏览</li>
<li>按q退出浏览</li>
<li>ctrl+c也可以退出</li>
</ul>
<p>tail -10 [文件名]：直接浏览文件最后10行</p>
<p>tail –f [文件名]：可以动态查看内容</p>
<h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h2><p><strong>vim命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>vim [文件名]</td>
<td>进入指定文件的编辑界面</td>
</tr>
</tbody></table>
<ul>
<li>vim 不仅可以编辑已存在的文件，不存在的文件只要正常编辑并保存退出，会自动创建</li>
</ul>
<p><strong>Linux文件的三种模式</strong></p>
<p>命令模式：切换到命令行模式：按Esc键</p>
<p>插入模式：切换到插入模式：按i、o、a键</p>
<ul>
<li>i在当前位置前插入</li>
<li>a在当前位置后插入</li>
<li>A在当前行尾插入</li>
<li>o在当前行之后插入一行</li>
<li>O在当前行之前插入一行</li>
</ul>
<p>底行模式：切换到底行模式：shitf+:</p>
<ul>
<li>底行模式下的wq（:wq）保存并退出</li>
<li>底行模式下的q!（:q!）退出不保存</li>
<li>底行模式下的/[字符串]（: /[字符串]）查找文件中的指定字符串</li>
</ul>
<p><strong>cat命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cat [文件1] &gt; [文件2]</td>
<td>将文件1的内容映射到文件2中去,如果文件2中已有内容，会覆盖文件2中的内容</td>
</tr>
<tr>
<td>cat [文件1] &gt;&gt; [文件2]</td>
<td>内容不会覆盖，直接追加</td>
</tr>
</tbody></table>
<h2 id="文件的拷贝和剪切"><a href="#文件的拷贝和剪切" class="headerlink" title="文件的拷贝和剪切"></a>文件的拷贝和剪切</h2><p><strong>拷贝</strong><br>| 命令 | 描述 |<br>|–|–|<br>|cp [文件名] [目录] | 将文件拷贝到目录下 |<br>|cp [文件名] [目录/文件名]  |  将文件拷贝到目录下，并修改文件名 |</p>
<p><strong>剪切</strong><br>| 命令 | 描述 |<br>|–|–|<br>|  mv [文件名] [目录]  |  将文件剪切到目录下|<br>|  mv [文件名] [目录/文件名]  |  将文件剪切到目录下，并修改文件名 |</p>
<h2 id="删除文件或文件夹"><a href="#删除文件或文件夹" class="headerlink" title="删除文件或文件夹"></a>删除文件或文件夹</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>rm [文件名]</td>
<td>删除当前目录下的文件，并发出询问，输入y(yes)确认删除，输入n(no)不删除。不加参数的rm只能删除文件，不能删除文件夹</td>
</tr>
<tr>
<td>rm –r [文件夹]</td>
<td>递归删除文件夹，会发出询问</td>
</tr>
<tr>
<td>rm –f [文件名]</td>
<td>删除文件，不询问（慎用）</td>
</tr>
<tr>
<td>rm –rf [文件夹]</td>
<td>递归删除文件夹，不询问（慎用）</td>
</tr>
<tr>
<td>rm –rf *</td>
<td>删除所有文件（慎用！！！）</td>
</tr>
<tr>
<td>rm –rf /*</td>
<td><strong>如果在生产环境使用了该命令，尽早跑路吧！</strong></td>
</tr>
</tbody></table>
<p><strong>参数</strong></p>
<ul>
<li>-r：参数r，增强命令，递归删除文件夹</li>
<li>-f：参数f，增强命令，强制删除，不询问</li>
</ul>
<h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>find [目录] -name [文件名]</td>
<td>通过名字查找目录下的指定文件</td>
</tr>
<tr>
<td>grep [字符串] [文件]</td>
<td>在指定文件中显示指定字符串</td>
</tr>
<tr>
<td>grep [字符串] [文件] –color</td>
<td>在指定文件中显示指定字符串，并高亮显示</td>
</tr>
<tr>
<td>grep [字符串] [文件] –color –A4 –B2</td>
<td>在指定文件中显示指定字符串，并高亮显示，显示后4行，前2行</td>
</tr>
</tbody></table>
<h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p><strong>Linux压缩文件</strong></p>
<ul>
<li>Linux的压缩文件后缀名为tar.gz，相关命令使用tar，使用参数增强命令，实现解压缩功能。</li>
</ul>
<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建一个新的tar文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示运行过程的信息</td>
</tr>
<tr>
<td>-f</td>
<td>指定文件名</td>
</tr>
<tr>
<td>-z</td>
<td>调用gzip压缩命令进行压缩</td>
</tr>
<tr>
<td>-x</td>
<td>解开tar文件</td>
</tr>
</tbody></table>
<p><strong>打包压缩</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tar –cvf [文件名.tar] [文件夹或文件]</td>
<td>将文件或文件打包为tar文件</td>
</tr>
<tr>
<td>tar –zcvf [文件名.tar.gz] [文件夹或文件]</td>
<td>将文件夹或文件打包并压缩为tar.gz文件</td>
</tr>
</tbody></table>
<p><strong>解压缩</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tar –xvf [文件名.tar]</td>
<td>将tar文件解开</td>
</tr>
<tr>
<td>tar –zxvf [文件名tar.gz]</td>
<td>将tar.gz文件解压缩到当前目录</td>
</tr>
<tr>
<td>tar –zxvf [文件名tar.gz] –C [文件目录]</td>
<td>将tar.gz文件解压缩到指定目录下</td>
</tr>
</tbody></table>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>ps -a：查看所有</li>
<li>ps -u：以用户的格式显示</li>
<li>ps -x：显示后台进程运行参数</li>
<li>ps -ef：以全格式显示进程所有信息，包括父进程Pid，创建人，创建时间，进程号等等</li>
<li>ps –ef | grep [进程名]：搜索包含指定进程名的进程</li>
<li>kill -9 [进程名称]：强制杀死指定进程名称的进程</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul>
<li>命令1 | 命令2：将命令1的输出（结果）作为命令2的输入（参数）</li>
</ul>
<h2 id="sftp传输"><a href="#sftp传输" class="headerlink" title="sftp传输"></a>sftp传输</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alt+p快捷键</td>
<td>进入sftp传输</td>
</tr>
<tr>
<td>put [文件路径名]</td>
<td>上传至root目录</td>
</tr>
<tr>
<td>get [文件名]</td>
<td>从root目录下载</td>
</tr>
</tbody></table>
<h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hostname</td>
<td>查看主机名配置</td>
</tr>
<tr>
<td>hostname [临时主机名]</td>
<td>将主机名临时修改临时主机名</td>
</tr>
</tbody></table>
<ul>
<li>持久化修改主机名，需要修改/etc/sysconfig/network文件</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ifconfig</td>
<td>显示当前网络ip</td>
</tr>
<tr>
<td>service network restart</td>
<td>重启网络服务</td>
</tr>
<tr>
<td>ifconfig eth0 192.168.12.22</td>
<td>临时修改ip地址为192.168.12.22</td>
</tr>
</tbody></table>
<ul>
<li>持久化修改ip地址，需要修改/etc/sysconfig/network-scripts/ifcfg-eth0文件</li>
</ul>
<h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><p><strong>网络</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>service network status</td>
<td>查看网络服务的状态</td>
</tr>
<tr>
<td>service network stop</td>
<td>停止网络服务</td>
</tr>
<tr>
<td>service network start</td>
<td>启动网络服务</td>
</tr>
<tr>
<td>service network restart</td>
<td>重启网络服务</td>
</tr>
</tbody></table>
<p><strong>防火墙</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>service iptables status</td>
<td>查看防火墙状态</td>
</tr>
<tr>
<td>service iptables stop</td>
<td>关闭防火墙</td>
</tr>
<tr>
<td>service iptables start</td>
<td>启动防火墙</td>
</tr>
<tr>
<td>cservice iptables off</td>
<td>禁止防火墙开机自启</td>
</tr>
</tbody></table>
<p><strong>其他</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>service –-status-all</td>
<td>查看系统中所有后台服务</td>
</tr>
<tr>
<td>service –nltp</td>
<td>查看系统中网络进程的端口监听情况</td>
</tr>
</tbody></table>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>clear</td>
<td>清屏（ctrl+l键也可以显示清屏）</td>
</tr>
</tbody></table>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/images/2020/03/20200310224122937.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境邮件服务报错：Couldn‘t connect to host, port: smtp.qq.com, 25； timeout -1；</title>
    <url>/2021/01/19/linux/Linux%E7%8E%AF%E5%A2%83%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>在Windows环境下邮件服务能够正常使用，但是在Linux环境下，邮件服务报错，无法发送邮件。</p>
<span id="more"></span>
<p>具体报错信息如下：</p>
<blockquote>
<p>com.sun.mail.util.MailConnectException: Couldn’t connect to host, port: smtp.qq.com, 25; timeout -1;</p>
</blockquote>
<p>这个报错的原因是因为阿里云服务器出于安全策略的考虑，主动屏蔽了服务器25端口，导致邮件服务无法正常使用。</p>
<p>解决该报错的方法有两种：</p>
<p><strong>第一：开放25端口。</strong></p>
<blockquote>
<p>阿里云服务25端口的屏蔽策略和普通的安全策略不同，无法通过配置安全组规则的方式来进行开放，如果需要开放25端口，需要向阿里云进行申诉，这是一种比较麻烦的处理方法。</p>
<p>具体的阿里云25端口申诉方法，可以参考：<a href="https://help.aliyun.com/knowledge_detail/56130.html">https://help.aliyun.com/knowledge_detail/56130.html</a></p>
</blockquote>
<p><strong>第二：邮件服务不使用25端口，而是使用465端口。</strong></p>
<blockquote>
<p>具体方法为：进行SpringBoot配置文件配置。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># SpringMail发送邮件相关配置</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="comment"># 发送邮件的账号名</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxxxxxxxxxxx@qq.com</span></span><br><span class="line">    <span class="comment"># 授权码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxxxxxxxx</span></span><br><span class="line">    <span class="comment"># smtp服务主机  qq邮箱的服务主机为smtp.qq.com</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="comment"># 服务协议</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtp</span></span><br><span class="line">    <span class="comment"># 编码集</span></span><br><span class="line">    <span class="attr">default-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="comment"># 服务端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">socketFactory:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">            <span class="attr">class:</span> <span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line">            <span class="attr">fallback:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">required:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统安装JDK环境</title>
    <url>/2020/03/15/linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85JDK%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>我们可以通过这篇博客来学习 Linux 的常用命令。</p>
<span id="more"></span>

<h2 id="Linux版本的JDK下载"><a href="#Linux版本的JDK下载" class="headerlink" title="Linux版本的JDK下载"></a>Linux版本的JDK下载</h2><p>JDK下载官网：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p>
<p><img src="/images/2020/03/20200315230304868.png" alt="在这里插入图片描述"></p>
<p>我们可以直接访问JDK的官方网站，去下载Linux版本对应的JDK安装包。<br>Linux系统直接下载tar.gz的压缩包即可。</p>
<h2 id="Linux环境安装JDK"><a href="#Linux环境安装JDK" class="headerlink" title="Linux环境安装JDK"></a>Linux环境安装JDK</h2><p>alt+p快捷键进入sftp传输方式，使用put命令将JDK上传至Linux的root目录下。</p>
<ul>
<li>Liunx环境下的sftp传输命令可以参考上一篇博客：<a href="/2020/03/10/linux/Linux常用命令/">Linux常用命令</a>的sftp传输。</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> jdk<span class="literal">-8u241-linux-x64</span>.tar.gz /usr/local/</span><br></pre></td></tr></table></figure>
<p>使用mv剪切命令，将root目录下的JDK安装包剪切到<code>/usr/local/</code>目录下。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">tar –zxvf jdk<span class="literal">-8u241-linux-x64</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>使用tar命令，将tar.gz压缩包解压缩在<code>/usr/local/</code>目录下。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">rpm <span class="literal">-qa</span> | grep java</span><br></pre></td></tr></table></figure>
<p>查询安装的jdk的信息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="literal">-rf</span> jdk<span class="literal">-8u241-linux-x64</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>删除JDK的压缩包。</p>
<h2 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>
<p>编辑/etc/下的profile文件。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#set java environment</span></span><br><span class="line">JAVA_HOME=/usr/local/jdk1.<span class="number">8.0</span>_241</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure>
<p>在profile文件中添加上面的配置，保存并退出。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>加载文件，使配置生效。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">java –version</span><br></pre></td></tr></table></figure>
<p>查看JDK版本。</p>
<h2 id="卸载JDK"><a href="#卸载JDK" class="headerlink" title="卸载JDK"></a>卸载JDK</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">rpm <span class="literal">-e</span> <span class="literal">--nodeps</span> jdk1.<span class="number">8.0</span>_241</span><br></pre></td></tr></table></figure>
<p>卸载JDK。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx系统安装JDK环境（yum安装）</title>
    <url>/2020/12/10/linux/Liunx%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85JDK%E7%8E%AF%E5%A2%83%EF%BC%88yum%E5%AE%89%E8%A3%85%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>在之前我曾经写过一篇<a href="/2020/03/15/linux/Linux系统安装JDK环境/">Linux系统安装JDK环境</a>，这篇博客是使用JDK安装包的方式，由自己手动安装并配置JDK的环境变量。<br>而今天使用的是yum来进行JDK自动化安装，卸载。这种方式比起手动安装更加方便，快捷。</p>
</blockquote>
<span id="more"></span>

<h1 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h1><h2 id="1、检查Linux系统是否已经拥有JDK环境。"><a href="#1、检查Linux系统是否已经拥有JDK环境。" class="headerlink" title="1、检查Linux系统是否已经拥有JDK环境。"></a>1、检查Linux系统是否已经拥有JDK环境。</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">rpm <span class="literal">-qa</span> | grep java</span><br><span class="line">yum list installed | grep java</span><br><span class="line">以上两个命令都可以检测Linux系统是否安装有JDK环境，选择其一即可</span><br></pre></td></tr></table></figure>
<h2 id="2、检索JDK"><a href="#2、检索JDK" class="headerlink" title="2、检索JDK"></a>2、检索JDK</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum search java | grep -i --color jdk</span><br></pre></td></tr></table></figure>
<h2 id="3、安装JDK"><a href="#3、安装JDK" class="headerlink" title="3、安装JDK"></a>3、安装JDK</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum install <span class="literal">-y</span> java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span>*</span><br></pre></td></tr></table></figure>

<p>只需要极其简单的三步，JDK环境就已经安装完毕了。<br>我们可以通过<code>java -version</code>命令来查看JDK版本，如果显示JDK版本信息，则说明JDK安装成功。</p>
<p><strong>如图所示：</strong><br><img src="/images/2020/12/20201210214030991.png" alt="在这里插入图片描述"></p>
<h1 id="卸载JDK"><a href="#卸载JDK" class="headerlink" title="卸载JDK"></a>卸载JDK</h1><h2 id="1、卸载JDK"><a href="#1、卸载JDK" class="headerlink" title="1、卸载JDK"></a>1、卸载JDK</h2><p> 如果在安装之前，Linux系统已经有了JDK的环境，但是想要重新安装，则可以使用卸载命令卸载JDK环境。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum <span class="literal">-y</span> remove java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span>*</span><br></pre></td></tr></table></figure>

<h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><h2 id="1、yum安装JDK的路径"><a href="#1、yum安装JDK的路径" class="headerlink" title="1、yum安装JDK的路径"></a>1、yum安装JDK的路径</h2><p>使用yum安装JDK，默认的JDK安装路径在<code>/usr/lib/jvm</code>目录下。</p>
<p><img src="/images/2020/12/20201210215253623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTkzMzA0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell报错syntax error: unexpected end of file</title>
    <url>/2021/01/01/linux/Shell%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>执行shell脚本文件，报错<code>syntax error: unexpected end of file</code>。</p>
<p>使用vim工具打开脚本文件，却并没有发现有什么问题。</p>
<span id="more"></span>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vim hello.sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/2021/01/20210101190743117.png" alt="在这里插入图片描述"></p>
<p>但是只需要使用vim+参数的方式打开该文件，就会发现一些端倪。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vim <span class="literal">-b</span> hello.sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/2021/01/20210101190806488.png" alt="在这里插入图片描述"></p>
<p>在每一个<code>shell</code>语句的末尾，都多了一个<code>^M</code>的标志，这其实是因为该文件是在<code>windows</code>环境下编写，然后传输到<code>Linux</code>环境来的，但是因为<code>windows</code>环境的文本有<code>\r</code>的回车标识，在<code>Linux</code>环境下就会出现不兼容的问题。</p>
<p><strong>解决方法：</strong></p>
<p>1、只需要把<code>^M</code>的标志符删除，该脚本文件即可正常执行。不过这种方法只适用于少量文本，如果是大量的脚本代码，这显然是不适用的。</p>
<p>2、通过命令的方式，将shell文件的格式改为unix。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vim hello.sh</span><br><span class="line">:<span class="built_in">set</span> fileformat=unix</span><br><span class="line">:x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>vim</code>编辑文本的时候，不要使用<code>-b</code>参数，否则是无法将<code>shell</code>文件的文件格式修改为<code>unix</code>的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇博客教会你怎么安装CentOS系统</title>
    <url>/2020/04/19/linux/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%95%99%E4%BC%9A%E4%BD%A0%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85CentOS%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>这篇博客我们来学习怎样通过VMware虚拟机软件来安装CentOS系统。<br>这篇博客是在VMware虚拟机的基础上安装CentOS系统，所以如果不知道怎么安装VMware虚拟机的同学，可以参考我之前的博客：<a href="/2020/04/19/一篇博客教会你怎么安装VMware虚拟机">一篇博客教会你怎么安装VMware虚拟机</a></p>
</blockquote>
<span id="more"></span>

<h1 id="一、下载CentOS系统镜像文件"><a href="#一、下载CentOS系统镜像文件" class="headerlink" title="一、下载CentOS系统镜像文件"></a>一、下载CentOS系统镜像文件</h1><p>CentOS系统的Linux系统比较流行的一个发行版本，CentOS系统是免费，所有人都可以从CentOS系统的官方网站中获取CentOS系统的镜像文件。<br>CentOS下载官网：<a href="http://isoredirect.centos.org/centos/8/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso">http://isoredirect.centos.org/centos/8/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso</a><br>在CentOS的官网中，我们可以看到很多个镜像网站下载地址，我们可以选择国内的镜像来进行下载，这样的话下载速度会非常可观。<br>国内的镜像推荐<code>华为</code>或者<code>阿里云</code>的镜像。<br><img src="/images/2020/04/20200415185900442.png" alt="在这里插入图片描述"></p>
<h1 id="二、在VMware中创建虚拟机"><a href="#二、在VMware中创建虚拟机" class="headerlink" title="二、在VMware中创建虚拟机"></a>二、在VMware中创建虚拟机</h1><p><strong>1、我们<code>以管理员身份运行VMware</code>，打开VMware虚拟机，点击创建新的虚拟机</strong><br><img src="/images/2020/04/20200415190905720.png" alt="在这里插入图片描述"><br><strong>2、开始创建虚拟机</strong><br><img src="/images/2020/04/20200415191542142.png" alt="在这里插入图片描述"><br><strong>3、安装客户机操作系统</strong><br><img src="/images/2020/04/20200415191722271.png" alt="在这里插入图片描述"><br><strong>4、选择客户机操作系统</strong><br><img src="/images/2020/04/20200415191925827.png" alt="在这里插入图片描述"><br><strong>5、命名虚拟机</strong><br><img src="/images/2020/04/20200415193411410.png" alt="在这里插入图片描述"><br><strong>6、指定磁盘容量</strong><br><img src="/images/2020/04/20200415192700707.png" alt="在这里插入图片描述"><br><strong>7、自定义配置</strong><br><img src="/images/2020/04/20200415193812791.png" alt="在这里插入图片描述"><br><strong>8、指定虚拟机内存</strong><br><img src="/images/2020/04/20200415194153507.png" alt="在这里插入图片描述"><br><strong>9、指定ISO映像文件路径</strong><br><img src="/images/2020/04/20200415194547766.png" alt="在这里插入图片描述"><br><strong>10、移除打印机</strong><br><img src="/images/2020/04/20200415194757891.png" alt="在这里插入图片描述"><br><strong>11、点击完成</strong><br><img src="/images/2020/04/20200415194908763.png" alt="在这里插入图片描述"><br><strong>12、虚拟机创建完成</strong><br><img src="/images/2020/04/20200415201407502.png" alt="在这里插入图片描述"></p>
<h1 id="三、安装CentOS系统"><a href="#三、安装CentOS系统" class="headerlink" title="三、安装CentOS系统"></a>三、安装CentOS系统</h1><p><strong>1、我们创建好虚拟机之后，就可以开始安装操作系统了，我们首先开启之前创建的虚拟机</strong><br><img src="/images/2020/04/2020041520181421.png" alt="在这里插入图片描述"><br><strong>2、选择检测安装</strong><br><img src="/images/2020/04/2020041520243732.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415202447999.png" alt="在这里插入图片描述"><br>选择检测安装之后，虚拟机会自动帮我们开始检测，这个过程大概<code>30-60秒</code>左右，等待即可。<br>完成之后出现如下界面：<br><img src="/images/2020/04/20200415202856283.png" alt="在这里插入图片描述"><br><strong>3、选择简体中文</strong><br><img src="/images/2020/04/20200415202958121.png" alt="在这里插入图片描述"><br><strong>4、调整系统时间</strong><br><img src="/images/2020/04/20200415203707220.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415203901353.png" alt="在这里插入图片描述"><br><strong>5、选择服务器类型</strong><br><img src="/images/2020/04/20200415204209197.png" alt="在这里插入图片描述"><br><strong>6、选择系统的安装目的地</strong><br><img src="/images/2020/04/20200415204351669.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415204930116.png" alt="在这里插入图片描述"><br><strong>7、开启虚拟机网络和指定主机名</strong><br><img src="/images/2020/04/20200415204953923.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415205835878.png" alt="在这里插入图片描述"><br><strong>8、开始安装</strong><br><img src="/images/2020/04/20200415210151647.png" alt="在这里插入图片描述"><br><strong>9、设置Root用户密码</strong><br><img src="/images/2020/04/20200415210335244.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415210844650.png" alt="在这里插入图片描述"><br><strong>10、等待安装</strong><br><img src="/images/2020/04/20200415211013781.png" alt="在这里插入图片描述"><br>等待安装需要一小段时间，耐心等待即可。</p>
<p><strong>11、重启系统</strong><br><img src="/images/2020/04/20200415211949410.png" alt="在这里插入图片描述"><br><strong>12、初始设置</strong><br><img src="/images/2020/04/20200415212211287.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415212327812.png" alt="在这里插入图片描述"><br><strong>13、结束配置</strong><br><img src="/images/2020/04/20200415212511711.png" alt="在这里插入图片描述"><br><strong>14、安装成功，欢迎界面</strong><br><img src="/images/2020/04/20200415212923944.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415213112150.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415213157314.png" alt="在这里插入图片描述"><br><strong>15、设置全名和用户名</strong><br><img src="/images/2020/04/20200415213425330.png" alt="在这里插入图片描述"><br><strong>16、设置密码</strong><br><img src="/images/2020/04/20200415213638959.png" alt="在这里插入图片描述"><br><strong>17、一切就绪，开始用吧</strong><br><img src="/images/2020/04/20200415213739774.png" alt="在这里插入图片描述"><br><strong>18、登录系统</strong><br><img src="/images/2020/04/20200415213942326.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415214001655.png" alt="在这里插入图片描述"><br><img src="/images/2020/04/20200415214020269.png" alt="在这里插入图片描述"><br><strong>19、开始使用</strong><br><img src="/images/2020/04/20200415214440688.png" alt="在这里插入图片描述"></p>
<p><strong>历经千难万险，终于把CentOS系统安装成功了，可以开始来上手试试CentOS系统了。</strong></p>
<blockquote>
<p><strong>最后提醒一下，如果不需要使用虚拟机了，不要直接关闭虚拟机，如果直接关闭虚拟机，下一次开机的时候会出现很多的问题，所以我们不要使用虚拟机之后，直接将虚拟机<code>挂起</code>，这样下次需要使用的时候，直接继续运行即可！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇博客教会你怎么安装VMware虚拟机</title>
    <url>/2020/04/19/linux/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%95%99%E4%BC%9A%E4%BD%A0%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85VMware%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<blockquote>
<p>这篇博客我们来学习VMware虚拟机的安装</p>
</blockquote>
<span id="more"></span>

<h1 id="1、下载VMware虚拟机"><a href="#1、下载VMware虚拟机" class="headerlink" title="1、下载VMware虚拟机"></a>1、下载VMware虚拟机</h1><p>获取VMware虚拟机安装包的方法有两个：</p>
<p><strong>1、VMware官网：</strong><a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p>
<p><img src="/images/2020/04/20200415174651464.png" alt="在这里插入图片描述">当然，VMware是一款商业软件，是收费的。</p>
<p><strong>2、除了官网下载之外，我还在自己的百度网盘中上传了VMware安装软件。</strong><br>链接：<a href="https://pan.baidu.com/s/1QON5-U4joSboW4Xb3N0Bgg">https://pan.baidu.com/s/1QON5-U4joSboW4Xb3N0Bgg</a><br>提取码：92xr</p>
<h1 id="2、安装VMware虚拟机"><a href="#2、安装VMware虚拟机" class="headerlink" title="2、安装VMware虚拟机"></a>2、安装VMware虚拟机</h1><p>我们直接运行VMware虚拟机安装包的exe文件，开始安装。</p>
<p><strong>1、释放文件</strong><br><img src="/images/2020/04/2020041517511543.png" alt="在这里插入图片描述"></p>
<p><strong>2、VMware安装开始界面</strong><br><img src="/images/2020/04/2020041517525792.png" alt="在这里插入图片描述"></p>
<p><strong>3、接受许可协议</strong><br><img src="/images/2020/04/20200415175421150.png" alt="在这里插入图片描述"></p>
<p><strong>4、选择安装磁盘位置</strong><br><img src="/images/2020/04/20200415180809522.png" alt="在这里插入图片描述"></p>
<p><img src="/images/2020/04/20200415180916743.png" alt="在这里插入图片描述"></p>
<p><strong>5、自定义安装</strong><br><img src="/images/2020/04/2020041518102297.png" alt="在这里插入图片描述"></p>
<p><strong>6、快捷方式</strong><br><img src="/images/2020/04/20200415175746169.png" alt="在这里插入图片描述"></p>
<p><strong>7、安装</strong><br><img src="/images/2020/04/20200415175810600.png" alt="在这里插入图片描述"></p>
<p><strong>8、安装过程</strong><br><img src="/images/2020/04/20200415175846361.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>备注：如果是使用我百度网盘中的安装包，安装完了之后会跳出一个破解界面，点击许可证——输入——完成即可。</strong></p>
</blockquote>
<h1 id="3、开启VMware虚拟机"><a href="#3、开启VMware虚拟机" class="headerlink" title="3、开启VMware虚拟机"></a>3、开启VMware虚拟机</h1><p><strong>当安装完成之后，电脑桌面会出现一个VMware虚拟机的图标：</strong><br><img src="/images/2020/04/20200415181445981.png" alt="在这里插入图片描述"></p>
<p><strong>双击开启VMware虚拟机，虚拟机界面如下：</strong><br><img src="/images/2020/04/20200415181640707.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>WebStrom 开发 Vue 项目，安装 ESLint 代码风格检查工具</title>
    <url>/2021/08/30/javascript/WebStrom%20%E5%BC%80%E5%8F%91%20Vue%20%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%AE%89%E8%A3%85%20ESLint%20%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>WebStrom 开发 Vue 项目，安装 ESLint 代码风格检查工具</p>
<span id="more"></span>

<h1 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h1><blockquote>
<p>ESLint最初是由<a href="http://nczonline.net">Nicholas C. Zakas</a> 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。</p>
</blockquote>
<p>在一个 Vue 项目中要使用 ESLint 工具，首先需要安装 Vue，并创建一个简单的 Vue 项目，而后在 Vue 项目的基础上安装 ESLint 依赖，最后进行 ESLint 的相关配置。</p>
<h2 id="创建-Vue-项目"><a href="#创建-Vue-项目" class="headerlink" title="创建 Vue 项目"></a>创建 Vue 项目</h2><p>1、使用 npm 安装 Vue3 的最新版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue@next</span><br></pre></td></tr></table></figure>



<p>2、安装最新版本的 Vue-cli 脚手架模板。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli@next</span><br></pre></td></tr></table></figure>



<p>3、使用 Vite 构建项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>



<h2 id="安装-ESLint"><a href="#安装-ESLint" class="headerlink" title="安装 ESLint"></a>安装 ESLint</h2><p>我们可以使用 npm 命令安装 ESLint，一共需要安装三个 ESLint 项目的依赖，本地安装和全局安装任选一个即可。</p>
<ul>
<li>本地安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install eslint --save-dev</span><br><span class="line">npm install eslint-plugin-vue --save-dev</span><br><span class="line">npm install babel-eslint --save-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>全局安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g eslint</span><br><span class="line">npm install -g eslint-plugin-vue</span><br><span class="line">npm install -g babel-eslint</span><br></pre></td></tr></table></figure>



<h2 id="配置-WebStrom"><a href="#配置-WebStrom" class="headerlink" title="配置 WebStrom"></a>配置 WebStrom</h2><p>在 Vue 项目中安装完 ESLint 依赖，还需要对 WebStrom 进行配置。</p>
<p>打开 File -&gt; Settings -&gt; Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; ESLint</p>
<p>界面如下：</p>
<p><img src="/images/2023/02/01.png" alt="img"></p>
<p>最后，点击界面右下角的 <code>Apply</code> 按钮，应用该配置即可。</p>
<h2 id="添加-ESLint-配置文件"><a href="#添加-ESLint-配置文件" class="headerlink" title="添加 ESLint 配置文件"></a>添加 ESLint 配置文件</h2><p>在没有 ESLint 配置文件的情况下，会使用默认的代码风格配置进行检查，我们可以给项目增加 ESLint 的配置文件来对项目进行代码风格配置，变成自己适应的代码风格。</p>
<ul>
<li>在项目的顶级目录下新增 <code>.eslintrc.js</code> 和 <code>.eslintignore</code> 文件，其中 <code>.eslintrc.js</code> 文件是 ESLint 的代码风格配置文件，而 <code>.eslintignore</code> 文件，则是忽略 ESLint 代码风格检查的文件的名称或路径的配置文件。</li>
</ul>
<h3 id="eslintignore"><a href="#eslintignore" class="headerlink" title=".eslintignore"></a>.eslintignore</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">build<span class="comment">/*.js</span></span><br><span class="line"><span class="comment">src/assets</span></span><br><span class="line"><span class="comment">public</span></span><br><span class="line"><span class="comment">dist</span></span><br></pre></td></tr></table></figure>



<h3 id="eslintrc-js"><a href="#eslintrc-js" class="headerlink" title=".eslintrc.js"></a>.eslintrc.js</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">es6</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;plugin:vue/recommended&#x27;</span>, <span class="string">&#x27;eslint:recommended&#x27;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your custom rules here</span></span><br><span class="line">  <span class="comment">// it is base on https://github.com/vuejs/eslint-config-vue</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;vue/max-attributes-per-line&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;singleline&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">&#x27;multiline&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;max&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&#x27;allowFirstLine&#x27;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;vue/singleline-html-element-content-newline&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;vue/multiline-html-element-content-newline&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;vue/name-property-casing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;PascalCase&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;vue/no-v-html&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;accessor-pairs&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;arrow-spacing&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;before&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;after&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;block-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;brace-style&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;1tbs&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;allowSingleLine&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;camelcase&#x27;</span>: [<span class="number">0</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;properties&#x27;</span>: <span class="string">&#x27;always&#x27;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;comma-dangle&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;comma-spacing&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;before&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&#x27;after&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;comma-style&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;last&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;constructor-super&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;curly&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;multi-line&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;dot-location&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;property&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;eol-last&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;eqeqeq&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>, &#123; <span class="string">&#x27;null&#x27;</span>: <span class="string">&#x27;ignore&#x27;</span> &#125;],</span><br><span class="line">    <span class="string">&#x27;generator-star-spacing&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;before&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;after&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;handle-callback-err&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;^(err|error)$&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;indent&#x27;</span>: [<span class="number">2</span>, <span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;SwitchCase&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;jsx-quotes&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;prefer-single&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;key-spacing&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;beforeColon&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&#x27;afterColon&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;keyword-spacing&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;before&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;after&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;new-cap&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;newIsCap&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;capIsNew&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;new-parens&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-array-constructor&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-caller&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-class-assign&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-cond-assign&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-const-assign&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-control-regex&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;no-delete-var&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-dupe-args&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-dupe-class-members&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-dupe-keys&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-duplicate-case&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-empty-character-class&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-empty-pattern&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-eval&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-ex-assign&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-extend-native&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-extra-bind&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-extra-boolean-cast&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-extra-parens&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;functions&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;no-fallthrough&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-floating-decimal&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-func-assign&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-implied-eval&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-inner-declarations&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;functions&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;no-invalid-regexp&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-irregular-whitespace&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-iterator&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-label-var&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-labels&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;allowLoop&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&#x27;allowSwitch&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;no-lone-blocks&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-mixed-spaces-and-tabs&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-multi-spaces&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-multi-str&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-multiple-empty-lines&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;max&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;no-native-reassign&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-negated-in-lhs&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-new-object&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-new-require&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-new-symbol&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-new-wrappers&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-obj-calls&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-octal&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-octal-escape&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-path-concat&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-proto&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-redeclare&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-regex-spaces&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-return-assign&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;except-parens&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;no-self-assign&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-self-compare&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-sequences&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-shadow-restricted-names&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-spaced-func&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-sparse-arrays&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-this-before-super&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-throw-literal&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-trailing-spaces&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-undef&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-undef-init&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-unexpected-multiline&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-unmodified-loop-condition&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-unneeded-ternary&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;defaultAssignment&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;no-unreachable&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-unsafe-finally&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-unused-vars&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;vars&#x27;</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;args&#x27;</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;no-useless-call&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-useless-computed-key&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-useless-constructor&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-useless-escape&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;no-whitespace-before-property&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-with&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;one-var&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;initialized&#x27;</span>: <span class="string">&#x27;never&#x27;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;operator-linebreak&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;after&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;overrides&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: <span class="string">&#x27;before&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;:&#x27;</span>: <span class="string">&#x27;before&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;padded-blocks&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;quotes&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;single&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;avoidEscape&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;allowTemplateLiterals&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;semi&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;semi-spacing&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;before&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&#x27;after&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;space-before-blocks&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;space-before-function-paren&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;space-in-parens&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;space-infix-ops&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;space-unary-ops&#x27;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;words&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;nonwords&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;spaced-comment&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;always&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;markers&#x27;</span>: [<span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;eslint&#x27;</span>, <span class="string">&#x27;eslint-disable&#x27;</span>, <span class="string">&#x27;*package&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;,&#x27;</span>]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;template-curly-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;use-isnan&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;valid-typeof&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;wrap-iife&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;any&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;yield-star-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;both&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;yoda&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;prefer-const&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="number">2</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;object-curly-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;always&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">objectsInObjects</span>: <span class="literal">false</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&#x27;array-bracket-spacing&#x27;</span>: [<span class="number">2</span>, <span class="string">&#x27;never&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="格式化代码快捷键"><a href="#格式化代码快捷键" class="headerlink" title="格式化代码快捷键"></a>格式化代码快捷键</h2><p>在配置完 ESLint 代码风格检查工具之后，我们可以直接格式化代码，使得我们的前端代码自动格式化为 ESLint 的所配置的代码风格。</p>
<h3 id="右键格式化"><a href="#右键格式化" class="headerlink" title="右键格式化"></a>右键格式化</h3><p>在需要格式化的文件中点击鼠标右键，可以看到右键菜单中有一个 <code>Fix ESLint Problems</code> 的选项，点击该选项，即可格式化该文件的全部代码。</p>
<p><img src="/images/2023/02/02.png" alt="img"></p>
<h3 id="快捷键格式化"><a href="#快捷键格式化" class="headerlink" title="快捷键格式化"></a>快捷键格式化</h3><p>右键菜单的方法毕竟还是比较繁琐的，我们还可以通过配置快捷键的方式，直接使用快捷键对文件代码进行格式化操作。</p>
<p>打开 File -&gt; Settings -&gt; Keymap</p>
<p><img src="/images/2023/02/03.png" alt="img"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>WebStrom</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库常用SQL</title>
    <url>/2020/03/14/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8SQL/</url>
    <content><![CDATA[<h1 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h1><p>结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>
<span id="more"></span>
<p><strong>SQL的分类</strong></p>
<ul>
<li>DDL: 数据库的定义, 与数据库/表结构: create, drop, alter</li>
<li>DCL: 数据控制语言: 设置用户的访问权限  安全</li>
<li>DML: 数据操纵语言: 操作表数据 insert update delete</li>
<li>DQL: 数据查询语言: select  from where</li>
</ul>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><table>
<thead>
<tr>
<th>操作</th>
<th>SQL</th>
</tr>
</thead>
<tbody><tr>
<td>创建数据库</td>
<td>create database 数据库的名字</td>
</tr>
<tr>
<td>删除数据库</td>
<td>drop database 数据库名字</td>
</tr>
<tr>
<td>修改数据库</td>
<td>alter database character set 字符集</td>
</tr>
<tr>
<td>查看所有数据库</td>
<td>show databases</td>
</tr>
<tr>
<td>查看数据库定义</td>
<td>show create database 数据库名字</td>
</tr>
<tr>
<td>查看当前正在使用的数据库</td>
<td>select database()</td>
</tr>
<tr>
<td>选中数据库</td>
<td>use 数据库的名字</td>
</tr>
</tbody></table>
<h1 id="表结构操作"><a href="#表结构操作" class="headerlink" title="表结构操作"></a>表结构操作</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>create table 表名(<br>  列名 列的类型(长度) 约束,<br>  列名2 列的类型(长度) 约束<br>);</p>
<p><strong>列的约束</strong></p>
<ul>
<li>主键约束: primary key</li>
<li>唯一约束: unique</li>
<li>非空约束: not null</li>
</ul>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>drop table 表名</p>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><table>
<thead>
<tr>
<th>操作</th>
<th>SQL</th>
</tr>
</thead>
<tbody><tr>
<td>添加列</td>
<td>alter table 表名 add 列名 列的类型 列的约束</td>
</tr>
<tr>
<td>修改列</td>
<td>alter table 表名 modify 列名 列的类型 列的约束</td>
</tr>
<tr>
<td>修改列名</td>
<td>alter table 表名 change 旧列名 新列名 列的类型 列的约束</td>
</tr>
<tr>
<td>删除列</td>
<td>alter table 表名 drop 列名</td>
</tr>
<tr>
<td>修改表的字符集</td>
<td>alter table 表名 character set 字符集</td>
</tr>
<tr>
<td>修改表名</td>
<td>rename table  旧表名 to 新的表名</td>
</tr>
</tbody></table>
<h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><table>
<thead>
<tr>
<th>操作</th>
<th>SQL</th>
</tr>
</thead>
<tbody><tr>
<td>查看当前数据库中所有的表名</td>
<td>show tables</td>
</tr>
<tr>
<td>查看表的定义结构/创建语句</td>
<td>show create table 表名</td>
</tr>
<tr>
<td>查看表的结构</td>
<td>desc 表名</td>
</tr>
</tbody></table>
<h1 id="表中数据的CRUD操作"><a href="#表中数据的CRUD操作" class="headerlink" title="表中数据的CRUD操作"></a>表中数据的CRUD操作</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><ul>
<li>insert into 表名(列名1,列名2)values(值1,值2);</li>
<li>insert into 表名 values(值1,值2);</li>
<li>批量插入：insert into 表名values(值1,值2),(值1,值2),(值1,值2);</li>
</ul>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul>
<li>delete from 表名 [where 条件];</li>
<li>先删除表,再重建表：truncate table 表名;</li>
</ul>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul>
<li>update 表名 set 列名=值, 列名=值 [where 条件];</li>
</ul>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p><strong>通用格式</strong><br>select [distinct] [*] [列名1,列名2] from 表名 where 条件 group by [列名] having 条件过滤 order by 排序1 asc,排序2 desc;</p>
<p><strong>关系运算符</strong></p>
<ul>
<li>&lt;&gt; 不等于</li>
<li>!= 不等于</li>
</ul>
<p><strong>逻辑运算符</strong></p>
<ul>
<li>and or not</li>
</ul>
<p><strong>在范围中</strong></p>
<ul>
<li>in</li>
</ul>
<p><strong>模糊查询</strong></p>
<ul>
<li>like</li>
<li>_  表示的单个字符</li>
<li>% 表示的是多个字符</li>
</ul>
<p><strong>别名查询</strong></p>
<ul>
<li>as</li>
</ul>
<p><strong>聚合函数</strong></p>
<ul>
<li>sum : 求和</li>
<li>avg()  : 平均值</li>
<li>count() : 统计数量</li>
<li>max() : 最大值</li>
<li>min() : 最小值</li>
</ul>
<p><strong>排序</strong> </p>
<ul>
<li>order by [列名] asc：升序排序 </li>
<li>order by [列名] desc：降序排序 </li>
</ul>
<p><strong>分组</strong> </p>
<ul>
<li>group by [列名]</li>
</ul>
<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="/images/2020/03/2020031409202382.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库逻辑架构与存储引擎</title>
    <url>/2020/04/04/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<blockquote>
<p>MySQL是目前市场是非常流行的关系型数据库，很多企业都使用MySQL作为服务器数据库。</p>
</blockquote>
<span id="more"></span>
<h1 id="MySQL数据库的特点"><a href="#MySQL数据库的特点" class="headerlink" title="MySQL数据库的特点"></a>MySQL数据库的特点</h1><ul>
<li>MySQL数据库是一款开源的关系型数据库，性能突出。</li>
<li>MySQL支持多种存储引擎，可以自由选择。</li>
<li>MySQL支持事务和数据恢复（依赖存储引擎）。</li>
</ul>
<h1 id="MySQL数据库的架构"><a href="#MySQL数据库的架构" class="headerlink" title="MySQL数据库的架构"></a>MySQL数据库的架构</h1><h2 id="MySQL的客户端"><a href="#MySQL的客户端" class="headerlink" title="MySQL的客户端"></a>MySQL的客户端</h2><p>MySQL数据库是一个C/S架构的数据库，其中MySQL的服务端只有一个，但是客户端可以有多个，比如使用Java，Python等语言操作数据库，那么这些语言所编写的程序，就算是一个MySQL数据库的客户端，除此之外，比如Windows系统下的cmd命令提示窗口，也可以算是一种客户端。</p>
<h2 id="MySQL的服务器端"><a href="#MySQL的服务器端" class="headerlink" title="MySQL的服务器端"></a>MySQL的服务器端</h2><p>MySQL的服务器端是重点，是MySQL数据库能够保存大量数据的原因，我们首先来看一看MySQL服务器端的各个组件以及组件的作用。</p>
<p><strong>连接管理：</strong> 这是MySQL数据库的客户端和服务器端建立连接的一个管理工具，客户端通过IP地址，端口号，用户名和密码等信息连接MySQL数据库，然后由数据库的连接管理工具进行连接验证，确认用户名和密码的权限，是否能够访问数据库，能够访问哪些数据库。</p>
<p><strong>缓存查询：</strong> MySQL为了优化访问数据的效率，会将一些SQL查询的数据放入缓存中，当有其他SELECT语句的SQL查询数据库的时候，会先查看缓存中是否有对应数据，如果有则直接返回，没有才会去解析SQL。但是因为缓存命中需要满足很多条件，比如SQL相同，上下文环境相同等等，导致MySQL的缓存命中率非常低下，所以在MySQL8.0的版本中，已经将缓存查询移除了。</p>
<p><strong>解析器：</strong> MySQL的解析器的作用是用来解析SQL语句的，分析SQL语句的语法和语义。</p>
<p><strong>优化器：</strong> MySQL的优化器，顾名思义，就是用来优化SQL的执行效率的，MySQL的优化器，可以分析SQL使用哪种方式执行效率最高，比如查询语句是使用全盘扫描的方式还是索引查询，MySQL的优化器是决定SQL执行性能的关键组件。不过优化器也并不是万能的，因为优化器判断使用哪种执行方式，使用的是基于数据库数据的抽样统计分析，抽样统计分析有时候可能会导致数据具有倾向性，从而导致优化器使用了错误的执行方法。</p>
<h2 id="MySQL的逻辑架构"><a href="#MySQL的逻辑架构" class="headerlink" title="MySQL的逻辑架构"></a>MySQL的逻辑架构</h2><p> <strong>MySQL的架构分为三层，分别是客户端，服务器层，存储引擎层。</strong></p>
<p><img src="/images/2020/04/20200404225751911.png" alt="在这里插入图片描述"></p>
<h2 id="MySQL的SQL执行流程"><a href="#MySQL的SQL执行流程" class="headerlink" title="MySQL的SQL执行流程"></a>MySQL的SQL执行流程</h2><ul>
<li>一条SQL通过连接管理工具的权限验证之后，会首先使用MySQL的缓存查询，如果缓存命中，直接返回SQL执行结果，如果缓存未命中，则由SQL解析器进行SQL语法语义解析。<strong>MySQL8.0由于缓存命中率太低，已经移除了缓存查询这一组件。</strong></li>
<li>SQL通过解析器解析了语法和语义之后，将解析出来的内容交给MySQL优化器，由MySQL优化器做进一步的优化分析。</li>
<li>最终MySQL将优化器分析出来的结果交给MySQL的存储引擎执行。</li>
</ul>
<h1 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h1><ul>
<li>MySQL的存储引擎是对底层物理数据执行实际操作的组件，为服务器层提供各种操作数据的 API。MySQL 支持插件式的存储引擎，包括 InnoDB、MyISAM、Memory 等等。</li>
<li>插件式存储引擎是 MySQL 的一大特点体系结构，每个存储引擎都提供了各自的功能，用户可以根据业务或者应用场景为数据表选择不同的存储引擎。也就是说，存储引擎的设置是在表级别的；因此也被称为表类型（table type）.</li>
</ul>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>MySQL数据库在5.5的版本之后，默认使用InnoDB存储引擎。</p>
<ul>
<li>InnoDB存储引擎是一个支持事务，支持表级锁和行级锁，支持高并发的存储引擎。</li>
<li>InnoDB是事务安全型的存储引擎，可以保证数据安全，更加注重数据的完整性和安全性。</li>
<li>InnoDB存储引擎，在插入数据的时候，会按照主键顺序进行排序，所以插入数据的效率较低一些。</li>
<li>InnoDB在5.6版本之后支持全文检索功能。</li>
</ul>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>在MySQL5.5之前的版本，默认使用的存储引擎都是MyISAM，后来因为InnoDB的功能和性能逐渐完善和强大，才被InnoDB取代。</p>
<ul>
<li>MyISAM不支持事务，也不支持行级锁，只支持表级锁，不支持高并发。</li>
<li>MyISAM擅长高速读写，在插入数据的时候不进行排序，所以插入数据的速度优于InnoDB。</li>
<li>MyISAM支持数据压缩，但是数据压缩之后表变为只读表，只允许读操作，如果要进行写操作，需要解压数据。</li>
<li>MyISAM支持全文检索功能。</li>
</ul>
<h2 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h2><table>
<thead>
<tr>
<th></th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持事务</td>
<td>不支持事务</td>
</tr>
<tr>
<td>全文检索</td>
<td>5.6之后支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁粒度</td>
<td>支持表级锁，行级锁</td>
<td>支持表级锁，不支持行级锁</td>
</tr>
<tr>
<td>高并发</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>效率</td>
<td>更新、删除快，插入较慢</td>
<td>高速插入和查找</td>
</tr>
<tr>
<td>数据安全</td>
<td>注重数据完整性、安全性</td>
<td>较差</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL警告信息：不建议在没有服务器身份验证的情况下建立SSL连接</title>
    <url>/2020/06/26/mysql/MySQL%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF%EF%BC%9A%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%9C%A8%E6%B2%A1%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%BB%BA%E7%AB%8BSSL%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>前段时间重装了MySQL数据库，将原本的MySQL5.5版本换成了5.7版本，今天在运行以前的项目的时候，突然爆出了如下的错误信息：</p>
<span id="more"></span>

<p><font color="#FF0000">Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</font ></p>
<p>不建议在没有服务器身份验证的情况下建立SSL连接。 根据MySQL 5.5.45 +，5.6.26 +和5.7.6+的要求，如果未设置显式选项，则默认情况下必须建立SSL连接。 为了与不使用SSL的现有应用程序兼容，将verifyServerCertificate属性设置为’false’。 您需要通过设置useSSL = false显式禁用SSL，或者设置useSSL = true并提供信任库以进行服务器证书验证。</p>
<p><strong>这个报错信息比较容易理解，我们直接在MySQL的url连接中添加一个参数<code>useSSL=false</code>，即可解决该报错问题。</strong></p>
<p>例如：<code>jdbc:mysql://localhost:3306/myshop?useSSL=false</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇博客教会你怎么使用Docker安装MySQL5.7</title>
    <url>/2020/05/07/mysql/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%95%99%E4%BC%9A%E4%BD%A0%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85MySQL5.7/</url>
    <content><![CDATA[<blockquote>
<p>首先我们需要安装Docker，如果没有安装Docker的朋友，可以参考我以前的博客<a href="/2020/04/16/tool/一篇博客教会你怎么安装Docker/">一篇博客教会你怎么安装Docker</a>进行Docker的安装。</p>
</blockquote>
<span id="more"></span>

<h1 id="一、我们直接使用Docker来拉取MySQL5-7的镜像文件"><a href="#一、我们直接使用Docker来拉取MySQL5-7的镜像文件" class="headerlink" title="一、我们直接使用Docker来拉取MySQL5.7的镜像文件"></a>一、我们直接使用Docker来拉取MySQL5.7的镜像文件</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure>

<h1 id="二、我们使用这个镜像创建一个MySQL容器"><a href="#二、我们使用这个镜像创建一个MySQL容器" class="headerlink" title="二、我们使用这个镜像创建一个MySQL容器"></a>二、我们使用这个镜像创建一个MySQL容器</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> <span class="literal">--name</span> mysql <span class="literal">-e</span> TZ=Asia/Shanghai <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=admin <span class="literal">-d</span> mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure>

<h1 id="三、我们运行这个MySQL容器"><a href="#三、我们运行这个MySQL容器" class="headerlink" title="三、我们运行这个MySQL容器"></a>三、我们运行这个MySQL容器</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">start</span> mysql</span><br></pre></td></tr></table></figure>
<p>运行成功之后，我们可以通过命令<code>docker ps -a</code>来查看当前容器的状态。<br><img src="/images/2020/05/20200507132547373.png" alt="在这里插入图片描述"></p>
<h1 id="四、我们进入MySQL容器内部"><a href="#四、我们进入MySQL容器内部" class="headerlink" title="四、我们进入MySQL容器内部"></a>四、我们进入MySQL容器内部</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> mysql bash</span><br></pre></td></tr></table></figure>

<h1 id="五、输入MySQL的账户名和密码，进入MySQL命令提示行"><a href="#五、输入MySQL的账户名和密码，进入MySQL命令提示行" class="headerlink" title="五、输入MySQL的账户名和密码，进入MySQL命令提示行"></a>五、输入MySQL的账户名和密码，进入MySQL命令提示行</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br></pre></td></tr></table></figure>

<h1 id="六、退出MySQL命令提示行"><a href="#六、退出MySQL命令提示行" class="headerlink" title="六、退出MySQL命令提示行"></a>六、退出MySQL命令提示行</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<h1 id="七、退出容器"><a href="#七、退出容器" class="headerlink" title="七、退出容器"></a>七、退出容器</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇博客教会你怎么安装MySQL5.7</title>
    <url>/2020/05/18/mysql/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%95%99%E4%BC%9A%E4%BD%A0%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85MySQL5.7/</url>
    <content><![CDATA[<blockquote>
<p>上一次我们学习了在Linux系统环境下，使用docker来进行安装MySQL5.7，具体可以参考博客<a href="/2020/05/07/mysql/一篇博客教会你怎么使用Docker安装MySQL5.7/">一篇博客教会你怎么使用Docker安装MySQL5.7</a>，今天我们来学习在Windows环境下安装MySQL5.7。</p>
</blockquote>
<span id="more"></span>
<h1 id="一、MySQL的下载"><a href="#一、MySQL的下载" class="headerlink" title="一、MySQL的下载"></a>一、MySQL的下载</h1><p>MySQL5.7版本是免费版本，我们可以直接去MySQL的官网进行安装包下载。<br>MySQL官网：<a href="https://dev.mysql.com/downloads/windows/installer/5.7.html">https://dev.mysql.com/downloads/windows/installer/5.7.html</a></p>
<p>我们打开官网链接，可以看到如下的界面：<br><img src="/images/2020/05/20200517135416867.png" alt="在这里插入图片描述"><br><img src="/images/2020/05/20200517135416980.png" alt="在这里插入图片描述"></p>
<h1 id="二、MySQL的安装"><a href="#二、MySQL的安装" class="headerlink" title="二、MySQL的安装"></a>二、MySQL的安装</h1><p>1、我们下载完成之后，双击运行MySQL的安装包。<br><img src="/images/2020/05/20200518130626463.png" alt="在这里插入图片描述"></p>
<p>2、打开如下界面，我们选择运行。<br><img src="/images/2020/05/20200518130702776.png" alt="在这里插入图片描述"></p>
<p>3、电脑会为我们进行一些配置，画面如下，我们等待即可。<br><img src="/images/2020/05/20200518130830279.png" alt="在这里插入图片描述"></p>
<p>4、出现如下界面，表示我们已经进入了MySQL的安装界面，可以正式开始安装MySQL了。<br><img src="/images/2020/05/2020051813085633.png" alt="在这里插入图片描述"></p>
<p>5、我们选择自定义配置，然后Next。<br><img src="/images/2020/05/20200518131221599.png" alt="在这里插入图片描述"></p>
<p>6、选择32位或者64位的MySQL。<br><img src="/images/2020/05/20200518131643386.png" alt="在这里插入图片描述"></p>
<p>7、选择MySQL的安装位置。<br><img src="/images/2020/05/20200518131918389.png" alt="在这里插入图片描述"><br><img src="/images/2020/05/20200518132028908.png" alt="在这里插入图片描述"></p>
<p>8、检查MySQL5.7的安装环境。<br><img src="/images/2020/05/20200518132331645.png" alt="在这里插入图片描述"></p>
<p>9、默认配置，直接Next即可。<br><img src="/images/2020/05/20200518132555765.png" alt="在这里插入图片描述"></p>
<p>10、选择默认，点击Next即可。<br><img src="/images/2020/05/20200518132712641.png" alt="在这里插入图片描述"></p>
<p>11、选择默认，点击Next即可。<br><img src="/images/2020/05/2020051813285345.png" alt="在这里插入图片描述"></p>
<p>12、设置密码。<br><img src="/images/2020/05/20200518133124969.png" alt="在这里插入图片描述"></p>
<p>13、MySQL服务配置，点击Next即可。<br><img src="/images/2020/05/20200518133410292.png" alt="在这里插入图片描述"></p>
<p>14、点击Execute。<br><img src="/images/2020/05/20200518133602347.png" alt="在这里插入图片描述"></p>
<p>15、点击Finish。<br><img src="/images/2020/05/20200518133712331.png" alt="在这里插入图片描述"></p>
<p>16、点击Next。<br><img src="/images/2020/05/20200518133807610.png" alt="在这里插入图片描述"></p>
<p>17、点击Finish，完成安装。<br><img src="/images/2020/05/20200518133934256.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基本数据类型</title>
    <url>/2021/11/21/python/Python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>Python 有多种基本数据类型，用来存储内存中的数据。Python 一共提供了三种基本数据类型，其中分为是：数值型、字符型、布尔型。</p>
</blockquote>
<span id="more"></span>

<h2 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h2><blockquote>
<p>数值型就是用来存储数字的类型，例如一个人的年龄，身高，体重，一家公司的年度营收，员工总数等等。</p>
</blockquote>
<p>在 Python 中，提供了数字类型来保存这些数据，并且这些数值类型是不可改变的数据类型。如果需要修改数字类型变量的值，那么会先把该值放入内存中，然后修改变量让其指向新的内存地址。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line">a = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">140718916818880</span></span><br><span class="line"><span class="number">140718916818880</span></span><br><span class="line"><span class="number">140718916818944</span></span><br><span class="line"><span class="number">140718916818880</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：在 Python 语言中，可以使用内置的函数 <code>id()</code> 来获取变量所指向的内存地址。</p>
</blockquote>
<p>a 与 b 虽然是不同的变量，但是他们的值都是相同的，所以它们在内存中的地址也是相同的，而当改变变量 a 的值的时候，并不是直接改变变量 a 的值，而是改变了变量 a 所指向的内存地址。</p>
<p>在 Python 语言中，数值类型主要包括整数、浮点数和复数。</p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><blockquote>
<p>整数就是整数数值，是没有小数部分的数值，例如：0、3、10、-1 等等。整数包括正整数、负数和0。Python 中的整数会自动转换高精度计算，所以 Python 中的整数类型的位数是任意的。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123456</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">c = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">d = <span class="number">25465486413516513542315452153423134654134531</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">25465486413516513542315452153423134654134531</span></span><br></pre></td></tr></table></figure>



<p>值得一提的是，Python 中的整数类型，如果是十进制整数，除了0之外，其他数值不能以0作为开头。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">000000000</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = 000023</span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure>

<p>运行结果：报错</p>
<p>Python 中的整数除了十进制类型外，还有八进制、十六进制、二进制等等，在这里不过多讲解。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><blockquote>
<p>浮点数主要由整数部分和小数部分组成，主要用于处理包括小数的数值。例如：3.1415926、-152.01、0.0001 等。</p>
</blockquote>
<p>在使用浮点数计算的时候，可能会出现小数位数不确定的情况。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0.1</span> + <span class="number">0.1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>这是因为浮点数值在内存中保存方法导致的，基本上所有的计算机语言都存在这个问题，我们这里直接忽略多余的小数位即可。</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><blockquote>
<p>Python 中的复数与数学中的复数的表现形式完全一致，都是有实数和虚数构成，并且使用 <code>j</code> 或 <code>J</code> 表示虚部。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">6.54</span> + <span class="number">32.01j</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">6.54</span>+<span class="number">32.01j</span>)</span><br></pre></td></tr></table></figure>



<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><blockquote>
<p>字符串就是连续的字符组成的，通常使用 单引号<code>&#39;&#39;</code>、双引号<code>&quot;&quot;</code>、三引号<code>&#39;&#39;&#39;&#39;&#39;&#39;</code>或者 <code>&quot;&quot;&quot;&quot;&quot;&quot;</code>包裹起来。</p>
</blockquote>
<p>这三种类在 Python 中，字符串和整数一样，也属于不可变序列。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;字符串类型&quot;</span></span><br><span class="line">b = <span class="string">&quot;字符串类型&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line">a = <span class="string">&quot;字符串类型2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1357027606320</span></span><br><span class="line"><span class="number">1357027606320</span></span><br><span class="line"><span class="number">1357027224800</span></span><br><span class="line"><span class="number">1357027606320</span></span><br></pre></td></tr></table></figure>



<p>在 Python 中，单引号和双引号的字符串都只能在同一行，而三引号的字符串可以多行书写。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;单引号字符串&#x27;</span></span><br><span class="line">b = <span class="string">&quot;双引号字符串&quot;</span></span><br><span class="line">c = <span class="string">&#x27;&#x27;&#x27;三引号字符串</span></span><br><span class="line"><span class="string">    可以多行展示</span></span><br><span class="line"><span class="string">    |————————|</span></span><br><span class="line"><span class="string">    |        |</span></span><br><span class="line"><span class="string">    |--------|</span></span><br><span class="line"><span class="string">    结束&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">单引号字符串</span><br><span class="line">双引号字符串</span><br><span class="line">三引号字符串</span><br><span class="line">    可以多行展示</span><br><span class="line">    |————————|</span><br><span class="line">    |        |</span><br><span class="line">    |--------|</span><br><span class="line">    结束</span><br></pre></td></tr></table></figure>



<p>在 Python 中，存在转义字符，所谓转义字符，是指使用反斜杠 <code>\</code> 对一些特殊字符进行转义。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \n 换行符</span></span><br><span class="line">a = <span class="string">&quot;Python\n字符串a&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># \0 空</span></span><br><span class="line">b = <span class="string">&quot;Python\0字符串b&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># \t 水平制表符</span></span><br><span class="line">c = <span class="string">&quot;Python\t字符串c&quot;</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># \&quot; 双引号</span></span><br><span class="line">d = <span class="string">&quot;Python\&quot;字符串d&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># \&#x27; 单引号</span></span><br><span class="line">e = <span class="string">&#x27;Python\&#x27;字符串e&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment"># \\ 反斜杠</span></span><br><span class="line">f = <span class="string">&quot;Python\\字符串f&quot;</span></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="comment"># \f 换页</span></span><br><span class="line">j = <span class="string">&quot;Python\f字符串j&quot;</span></span><br><span class="line"><span class="built_in">print</span>(j)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python</span><br><span class="line">字符串a</span><br><span class="line">Python 字符串b</span><br><span class="line">Python	字符串c</span><br><span class="line">Python<span class="string">&quot;字符串d</span></span><br><span class="line"><span class="string">Python&#x27;字符串e</span></span><br><span class="line"><span class="string">Python\字符串f</span></span><br><span class="line"><span class="string">Python字符串j</span></span><br></pre></td></tr></table></figure>



<p>除了这些转义字符外，还有其他一些不常用的转义字符，在这里不过多讲述。</p>
<p>值得一提的是，在 Python 中，在字符串定界符引前加上字母<code>r</code>（或者R），即可原样输出字符串。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">r&quot;Python\n字符串a&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python\n字符串a</span><br></pre></td></tr></table></figure>





<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><blockquote>
<p>布尔类型主要表示为真值或者假值，在 Python 中，<code>Treu</code> 和 <code>False</code> 都解释为布尔类型。</p>
</blockquote>
<p>Python 中的布尔类型可以解释为数值类型进行计算，<code>True</code> 解释为 1，<code>False</code> 解释为 0。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">True</span> +  <span class="number">1</span></span><br><span class="line">b = <span class="literal">False</span> + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>在 Python 中，所有的对象都可以真值测试，其中，以下几种情况可以被判定为 <code>False</code>，其他情况则为 <code>True</code>。</p>
<ul>
<li><code>False</code> 或 <code>None</code>。</li>
<li>数值中的0，包括0、0.0、虚数0。</li>
<li>空序列，包括空字符串、空元组、空列表、空字典。</li>
<li>自定义的对象，该对象的<code>__bool__</code>  方法返回 <code>False</code>，或者 <code>__len__</code> 方法返回0。</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在 Python 中，可以使用 Python 的内置函数，将一些类型的数据转换为另外一种类型。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>(a)))</span><br><span class="line"></span><br><span class="line">b = <span class="string">&quot;100&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">int</span>(b)))</span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>



<p>常用的类型转换函数有：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换为整数类型</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换为浮点数类型</td>
</tr>
<tr>
<td>complex(real [,imag])</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将x转换为字符串类型</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将x转换为表达式字符串</td>
</tr>
<tr>
<td>eval(x)</td>
<td>计算在字符串中的有效 Python 表达式，并返回一个对象</td>
</tr>
<tr>
<td>chr(x)</td>
<td>将整数x转换为一个字符</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python序列</title>
    <url>/2021/11/29/python/Python%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>序列是一块用于存放多个值的连续的内存空间，并按照一定的顺序排列，每一个值（称为元素）都分配一个数字（称为索引或者位置）。通过索引可以取出对应位置的值。</p>
</blockquote>
<span id="more"></span>

<h1 id="序列的通用操作"><a href="#序列的通用操作" class="headerlink" title="序列的通用操作"></a>序列的通用操作</h1><p>在 Python 中，序列的主要结构有列表、元组、集合、字典和字符串。对于这些序列有一些通用操作，例如索引，切片，相加，相乘，序列长度，是否包含某个元素，序列最大值，序列最小值等等，其中集合和字典不支持索引、切片、相加、相乘操作。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p> 序列中的每一个元素都有一个编号，也称之为索引。序列从左往右开始数，第一个元素的索引是0，第二个元素的索引是1，以此类推。</p>
<p>值得一提的是，Python 的索引可以是负数，从右往左数，第一个元素的索引是-1，第二个元素的索引是-2，以此类推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(arr[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(arr[-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一个元素</span><br><span class="line">第二个元素</span><br><span class="line">第四个元素</span><br><span class="line">第三个元素</span><br></pre></td></tr></table></figure>



<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片操作是访问序列中元素的一种方法，可以用于访问序列中指定范围的元素，通过切片操作生成一个新的序列。</p>
<p>切片操作的语法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name[start : end : step]</span><br></pre></td></tr></table></figure>



<ul>
<li>name 为序列名称</li>
<li>start 为切片开始的索引，如果不指定，默认为0</li>
<li>end 为切片结束的索引 + 1，如果不指定，默认为序列的长度</li>
<li>step 为切片的步长，如果不指定，默认为1</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arr = <span class="selector-attr">[<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr[<span class="number">1</span>:<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr[<span class="number">0</span>:<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr[:])</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>]</span><br></pre></td></tr></table></figure>





<h2 id="序列相加"><a href="#序列相加" class="headerlink" title="序列相加"></a>序列相加</h2><p>在 Python 中，同类型的序列支持相加操作，相加之后的序列元素是原来两个序列的元素组合在一起，重复的元素不会去重，可以直接使用 + 运算符实现。</p>
<p>Python相加只支持同类型的序列，比如列表+列表，不支持列表+元组的操作。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arr1 = <span class="selector-attr">[<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>]</span></span><br><span class="line">arr2 = <span class="selector-attr">[<span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr1 + arr2)</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>]</span><br></pre></td></tr></table></figure>





<h2 id="序列相乘"><a href="#序列相乘" class="headerlink" title="序列相乘"></a>序列相乘</h2><p>序列相乘的操作和序列相加的操作结果类似，相乘是将原来的序列元素乘以倍数，相当于倍数个序列相加。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arr = <span class="selector-attr">[<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr * <span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="序列长度"><a href="#序列长度" class="headerlink" title="序列长度"></a>序列长度</h2><p>Python 提供了内置的函数计算序列的长度。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arr = <span class="selector-attr">[<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;序列长度：&quot;</span>, len(arr)</span></span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">序列长度： <span class="number">4</span></span><br></pre></td></tr></table></figure>



<h2 id="是否包含某个元素"><a href="#是否包含某个元素" class="headerlink" title="是否包含某个元素"></a>是否包含某个元素</h2><p>在 Python 中，可以使用 in 关键字，判断某个元素是否是序列的成员。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arr = <span class="selector-attr">[<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;第二个元素&quot;</span> in arr)</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h2 id="序列最大最小值"><a href="#序列最大最小值" class="headerlink" title="序列最大最小值"></a>序列最大最小值</h2><p>Python 同样提供了内置函数来计算序列中的最大元素和最小元素。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arr = <span class="selector-attr">[23, 234, 324, 1, 34, 23, 6, 34]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(min(arr)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(max(arr)</span></span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">324</span></span><br></pre></td></tr></table></figure>



<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>Python 提供了大量的内置函数，用于操作序列。</p>
<table>
<thead>
<tr>
<th>内置函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>list()</td>
<td>将序列转换为列表</td>
</tr>
<tr>
<td>str()</td>
<td>将序列转换为字符串</td>
</tr>
<tr>
<td>sum()</td>
<td>计算元素和（元素为数字类型）</td>
</tr>
<tr>
<td>sorted()</td>
<td>对元素进行排序</td>
</tr>
<tr>
<td>reversed()</td>
<td>反向序列中的元素</td>
</tr>
<tr>
<td>enumerate()</td>
<td>将序列组合为一个索引序列，多用在for循环中</td>
</tr>
</tbody></table>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul>
<li>可变序列。</li>
<li>所有元素放在一对中括号 <code>[]</code> 中，每个元素之间使用英文逗号 <code>,</code> 分割开来。</li>
<li>元素可以是任意类型。</li>
<li>同一列表的元素类型可以不同。</li>
<li>元素可重复。</li>
</ul>
<h2 id="创建空列表"><a href="#创建空列表" class="headerlink" title="创建空列表"></a>创建空列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emptylist = []</span><br></pre></td></tr></table></figure>



<h2 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="list-函数"><a href="#list-函数" class="headerlink" title="list() 函数"></a>list() 函数</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>))</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(arr)</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure>



<h2 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 内置函数 enumerate()</span></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(index, item)</span><br></pre></td></tr></table></figure>



<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>



<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">list</span>.append(<span class="string">&quot;第五元素&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>, <span class="string">&#x27;第五元素&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>] = <span class="string">&quot;修改后的第一个元素&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;修改后的第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="列表计算"><a href="#列表计算" class="headerlink" title="列表计算"></a>列表计算</h2><p>使用列表对象的 <code>count()</code> 方法，可以统计列表中包含的某个元素出现的次数，<code>index()</code> 方法，可以获取该对象在列表中首次出现的索引位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.count(<span class="string">&quot;第二个元素&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>.index(<span class="string">&quot;第二个元素&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>Python 的内置函数 <code>sum()</code> 可以对列表的元素进行统计。（列表的元素必须是数字类型）</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">list = <span class="selector-attr">[1, 3, 34, 451, 3]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(sum(list)</span></span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">492</span></span><br></pre></td></tr></table></figure>



<p>可以使用列表对象的方法 <code>sort()</code> 或者 Python 的内置函数对列表进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">451</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">list</span>.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">list</span>.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(<span class="built_in">list</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(<span class="built_in">list</span>, reverse=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">451</span>]</span><br><span class="line">[<span class="number">451</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">451</span>]</span><br><span class="line">[<span class="number">451</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<p>值得一提的是，列表对象的 <code>sort()</code> 方法，是在原列表的基础上对列表元素进行排序，而内置函数 <code>sorted()</code>是建立了一个副本，对该副本的元素进行排序。</p>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>使用列表推导式，可以快速生成一个列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">list1 = [random.randint(<span class="number">10</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line">list2 = [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> list1]</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"></span><br><span class="line">list3 = [x <span class="keyword">for</span> x <span class="keyword">in</span> list1 <span class="keyword">if</span> x &gt; <span class="number">50</span>]</span><br><span class="line"><span class="built_in">print</span>(list3)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">25</span>, <span class="number">98</span>, <span class="number">73</span>, <span class="number">70</span>, <span class="number">95</span>, <span class="number">30</span>, <span class="number">62</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">69</span>]</span><br><span class="line">[<span class="number">50</span>, <span class="number">196</span>, <span class="number">146</span>, <span class="number">140</span>, <span class="number">190</span>, <span class="number">60</span>, <span class="number">124</span>, <span class="number">30</span>, <span class="number">46</span>, <span class="number">138</span>]</span><br><span class="line">[<span class="number">98</span>, <span class="number">73</span>, <span class="number">70</span>, <span class="number">95</span>, <span class="number">62</span>, <span class="number">69</span>]</span><br></pre></td></tr></table></figure>





<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><ul>
<li>元组与列表唯一的不同是，元组是不可变序列，不能单独对元组的某一个元素进行修改。</li>
</ul>
<h2 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emptytuple = ()</span><br></pre></td></tr></table></figure>

<h2 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplearr = (<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="tuple-函数"><a href="#tuple-函数" class="headerlink" title="tuple() 函数"></a>tuple() 函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">20</span>)))</span><br></pre></td></tr></table></figure>

<h2 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplearr = (<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> tuplearr</span><br></pre></td></tr></table></figure>

<h2 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplearr = (<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> tuplearr:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(tuplearr):</span><br><span class="line">    <span class="built_in">print</span>(index, item)</span><br></pre></td></tr></table></figure>

<h2 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplearr = (<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tuplearr[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第三个元素</span><br></pre></td></tr></table></figure>



<h2 id="修改元素-1"><a href="#修改元素-1" class="headerlink" title="修改元素"></a>修改元素</h2><blockquote>
<p>元组和列表最大的不同，就在于元组是不可变序列，元组内的元组不可以被修改。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplearr = (<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>)</span><br><span class="line">tuplearr[<span class="number">1</span>] = <span class="string">&quot;第五个元素&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：报错</p>
<blockquote>
<p>如果想要修改元组的元素，必须将整个元组全部重新赋值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplearr = (<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第二个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tuplearr)</span><br><span class="line">tuplearr = (<span class="string">&quot;第一个元素&quot;</span>, <span class="string">&quot;第五个元素&quot;</span>, <span class="string">&quot;第三个元素&quot;</span>, <span class="string">&quot;第四个元素&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tuplearr)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第二个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;第一个元素&#x27;</span>, <span class="string">&#x27;第五个元素&#x27;</span>, <span class="string">&#x27;第三个元素&#x27;</span>, <span class="string">&#x27;第四个元素&#x27;</span>)</span><br></pre></td></tr></table></figure>





<h2 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h2><blockquote>
<p>元组推导式和列表推导式不同的地方在于，列表推导式生成的是一个列表对象，而元组推导式生成的是一个生成器对象，我们需要使用 <code>tuple()</code> 函数将其转换为元组。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">randomtuple1 = (random.randint(<span class="number">10</span>, <span class="number">20</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">randomtuple1 = <span class="built_in">tuple</span>(randomtuple1)</span><br><span class="line"><span class="built_in">print</span>(randomtuple1)</span><br><span class="line"></span><br><span class="line">randomtuple2 = (x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> randomtuple1)</span><br><span class="line">randomtuple2 = <span class="built_in">tuple</span>(randomtuple2)</span><br><span class="line"><span class="built_in">print</span>(randomtuple2)</span><br><span class="line"></span><br><span class="line">randomtuple3 = (x <span class="keyword">for</span> x <span class="keyword">in</span> randomtuple1 <span class="keyword">if</span> x &gt; <span class="number">15</span>)</span><br><span class="line">randomtuple3 = <span class="built_in">tuple</span>(randomtuple3)</span><br><span class="line"><span class="built_in">print</span>(randomtuple3)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">18</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">16</span>)</span><br><span class="line">(<span class="number">36</span>, <span class="number">20</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">32</span>)</span><br><span class="line">(<span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>



<h1 id="列表与元组的区别"><a href="#列表与元组的区别" class="headerlink" title="列表与元组的区别"></a>列表与元组的区别</h1><ul>
<li>列表是可变序列，列表元素可以修改；元组是不可变序列，元组元素不可以修改。</li>
<li>列表可以使用 <code>append()</code> 、<code>extend()</code> 、<code>insert()</code> 、<code>remove()</code> 、<code>pop()</code> 等方法对列表进行修改，元组没有这些方法修改元素，同时元组也无法删除元素。</li>
<li>列表支持用切片修改元素，元组不支持切片修改元素。</li>
<li>元组的访问速度比列表快。</li>
<li>列表不能作为字典的键，元组可以。</li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><ul>
<li>字典通过键值获取字典中保存的数据，不通过索引获取。</li>
<li>字典是无序的。</li>
<li>字典是可变序列的。</li>
<li>字典的键值是唯一的，如果有相同键值，后面的会覆盖前面的。</li>
<li>字典是键必须不可变。</li>
</ul>
<h2 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;&#125;</span><br><span class="line">dictionary = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>



<h2 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br><span class="line"></span><br><span class="line">keylist = [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key3&quot;</span>]</span><br><span class="line">valuelist = [<span class="string">&quot;value1&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;value4&quot;</span>]</span><br><span class="line">dictionary = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keylist, valuelist))</span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br><span class="line"></span><br><span class="line">dictionary = <span class="built_in">dict</span>(key1=<span class="string">&quot;value1&quot;</span>, key2=<span class="string">&quot;value2&quot;</span>, key3=<span class="string">&quot;value3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖总&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>, <span class="string">&#x27;key3&#x27;</span>: <span class="string">&#x27;value3&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>, <span class="string">&#x27;key3&#x27;</span>: <span class="string">&#x27;value3&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>zip()</code> 函数创建字典，字典元素个数取两个列表长度较短的那个。</p>
</blockquote>
<h2 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dictionary</span>.clear()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> dictionary</span><br></pre></td></tr></table></figure>



<h2 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h2><p>字典只能通过键值去访问内部的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dictionary[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(dictionary.get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(dictionary[<span class="string">&quot;age&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(dictionary.get(<span class="string">&quot;age&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">肖总</span><br><span class="line">肖总</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，如果直接使用 <code>[键值]</code>获得的时候，字典中不存在该键值，会直接爆错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dictionary[<span class="string">&quot;sex&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>运行结果：报错</p>
<p>使用 <code>get()</code>方法如果没有该键值会返回 <code>None</code>值，而且可以设置第二个参数为默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dictionary.get(<span class="string">&quot;sex&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(dictionary.get(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;未知&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">未知</span><br></pre></td></tr></table></figure>



<h2 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h2><p>可以使用字典的 <code>items()</code> 方法遍历字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dictionary.items():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dictionary.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;肖总&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">name 肖总</span><br><span class="line">age <span class="number">18</span></span><br></pre></td></tr></table></figure>



<h2 id="修改元素-2"><a href="#修改元素-2" class="headerlink" title="修改元素"></a>修改元素</h2><p>字典可以直接通过添加键值的方式，对字典中的元素进行添加，修改等操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br><span class="line">dictionary[<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br><span class="line">dictionary[<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;女&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖总&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖总&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖总&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;女&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>



<p>字典可以通过 <code>del</code>命令删除字典元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br><span class="line"><span class="keyword">del</span> dictionary[<span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖总&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖总&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果删除一个不存在的键值，会直接报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dictionary[<span class="string">&quot;sex&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>运行结果：报错</p>
<p>正确的删除方式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;sex&quot;</span> <span class="keyword">in</span> dictionary:</span><br><span class="line">    <span class="keyword">del</span> dictionary[<span class="string">&quot;sex&quot;</span>]</span><br></pre></td></tr></table></figure>



<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line">value = [<span class="string">&quot;肖总&quot;</span>, <span class="string">&quot;18&quot;</span>]</span><br><span class="line">dictionary = &#123;i: j + <span class="string">&quot;~&quot;</span> <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(key, value)&#125;</span><br><span class="line"><span class="built_in">print</span>(dictionary)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖总~&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18~&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>





<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><blockquote>
<p>集合和列表一样，都是若干个元素的集合，不过集合和列表的区别在于，集合中如果有重复元素，只会保留一个。</p>
</blockquote>
<h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setname = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(setname)</span><br></pre></td></tr></table></figure>



<p>可以使用 <code>set()</code>函数，将列表，元组转换为集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">list</span>))</span><br><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">tuple</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>



<h2 id="修改集合"><a href="#修改集合" class="headerlink" title="修改集合"></a>修改集合</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setname = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(setname)</span><br><span class="line">setname.add(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(setname)</span><br><span class="line">setname.remove(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(setname)</span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setname1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">setname2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line"><span class="built_in">print</span>(setname1 &amp; setname2)</span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line"><span class="built_in">print</span>(setname1 | setname2)</span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line"><span class="built_in">print</span>(setname1 - setname2)</span><br><span class="line"><span class="built_in">print</span>(setname2 - setname1)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>





<h1 id="序列之间的区别"><a href="#序列之间的区别" class="headerlink" title="序列之间的区别"></a>序列之间的区别</h1><table>
<thead>
<tr>
<th>序列</th>
<th>是否可变</th>
<th>是否重复</th>
<th>是否有序</th>
<th>定义符号</th>
</tr>
</thead>
<tbody><tr>
<td>列表(list）</td>
<td>可变</td>
<td>可重复</td>
<td>有序</td>
<td>[]</td>
</tr>
<tr>
<td>元组(tuple）</td>
<td>不可变</td>
<td>可重复</td>
<td>有序</td>
<td>()</td>
</tr>
<tr>
<td>字典(dictionary）</td>
<td>可变</td>
<td>不可重复</td>
<td>无序</td>
<td>{key:value}</td>
</tr>
<tr>
<td>集合(set）</td>
<td>可变</td>
<td>不可重复</td>
<td>无序</td>
<td>{}</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis安装及常用命令</title>
    <url>/2020/02/22/redis/Redis%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一款开源的，高性能的，存储key-value数据结构的缓存数据库，相比较于其他缓存数据库而言，Redis有以下优势：</p>
<span id="more"></span>
<ul>
<li>Redis支持数据的持久化，可以将数据持久化到硬盘中，服务器重启后可以重新加载到Redis数据库中。</li>
<li>Redis不仅仅支持String类型的数据，还支持Hash，List，Set，Zset等数据结构的存储。</li>
<li>Redis支持数据备份。</li>
<li>Redis读写性能极高，根据官方测试数据，Redis读速度为11万次/秒，写速度为8.1万次/秒。</li>
<li>Redis的操作具有原子性，即要么命令执行成功，要么命令执行失败，即便是多组命令，也可以通过MULTI和EXEC指令包起来，实现原子性。</li>
</ul>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><p>Redis官网：<a href="https://redis.io/">https://redis.io/</a><br><img src="/images/2020/02/20200222100610306.png" alt="在这里插入图片描述"></p>
<p>不过需要注意的是，Redis官网中只有tar.gz格式的安装包，如果你是Windows操作系统，那么你需要到github上下载Windows操作系统的安装包。</p>
<p>github下载地址：<a href="https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100">https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100</a></p>
<p><img src="/images/2020/02/20200222101051950.png" alt="在这里插入图片描述"><br>安装包下载完成之后，直接在安装目录下解压缩即可。</p>
<h2 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h2><p>我们先来看看Redis解压缩之后的目录结构，其中我们需要关注的有两个执行文件。<br><img src="/images/2020/02/2020022210141112.png" alt="在这里插入图片描述"><br>我们先双击redis-server.exe执行文件。<br><img src="/images/2020/02/20200222101610363.png" alt="在这里插入图片描述"><br><strong>记住，不要关闭这个命令窗口界面，因为关闭这个窗口就相当于关闭服务器，我们把这个窗口最小化即可。</strong></p>
<p>然后我们再双击redis-cli.exe执行文件。<br><img src="/images/2020/02/20200222101948154.png" alt="在这里插入图片描述"><br>如此，Redis就已经启动成功了，如果我们使用其他Redis客户端或API来操作Redis，那么只需要启动Redis的服务器就可以了，Redis的客户端可以不需要启动。</p>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis是一个key-value型数据库，所有的数据都是以key-value结构存储在内存中的。<br>Redis的key类型全部都是String类型，即字符串。<br>Redis的value类型可以支持5中不同的数据类型：</p>
<ul>
<li>String（字符串）：普通字符串</li>
<li>Hash（哈希）：Map结构</li>
<li>List（列表）：linkedList结构，支持重复元素</li>
<li>Set（集合）：不允许重复元素</li>
<li>Zset（有序集合）：sortedSet，支持重复元素，且元素有序</li>
</ul>
<h2 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h2><p><strong>通用命令</strong></p>
<ul>
<li>keys *        ： 显示所有的key值</li>
<li>type key     ：显示key对应的value的类型</li>
<li>del key         ：删除指定的key和value</li>
</ul>
<p><strong>字符串类型（String）命令</strong></p>
<ul>
<li>存储：set key value</li>
<li>获取：get key</li>
<li>删除：del key</li>
</ul>
<p><img src="/images/2020/02/20200222104449885.png" alt="在这里插入图片描述"></p>
<p><strong>哈希类型（hash）命令</strong></p>
<ul>
<li>存储：hset key field value</li>
<li>获取：<pre><code>hget key field：获取指定的field对应的值
hgetall key：获取所有的field和value</code></pre></li>
<li>删除：hdel key field</li>
</ul>
<p><img src="/images/2020/02/20200222105001183.png" alt="在这里插入图片描述"></p>
<p><strong>列表类型（list）命令</strong></p>
<ul>
<li>添加：<br>  lpush key value ：将元素加入列表的左边<br>  rpush key value：将元素加入列表的右边</li>
<li>获取：lrange key strart end：范围获取<br>【注意】lrange命令索引从0开始，返回[strart,end]闭区间，end取-1则获取从strart开始至结尾的全部元素。</li>
<li>删除：<br>   lpop key：删除列表最左边的元素，并将元素返回<br>  rpop key：删除列表最右边的元素，并将元素返回</li>
</ul>
<p><img src="/images/2020/02/20200222105825424.png" alt="在这里插入图片描述"></p>
<p><strong>集合类型（set）命令</strong></p>
<ul>
<li>存储：sadd key value：</li>
<li>获取：smembers key ：获取set集合中的所有元素</li>
<li>删除：srem key value：删除set集合中的某个元素</li>
</ul>
<p><img src="/images/2020/02/20200222110340277.png" alt="在这里插入图片描述"></p>
<p><strong>有序集合类型（sortedset）命令</strong></p>
<ul>
<li>存储：zadd key score value：score为排序分数</li>
<li>获取：zrange key start end：如果要显示score的值，就在后面加withscores</li>
<li>删除：zrem key value</li>
</ul>
<p><img src="/images/2020/02/20200222111423909.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现商品秒杀</title>
    <url>/2020/03/19/redis/Redis%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E7%A7%92%E6%9D%80/</url>
    <content><![CDATA[<blockquote>
<p>商品秒杀是一个非常常见的场景，今天我们就使用Redis来实现商品秒杀功能。</p>
</blockquote>
<span id="more"></span>
<h1 id="为什么使用Redis？"><a href="#为什么使用Redis？" class="headerlink" title="为什么使用Redis？"></a>为什么使用Redis？</h1><ul>
<li>Redis是一款非关系数据库，数据存储在内存中，存取数据速度非常快！</li>
<li>Redis是单线程的，即使在同一时间有多条命令操作数据库，这些命令依然只能排队等候。</li>
</ul>
<h1 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h1><p>SpringDataRedis是一款Java语言实现的Redis数据库的操作API，它是SpringData系列的框架之一，专门用于操作Redis，而且可以和SpringBoot进行无缝整合。</p>
<h1 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="怎么实现？"></a>怎么实现？</h1><p>Redis可以存储五种数据结构，我们使用列表数据来实现商品秒杀功能。</p>
<ul>
<li>我们将商品信息作为列表结构的key值，给列表push商品库存个数的value。</li>
<li>当商品秒杀的时候，我们使用pop命令从列表中取出数据即可。</li>
</ul>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot为父项目--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试功能的启动器，用于整合junit测试功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring-Data-Redis的启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombox插件的依赖，SpringBoot内置，无须标注版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot项目的启动类"><a href="#SpringBoot项目的启动类" class="headerlink" title="SpringBoot项目的启动类"></a>SpringBoot项目的启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><ul>
<li><strong>Dao层接口</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommodityDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将商品加入库存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">(String key,String value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">spike</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Dao层实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommodityDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">CommodityDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">(String key,String value)</span> &#123;</span><br><span class="line">        redisTemplate.boundListOps(key).leftPush(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">spike</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) redisTemplate.boundListOps(key).leftPop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><ul>
<li><strong>Service层接口</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommodityService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将商品加入库存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">(<span class="type">int</span> stock)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">spike</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Service层实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommodityServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CommodityService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommodityDao commodityDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;commodity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">(<span class="type">int</span> stock)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stock; i++) &#123;</span><br><span class="line">            commodityDao.addStock(KEY,<span class="string">&quot;智能手表&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">spike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> commodityDao.spike(KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试功能"><a href="#测试功能" class="headerlink" title="测试功能"></a>测试功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommodityService commodityService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行商品秒杀前，将商品存入数据库中，已存入5件商品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">()</span> &#123;</span><br><span class="line">        commodityService.addStock(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 商品秒杀测试，使用两个线程一起秒杀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        es.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在秒杀&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">commodity</span> <span class="operator">=</span> commodityService.spike();</span><br><span class="line">                <span class="keyword">if</span> (commodity != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了商品&quot;</span> + commodity);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;商品被抢完了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在秒杀&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">commodity</span> <span class="operator">=</span> commodityService.spike();</span><br><span class="line">                <span class="keyword">if</span> (commodity != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了商品&quot;</span> + commodity);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;商品被抢完了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单线程环境秒杀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">commodity</span> <span class="operator">=</span> commodityService.spike();</span><br><span class="line">            <span class="keyword">if</span> (commodity != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了商品&quot;</span> + commodity);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品被抢完了&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现排行榜</title>
    <url>/2020/03/19/redis/Redis%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C/</url>
    <content><![CDATA[<blockquote>
<p>Redis作为最为常用的非关系型数据库，具有十分优秀的性能，Redis的多种存储数据结构可以适应各种场景。</p>
</blockquote>
<span id="more"></span>
<h1 id="为什么使用Redis实现排行榜？"><a href="#为什么使用Redis实现排行榜？" class="headerlink" title="为什么使用Redis实现排行榜？"></a>为什么使用Redis实现排行榜？</h1><ul>
<li>Redis作为一款缓存数据库，性能优异，使用Redis可以提升服务存取数据的性能。</li>
<li>Redis的zset（有序集合）数据结构，天然具备作为排行榜的优势。<h1 id="怎么使用Redis实现排行榜？"><a href="#怎么使用Redis实现排行榜？" class="headerlink" title="怎么使用Redis实现排行榜？"></a>怎么使用Redis实现排行榜？</h1></li>
<li>使用Redis的zset数据结构，其中key为固定值，value为排行榜名称，score为排行分数。</li>
<li>我们记录点击数，每点击一次，排行榜所在的排名越高。</li>
<li>Redis的zset数据结构，使用的是从小到大的排序方式，所以我们使用负数来作为排名分数，每点击一次，排行榜的分数-1。<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1></li>
</ul>
<h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>Redis实现排行榜的项目环境，与<a href="/2020/03/19/redis/Redis实现商品秒杀/">Redis实现商品秒杀</a>完全一致，需要的可以到<a href="/2020/03/19/redis/Redis实现商品秒杀/">Redis实现商品秒杀</a>中去查看项目环境。</p>
<h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><ul>
<li><strong>Dao层接口</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis实现排名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hrp</span></span><br><span class="line"><span class="comment"> * 2020/3/19 16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击功能，修改排名,每点击一次，排名分数+1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> score</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(String key,String name,Double score)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有排名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">getSort</span><span class="params">(String key, Long start, Long end)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单个的排名分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Double <span class="title function_">getScore</span><span class="params">(String key,String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Dao层实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">SortDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(String key, String name, Double score)</span> &#123;</span><br><span class="line">        redisTemplate.boundZSetOps(key).incrementScore(name,score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSort</span><span class="params">(String key, Long start, Long end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.boundZSetOps(key).range(start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getScore</span><span class="params">(String key, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.boundZSetOps(key).score(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><ul>
<li><strong>Service层接口</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击功能，修改排名,每点击一次，排名分数+1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> score</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(String name,Double score)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有排名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">getSort</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单个的排名分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Double <span class="title function_">getScore</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Service层实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SortService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SortDao sortDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;sort&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(String name, Double score)</span> &#123;</span><br><span class="line">        sortDao.onClick(KEY,name,score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortDao.getSort(KEY,<span class="number">0L</span>,-<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getScore</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortDao.getScore(KEY,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="测试功能"><a href="#测试功能" class="headerlink" title="测试功能"></a>测试功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SortService sortService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String[] NAME = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;赵六&quot;</span>,<span class="string">&quot;田七&quot;</span>,<span class="string">&quot;孙八&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> NAME[<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">6</span>)];</span><br><span class="line">            sortService.onClick(name,-<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = sortService.getSort();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : set) &#123;</span><br><span class="line">            <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> sortService.getScore(str);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;名为：&quot;</span>+str+<span class="string">&quot;排名分数为：&quot;</span>+score);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>名为：孙八排名分数为：-<span class="number">194.0</span></span><br><span class="line">第<span class="number">2</span>名为：张三排名分数为：-<span class="number">184.0</span></span><br><span class="line">第<span class="number">3</span>名为：赵六排名分数为：-<span class="number">170.0</span></span><br><span class="line">第<span class="number">4</span>名为：田七排名分数为：-<span class="number">153.0</span></span><br><span class="line">第<span class="number">5</span>名为：王五排名分数为：-<span class="number">151.0</span></span><br><span class="line">第<span class="number">6</span>名为：李四排名分数为：-<span class="number">148.0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2020/03/16/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h1><p>在<a href="/2020/02/22/redis/Redis安装及常用命令/">Redis安装及常用命令</a>已经详细讲解了Redis这款菲关系型数据库，其中Redis比起其他非关系型数据库的优势之一，就是Redis支持数据的持久化机制。</p>
<span id="more"></span>
<p>Redis是一个内存数据库，Redis数据库中的所有数据都是以缓存的形式存储在内存中的，当redis服务器重启，或者电脑重启，数据会丢失。<br>为了解决这个问题，我们可以将redis内存中的数据持久化到硬盘中。<br><strong>Redis持久化机制有两种，分别是RDB和AOF。</strong></p>
<ul>
<li>RDB：在指定的时间间隔内，如果数据库内的数据达到改变次数，就对数据库进行快照。</li>
<li>AOF：记录每次对服务器的写操作，当服务器重启时会读取这些命令来恢复数据库的原始数据。<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2></li>
</ul>
<p><strong>默认方式，不需要进行配置，Redis默认就使用这种持久化机制</strong>，在一定的时间间隔中，检测key的变化情况，然后持久化数据。<br>Redis目录下有一个<code>redis.windows.conf</code>文件，其中有这么一段配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>		#<span class="number">15</span>分钟内有<span class="number">1</span>个key值被改变</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>		#<span class="number">5</span>分钟内有<span class="number">10</span>个key值被改变</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>	#<span class="number">1</span>分钟内有<span class="number">10000</span>个key值被改变</span><br></pre></td></tr></table></figure>
<p>当Redis数据库满足配置中的要求的时候，Redis服务器就会自动进行持久化，然后会在Redis的目录下生成一个名为<code>dump.rdb</code>的文件。<br>当服务器关闭，下一次重启服务器的时候，服务器就会自动读取<code>dump.rdb</code>中的内容，恢复数据库的原始数据。</p>
<p><strong>RDB的优点</strong></p>
<ul>
<li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 </li>
<li>这种文件非常适合用于进行备份，非常适用于灾难恢复。</li>
<li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
</ul>
<p><strong>RDB的缺点</strong></p>
<ul>
<li>RDB操作的时间粒度比较大，如果服务器发生故障，同时Redis的数据非常巨大，那么即便是1秒钟也可能会丢失大量的数据。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>日志记录的方式，可以记录每一条命令的操作，可以每一次命令操作后，持久化数据（消耗性能）。<br>在<code>redis.windows.conf</code>文件中，有一个<code>appendonly</code>属性，默认配置为no，如果需要使用AOF持久化机制，那么将<code>appendonly</code>修改为yes即可。<br>同时还应该修改appendfsync属性，设置AOF持久化策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appendonly no		#关闭AOF</span><br><span class="line">#appendonly yes		#开启AOF</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># appendfsync always		#每一次操作都进行持久化</span><br><span class="line">appendfsync everysec		#每隔一秒进行一次持久化</span><br><span class="line"># appendfsync no			#不进行持久化</span><br></pre></td></tr></table></figure>
<p>如果AOF持久化成功，那么会在Redis目录下生成一个<code>appendonly.aof</code>的文件。该文件作用与<code>dump.rdb</code>相似。</p>
<p><strong>AOF的优点</strong></p>
<ul>
<li>AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li>
</ul>
<p><strong>AOF的缺点</strong></p>
<ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
</ul>
<h2 id="开启持久化的方式"><a href="#开启持久化的方式" class="headerlink" title="开启持久化的方式"></a>开启持久化的方式</h2><p>打开cmd命令提示符窗口，进入Redis目录下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd E:\Program Files\Redis-x64-<span class="number">3.2</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>
<p>启动Redis服务器，并<strong>加载配置文件</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot使用Redis实现消息订阅</title>
    <url>/2020/03/31/redis/SpringBoot%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<blockquote>
<p>Redis不仅仅是一个优秀的非关系型缓存数据库，更是内置了一套消息机制。</p>
</blockquote>
<span id="more"></span>
<h2 id="关联知识"><a href="#关联知识" class="headerlink" title="关联知识"></a>关联知识</h2><ul>
<li><a href="/2020/02/22/redis/Redis安装及常用命令/">Redis安装及常用命令</a></li>
<li><a href="/2020/03/16/redis/Redis持久化/">Redis持久化</a></li>
<li><a href="/2020/03/19/redis/Redis实现商品秒杀/">Redis实现商品秒杀</a></li>
<li><a href="/2020/03/19/redis/Redis实现排行榜/">Redis实现排行榜</a></li>
</ul>
<h2 id="搭建项目环境"><a href="#搭建项目环境" class="headerlink" title="搭建项目环境"></a>搭建项目环境</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot为父项目--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试功能的启动器，用于整合junit测试功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring-Data-Redis的启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建监听者类"><a href="#创建监听者类" class="headerlink" title="创建监听者类"></a>创建监听者类</h2><p><strong>监听者1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener1</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] pattern)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyListener1收到消息：&quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;Mylistener1:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>监听者2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener2</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] pattern)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyListener2收到消息：&quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;Mylistener2:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurationSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedisMessageListenerContainer <span class="title function_">container</span><span class="params">(RedisConnectionFactory connectionFactory,</span></span><br><span class="line"><span class="params">                                            MessageListenerAdapter MyListener1,</span></span><br><span class="line"><span class="params">                                            MessageListenerAdapter MyListener2)</span> &#123;</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//订阅了一个叫chanel01的通道，这个container可以添加多个messageListener</span></span><br><span class="line">        container.addMessageListener(MyListener1, <span class="keyword">new</span> <span class="title class_">PatternTopic</span>(<span class="string">&quot;Mylistener1&quot;</span>));</span><br><span class="line">        <span class="comment">//订阅了一个叫chanel02的通道</span></span><br><span class="line">        container.addMessageListener(MyListener2, <span class="keyword">new</span> <span class="title class_">PatternTopic</span>(<span class="string">&quot;Mylistener2&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    MessageListenerAdapter <span class="title function_">MyListener1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MessageListenerAdapter</span>(<span class="keyword">new</span> <span class="title class_">MyListener1</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    MessageListenerAdapter <span class="title function_">MyListener2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MessageListenerAdapter</span>(<span class="keyword">new</span> <span class="title class_">MyListener2</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(factory);</span><br><span class="line">        <span class="comment">//定义value的序列化方式</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试类发送消息"><a href="#测试类发送消息" class="headerlink" title="测试类发送消息"></a>测试类发送消息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PubSubTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.convertAndSend(<span class="string">&quot;Mylistener1&quot;</span>,<span class="string">&quot;Redis发布的第一条消息&quot;</span>);</span><br><span class="line">        stringRedisTemplate.convertAndSend(<span class="string">&quot;Mylistener2&quot;</span>,<span class="string">&quot;Redis发布的第二条消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyListener2收到消息：Redis发布的第二条消息</span><br><span class="line">Mylistener2:Mylistener2</span><br><span class="line">MyListener1收到消息：Redis发布的第一条消息</span><br><span class="line">Mylistener1:Mylistener1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的安装&amp;IDEA整合Git</title>
    <url>/2020/02/16/tool/Git%E7%9A%84%E5%AE%89%E8%A3%85&amp;IDEA%E6%95%B4%E5%90%88Git/</url>
    <content><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。<br>也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>
<span id="more"></span>

<h2 id="1、下载与安装Git"><a href="#1、下载与安装Git" class="headerlink" title="1、下载与安装Git"></a>1、下载与安装Git</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br><img src="/images/2020/02/20200216200615234.png" alt="在这里插入图片描述">但是官网的下载速度非常慢，我试了几次都下载失败。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>电脑管家，没错，就是腾讯电脑管家，无意中发现在电脑管家的软件市场里面竟然有Git这个软件，而且——<strong>下载速度非常快</strong>【重点】<br><img src="/images/2020/02/20200216200924932.png" alt="在这里插入图片描述"></p>
<h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>我在自己的百度网盘中上传了Git的软件安装包，需要的可以去下载。<br><strong>链接</strong>：<a href="https://pan.baidu.com/s/1nBZHt0mBhFZadLSm2PYsXQ">https://pan.baidu.com/s/1nBZHt0mBhFZadLSm2PYsXQ</a><br><strong>提取码</strong>：enhm </p>
<h3 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h3><p>Git的安装非常简单，直接一路<strong>next</strong>就可以了，傻瓜式安装。<br>如果安装成功，打开cmd命令控制台，输入<strong>git –version</strong>即可查看到安装的git的版本。<br><img src="/images/2020/02/20200216201557805.png" alt="在这里插入图片描述"></p>
<p>如上图，说明安装成功！</p>
<h2 id="2、Git的配置"><a href="#2、Git的配置" class="headerlink" title="2、Git的配置"></a>2、Git的配置</h2><h3 id="配置全局用户名和密码"><a href="#配置全局用户名和密码" class="headerlink" title="配置全局用户名和密码"></a>配置全局用户名和密码</h3><p>安装成功后，随便在任何目录中点击鼠标右键，发现右键目录栏中多出了两栏。<br><img src="/images/2020/02/20200216202052724.png" alt="在这里插入图片描述"></p>
<p>点击<strong>Git Bash Here</strong>，就会进入Git的命令窗口，如下图：<br><img src="/images/2020/02/20200216202402590.png" alt="在这里插入图片描述"></p>
<p>我们在这个命令窗口中先配置一下全局用户名和邮箱，可以直接使用GitHub注册的账号的用户名和邮箱，命令如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your_name&quot;</span>  </span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@youremail.com&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h3><p>配置完全局用户名和邮箱，应该在生成一下Git的秘钥。<br>说到秘钥，就需要解释一下秘钥的作用了。</p>
<p>Git是一个远程仓库托管工具，可以远程链接云仓库上传自己的代码或资料，而像github，码云这些托管平台，一般使用两种协议进行数据传输，分别是https和ssh，其中使用https协议提交代码需要用户名和密码，而使用ssh协议则不需要用户名和密码，但是需要秘钥。<br>总的来说，秘钥主要就是用于ssh协议传输的时候使用的授权工具。</p>
<p>在Git命令窗口输入命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@youremail.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>输入完整命令，秘钥会自动生成在电脑用户目录下的.ssh文件中。<br><img src="/images/2020/02/20200216203921810.png" alt="在这里插入图片描述"></p>
<h3 id="github配置公钥"><a href="#github配置公钥" class="headerlink" title="github配置公钥"></a>github配置公钥</h3><p>我们先打开github网站，登录自己的账号，点击右上角的头像，就会有选项栏下拉，选择<strong>Settings</strong>。<br><img src="/images/2020/02/20200216204649687.png" alt="在这里插入图片描述"><br><img src="/images/2020/02/20200216205209368.png" alt="在这里插入图片描述"><br><img src="/images/2020/02/20200216205647937.png" alt="在这里插入图片描述"></p>
<h2 id="3、IDEA整合Git及使用"><a href="#3、IDEA整合Git及使用" class="headerlink" title="3、IDEA整合Git及使用"></a>3、IDEA整合Git及使用</h2><h3 id="IDEA整合Git"><a href="#IDEA整合Git" class="headerlink" title="IDEA整合Git"></a>IDEA整合Git</h3><p><img src="/images/2020/02/20200216210721164.png" alt="在这里插入图片描述"></p>
<h3 id="在IDEA中使用Git并上传文件"><a href="#在IDEA中使用Git并上传文件" class="headerlink" title="在IDEA中使用Git并上传文件"></a>在IDEA中使用Git并上传文件</h3><p>第一步，先创建一个Git本地仓库。<br><img src="/images/2020/02/2020021621132882.png" alt="在这里插入图片描述"><br><img src="/images/2020/02/20200216211335883.png" alt="在这里插入图片描述"></p>
<p>在选择仓库目录的时候，选择项目所在的目录，点击OK。同时在该目录下生成.git文件，说明仓库创建成功。<br><img src="/images/2020/02/20200216211536120.png" alt="在这里插入图片描述"></p>
<p>同时在IDEA的右上角会出现几个和Git相关的图标。<br><img src="/images/2020/02/20200216211722395.png" alt="在这里插入图片描述"><br><img src="/images/2020/02/20200216212352242.png" alt="在这里插入图片描述"></p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>点击COMMIT后，Git会将文件提交到本地仓库中，我们还需要远程将文件推送到远程仓库中。<br><img src="/images/2020/04/2020040411452756.png" alt="在这里插入图片描述"></p>
<p>创建仓库之后，VCS的目录也发生了变化，我们点击Git-&gt;Push。<br>如果是第一次和远程仓库建立链接，那么需要输入远程仓库的地址。<br><img src="/images/2020/02/20200216213318728.png" alt="在这里插入图片描述"></p>
<p>最后，我们点击最下面的PUSH，就可以将之前添加到本地仓库中的所有文件推送到远程仓库中去了。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA 插件 Alibaba Cloud Toolkit，一键部署前后端项目</title>
    <url>/2021/05/31/tool/IDEA%20%E6%8F%92%E4%BB%B6%20Alibaba%20Cloud%20Toolkit%EF%BC%8C%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="Alibaba-Cloud-Toolkit"><a href="#Alibaba-Cloud-Toolkit" class="headerlink" title="Alibaba Cloud Toolkit"></a>Alibaba Cloud Toolkit</h1><p>Alibaba Cloud Toolkit，顾名思义，这是一个由阿里开发的，用于快速部署云服务项目的 IDEA 插件工具。<br>使用该插件，可以在本地直接一键部署项目到云端服务器。</p>
<span id="more"></span>

<h2 id="下载-IDEA-插件"><a href="#下载-IDEA-插件" class="headerlink" title="下载 IDEA 插件"></a>下载 IDEA 插件</h2><p>File -&gt; Settings -&gt; Plugins</p>
<p>在插件的搜索栏输入 <code>Alibaba Cloud Toolkit</code>，下载、安装、重启 IDEA 即可。<br><img src="/images/2021/05/20210531231020147.png" alt="在这里插入图片描述"></p>
<h2 id="配置云端服务器"><a href="#配置云端服务器" class="headerlink" title="配置云端服务器"></a>配置云端服务器</h2><p>这里的云端服务器，可以是真正的云端服务器，比如阿里云服务器，腾讯云服务器等等，也可以是自己本地上的虚拟机服务器。</p>
<p>在 IDEA 的侧边或者底部的标签上可以找到一个 <code>Alibaba Cloud View</code> 的标签，打开该标签即可。</p>
<p><img src="/images/2021/05/20210531232711449.png" alt="在这里插入图片描述"></p>
<p>在该标签栏中点击右上角的 <code>Add Host</code> 按钮，按照自己的配置信息进行配置即可。</p>
<p><img src="/images/2021/05/20210531233029430.png" alt="在这里插入图片描述"><br>配置完主机信息，就会在标签页面形成一条主机记录，点击记录的 <code>Upload</code>  按钮，配置上传文件的属性。</p>
<p><img src="/images/2021/05/20210531233204440.png" alt="在这里插入图片描述"></p>
<p><img src="/images/2021/05/20210531233526517.png" alt="在这里插入图片描述"><br>在后续的开发过程中，只要更新了新的 <code>jar</code> 包之后，直接使用 <code>Upload</code> 按钮，即可直接一键部署项目到云端服务器。<br>前端项目也是同样的步骤和原理。</p>
<p>到此为止，使用 Alibaba Cloud Toolkit 插件工具来一键部署项目就完成了，在文章末尾，附带前后端项目部署的 <code>sh</code> 脚本文件。</p>
<h2 id="sh-脚本文件"><a href="#sh-脚本文件" class="headerlink" title="sh 脚本文件"></a>sh 脚本文件</h2><h3 id="后端项目部署脚本"><a href="#后端项目部署脚本" class="headerlink" title="后端项目部署脚本"></a>后端项目部署脚本</h3><ul>
<li>spring-boot.sh<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称</span></span><br><span class="line">SERVICE_NAME=zero-admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">项目路径</span></span><br><span class="line">SERVICE_DIR=/usr/web-project/zero-admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件</span></span><br><span class="line">LOG_FILE=$&#123;SERVICE_DIR&#125;/log.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">jar名称</span></span><br><span class="line">JAR_NAME=zero-web-1\.0-SNAPSHOT\.jar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进程文件名称</span></span><br><span class="line">PID_FILE=$&#123;SERVICE_NAME&#125;\.pid</span><br><span class="line"></span><br><span class="line">help()&#123;</span><br><span class="line">  echo &quot;=== spring-boot shell help start ===&quot;</span><br><span class="line">  echo &quot;start 启动服务&quot;</span><br><span class="line">  echo &quot;stop 停止服务&quot;</span><br><span class="line">  echo &quot;restart 重启服务&quot;</span><br><span class="line">  echo &quot;===  spring-boot shell help end  ===&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()&#123;</span><br><span class="line">  if [ ! -x $&#123;JAR_NAME&#125; ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;=== $&#123;JAR_NAME&#125;添加可执行权限 ===&quot;</span><br><span class="line">    chmod +x $&#123;JAR_NAME&#125;</span><br><span class="line">  fi</span><br><span class="line">  nohup java -Dfile.encoding=UTF-8 -jar $&#123;JAR_NAME&#125; --spring.profiles.active=prod &gt;$&#123;LOG_FILE&#125; 2&gt;&amp;1 &amp;</span><br><span class="line">  echo $! &gt; $&#123;SERVICE_DIR&#125;/$&#123;PID_FILE&#125;</span><br><span class="line">	echo &quot;=== 服务$&#123;SERVICE_NAME&#125;已启动 ===&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()&#123;</span><br><span class="line">  P_ID=$(cat $&#123;SERVICE_DIR&#125;/$&#123;PID_FILE&#125;)</span><br><span class="line">  if [ &quot;$&#123;P_ID&#125;&quot; == &quot;&quot; ]</span><br><span class="line">  then</span><br><span class="line">    echo &quot;=== 服务$&#123;SERVICE_NAME&#125;不存在或者已停止 ===&quot;</span><br><span class="line">  else</span><br><span class="line">    kill &quot;$&#123;P_ID&#125;&quot;</span><br><span class="line">    rm -rf $&#123;SERVICE_DIR&#125;/$&#123;PID_FILE&#125;</span><br><span class="line">    echo &quot;=== 服务$&#123;SERVICE_NAME&#125;已停止 ===&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart()&#123;</span><br><span class="line">  stop</span><br><span class="line">  sleep 2</span><br><span class="line">  start</span><br><span class="line">  echo &quot;=== 服务$&#123;SERVICE_NAME&#125;已重启 ===&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cd $&#123;SERVICE_DIR&#125;</span><br><span class="line"></span><br><span class="line">case $&#123;1&#125; in</span><br><span class="line">    &quot;&quot;)</span><br><span class="line">      echo &quot;=== 参数错误 ===&quot;</span><br><span class="line">        ;;</span><br><span class="line">    help)</span><br><span class="line">      help</span><br><span class="line">        ;;</span><br><span class="line">    start)</span><br><span class="line">      start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">     	stop</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">      restart</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">      help</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="前端项目部署脚本"><a href="#前端项目部署脚本" class="headerlink" title="前端项目部署脚本"></a>前端项目部署脚本</h3><ul>
<li>vue-app.sh</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VueApp的项目目录</span></span><br><span class="line">VUE_APP_DIR=/usr/web-project/zero-admin/dist</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker 停止 nginx 服务</span></span><br><span class="line">docker stop nginx</span><br><span class="line">sleep 2</span><br><span class="line">docker cp $&#123;VUE_APP_DIR&#125; nginx:$&#123;VIE_APP_DIR&#125;</span><br><span class="line">docker start nginx</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA数据库集成管理工具Database的使用</title>
    <url>/2020/07/23/tool/IDEA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7Database%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>最近重新安装了一个新的IDEA，新的开发工具，自然带给人新的生活和心情，今天我们来学习使用IDEA自带的数据库集成管理工具Database的使用。</p>
</blockquote>
<span id="more"></span>

<h2 id="一、打开Database"><a href="#一、打开Database" class="headerlink" title="一、打开Database"></a>一、打开Database</h2><p><img src="/images/2020/07/20200723215200316.png" alt="在这里插入图片描述"></p>
<h2 id="二、配置Database"><a href="#二、配置Database" class="headerlink" title="二、配置Database"></a>二、配置Database</h2><p>首先，我们需要根据我们所使用的数据库类型来选择数据源，因为作者常用的数据库为MySQL，所以在博客中就以MySQL作为例子来进行配置。</p>
<h3 id="2-1、选择数据库"><a href="#2-1、选择数据库" class="headerlink" title="2.1、选择数据库"></a>2.1、选择数据库</h3><p><img src="/images/2020/07/20200723215358424.png" alt="在这里插入图片描述"></p>
<h3 id="2-2、配置数据库连接信息"><a href="#2-2、配置数据库连接信息" class="headerlink" title="2.2、配置数据库连接信息"></a>2.2、配置数据库连接信息</h3><p><img src="/images/2020/07/20200723220359941.png" alt="在这里插入图片描述"></p>
<h3 id="2-3、下载数据库驱动"><a href="#2-3、下载数据库驱动" class="headerlink" title="2.3、下载数据库驱动"></a>2.3、下载数据库驱动</h3><p><img src="/images/2020/07/20200723220359876.png" alt="在这里插入图片描述"></p>
<h3 id="2-4、下载中……"><a href="#2-4、下载中……" class="headerlink" title="2.4、下载中……"></a>2.4、下载中……</h3><p><img src="/images/2020/07/20200723220359308.png" alt="在这里插入图片描述"></p>
<h3 id="2-5、报错"><a href="#2-5、报错" class="headerlink" title="2.5、报错"></a>2.5、报错</h3><p>下载驱动成功后，我们点击测试按钮，结果爆出一个错误：</p>
<blockquote>
<p>Server returns invalid timezone. Need to set ‘serverTimezone’ property.</p>
</blockquote>
<p><img src="/images/2020/07/20200723221047682.png" alt="在这里插入图片描述"></p>
<h3 id="2-6、解决爆错"><a href="#2-6、解决爆错" class="headerlink" title="2.6、解决爆错"></a>2.6、解决爆错</h3><p><img src="/images/2020/07/20200723221653493.png" alt="在这里插入图片描述"></p>
<p><img src="/images/2020/07/20200723221451412.png" alt="在这里插入图片描述"><br><img src="/images/2020/07/20200723221451393.png" alt="在这里插入图片描述"></p>
<h2 id="三、使用Database"><a href="#三、使用Database" class="headerlink" title="三、使用Database"></a>三、使用Database</h2><p><img src="/images/2020/07/20200723222003723.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven安装与配置&amp;IDEA整合Maven</title>
    <url>/2020/01/26/tool/Maven%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE&amp;IDEA%E6%95%B4%E5%90%88Maven/</url>
    <content><![CDATA[<p>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。<br>现在，我们就来配置一个Maven，并将Maven工具和IDEA进行整合，让我们可以通过IDEA来创建Maven项目。</p>
<span id="more"></span>

<h2 id="下载Maven。"><a href="#下载Maven。" class="headerlink" title="下载Maven。"></a>下载Maven。</h2><p>Maven官网地址为：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p><img src="/images/2020/01/2020012619064198.png" alt="在这里插入图片描述"></p>
<p><strong>从Maven官网上下载Maven的压缩包之后，直接在安装目录下解压缩即可。</strong></p>
<h2 id="配置Maven环境"><a href="#配置Maven环境" class="headerlink" title="配置Maven环境"></a>配置Maven环境</h2><p>将Maven解压缩之后，Maven还不可以直接使用，需要对Maven进行相关的配置。</p>
<h3 id="配置Maven系统环境变量"><a href="#配置Maven系统环境变量" class="headerlink" title="配置Maven系统环境变量"></a>配置Maven系统环境变量</h3><p>按照顺序打开：此电脑（右键）-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</p>
<p><img src="/images/2020/01/20200126191808702.png" alt="在这里插入图片描述"></p>
<p>在环境变量中点击新建，配置一个新的系统变量：</p>
<p>变量名：MAVEN_HOME<br>变量值：E:\Program Files\apache-maven-3.6.1 <strong>（变量值的属性是你放置Maven解压缩包的路径）</strong></p>
<h3 id="配置Path属性"><a href="#配置Path属性" class="headerlink" title="配置Path属性"></a>配置Path属性</h3><p><img src="/images/2020/01/20200126192130313.png" alt="在这里插入图片描述"></p>
<p>编辑系统变量中的path变量，并在path中新建一个变量值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%MAVEN_HOME%\bin</span><br></pre></td></tr></table></figure>
<p>配置好了之后，点击确定，保存配置。</p>
<h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h3><p>然后就可以打开cmd创建，输入mvn -v，如果出现你的Maven版本号，就说明已经配置成功了。<br><img src="/images/2020/01/20200126192741414.png" alt="在这里插入图片描述"></p>
<h2 id="修改Maven配置"><a href="#修改Maven配置" class="headerlink" title="修改Maven配置"></a>修改Maven配置</h2><p>以上说明你已经安装好了Maven，但是我们需要使用，还需要修改maven的配置文件。</p>
<p>打开Maven的安装目录，找到conf文件下的settings.xml文件，使用编辑软件打开它。<br><img src="/images/2020/01/20200126192950315.png" alt="在这里插入图片描述"></p>
<h3 id="修改Maven仓库目录"><a href="#修改Maven仓库目录" class="headerlink" title="修改Maven仓库目录"></a>修改Maven仓库目录</h3><p>首先我们先配置Maven的本地仓库：<br><img src="/images/2020/01/20200126193234677.png" alt="在这里插入图片描述"></p>
<p>如果这个本地库不配置，那么Maven默认是在C盘用户目录下的.m2目录下，在这里，我将本地库的目录放到了<strong>F:\Maven\repository</strong>目录下，如果没有这个目录，可以直接手动创建目录。</p>
<h3 id="修改Maven中央仓库的访问路径"><a href="#修改Maven中央仓库的访问路径" class="headerlink" title="修改Maven中央仓库的访问路径"></a>修改Maven中央仓库的访问路径</h3><p>其次，我们需要配置Maven中央仓库的访问路径：<br><img src="/images/2020/01/2020012619361683.png" alt="在这里插入图片描述"></p>
<p>我配置的是国内的阿里云镜像仓库，如果不配置，那么默认使用的是国外的Maven中央仓库，如果网不好，可能会使得Maven在使用的时候jar下载速度慢。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改Maven的JDK编译版本"><a href="#修改Maven的JDK编译版本" class="headerlink" title="修改Maven的JDK编译版本"></a>修改Maven的JDK编译版本</h3><p>最后，我们需要配置Maven的JDK编译版本：<br><img src="/images/2020/01/20200126194003435.png" alt="在这里插入图片描述">Maven默认的JDK编译版本很低，有1.4的，也有1.5的，但是普遍不高，所以我直接配置了一个JDK1.8的默认编译版本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>     </span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk<span class="tag">&lt;/<span class="name">id</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;<span class="name">activation</span>&gt;</span>        </span><br><span class="line">		<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>      </span><br><span class="line">	<span class="tag">&lt;/<span class="name">activation</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到此为止，Maven的配置就结束了，我们就可以使用IDEA来整合Maven，并创建Maven项目了。</p>
<p><strong>打开IDEA，按照下图进行配置：</strong><br><img src="/images/2020/01/20200126194801751.png" alt="在这里插入图片描述"><br>除此之外，为了解决Maven项目在创建骨架时太慢的问题，我们需要修改运行参数：</p>
<p>在下图红框选中的地方，填入如下参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-DarchetypeCatalog=internal</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/01/20200126195329470.png" alt="在这里插入图片描述"></p>
<p>到此为止，Maven的配置和IDEA整合Maven工具就完成了。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven本地仓库删除.lastUpdated结尾的文件</title>
    <url>/2020/03/13/tool/Maven%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%88%A0%E9%99%A4.lastUpdated%E7%BB%93%E5%B0%BE%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>Maven 中有很多下载失败的，以.lastUpdated结尾的错误文件，我们可以直接将这些文件删除</p>
<span id="more"></span>

<h2 id="cmd命令删除"><a href="#cmd命令删除" class="headerlink" title="cmd命令删除"></a>cmd命令删除</h2><p>打开cmd命令窗口，进入Maven本地仓库，执行如下命令：</p>
<p><strong>第一步：进入本地仓库：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd F:\Maven\repository</span><br></pre></td></tr></table></figure>
<p><strong>第二步：执行以下命令：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /r %i <span class="title function_">in</span> <span class="params">(*.lastUpdated)</span> <span class="keyword">do</span> del %i</span><br></pre></td></tr></table></figure>


<h2 id="Java代码删除"><a href="#Java代码删除" class="headerlink" title="Java代码删除"></a>Java代码删除</h2><p>使用的是cmd命令窗口的方式，没有学习过这种命令的同学可能无法看懂，而这里使用的是Java代码的实现方式。<br>只需要运行下面代码的main方法，就可以递归删除Maven本地仓库下的所有以.lastUpdated为后缀的错误文件。</p>
<ul>
<li>运行前记得将常量<code>FILE_PATH</code>修改为自己的Maven本地仓库。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteErrorFile</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * FILE_NAME为Maven仓库的路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;F:\\Maven\\repository&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;.lastUpdated&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		deleteErrorFile(<span class="keyword">new</span> <span class="title class_">File</span>(FILE_PATH));</span><br><span class="line">		System.out.println(<span class="string">&quot;一共在Maven仓库中删除了&quot;</span> + count + <span class="string">&quot;个错误文件&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteErrorFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(String childrenFile : file.list()) &#123;</span><br><span class="line">                deleteErrorFile(<span class="keyword">new</span> <span class="title class_">File</span>(file,childrenFile));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.getName().endsWith(suffix)) &#123;</span><br><span class="line">                file.delete();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven项目pom.xml project标签爆红解决方法</title>
    <url>/2020/08/19/tool/Maven%E9%A1%B9%E7%9B%AEpom.xml%20project%E6%A0%87%E7%AD%BE%E7%88%86%E7%BA%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天在打开项目的时候，发现了一个Maven项目的问题，在Maven项目的pom.xml文件中，project标签爆出了一个错误。</p>
<span id="more"></span>
<p><img src="/images/2020/020200819081650697.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>‘parent.relativePath’ of POM com.hrp:springboot_jpa:1.0-SNAPSHOT (F:\IdeaCode\java-web\springboot_jpa\pom.xml) points at com.hrp:java-web instead of org.springframework.boot:spring-boot-starter-parent, please verify your project structure</p>
</blockquote>
<blockquote>
<p>POM com.hrp：springboot_jpa：1.0-SNAPSHOT（F：\ IdeaCode \ java-web \ springboot_jpa \ pom.xml）的’parent.relativePath’指向com.hrp：java-web而不是org.springframework.boot：spring -boot-starter-parent，请验证您的项目结构</p>
</blockquote>
<p>总而言之，这个问题是说在project标签下的parent.relativePath标签指向的路径出现了错误，所以导致报错。</p>
<p><strong>要解决这个问题的方法也很简单，在parent标签下添加一个<code>&lt;relativePath/&gt;</code>标签即可。</strong></p>
<p><img src="/images/2020/020200819082030419.png" alt="在这里插入图片描述"></p>
<p><strong>添加该标签之后，我们重新更新Maven项目，爆错就会消失了</strong></p>
<p><img src="/images/2020/020200819082324299.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman发送POST请求及日期格式的参数</title>
    <url>/2020/03/20/tool/Postman%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82%E5%8F%8A%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>Postman在发送POST请求的时候，所有参数写在Request Body（请求体）中，如果需要的参数类型的日期格式的，只需要将日期格式写为<code>2000/01/01</code>即可，Postman会自动识别为日期格式的数据。</p>
<span id="more"></span>

<ul>
<li>如果是2000-01-01格式，Postman无法识别为日期，而是当做普通字符串处理。</li>
</ul>
<p><img src="/images/2020/03/20200320164729364.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman的下载、安装与使用</title>
    <url>/2020/02/23/tool/Postman%E7%9A%84%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是Postman"><a href="#什么是Postman" class="headerlink" title="什么是Postman"></a>什么是Postman</h2><p>Postman是一款接口测试工具，可以模仿浏览器发出各种类型的HTTP请求，用来测试API是否可用。</p>
<span id="more"></span>

<h2 id="为什么要用Postman"><a href="#为什么要用Postman" class="headerlink" title="为什么要用Postman"></a>为什么要用Postman</h2><p>有一些小白可能会问，我可以直接在浏览器上访问应用程序的API不可以吗？为什么还需要多此一举使用Postman这么一个工具呢？<br>其实原因很简单，在没有html页面的情况下，我们直接在浏览器地址栏中输入的请求路径，请求类型全部都是Get方式的。<br>而对于RestFul开发风格而言，这很显然是不能满足的。</p>
<p><strong>举个栗子</strong><br>我们就以上一篇博文<a href="https://blog.csdn.net/qq_45193304/article/details/104455794">SpringBoot+SpringDataJPA</a>搭建的项目环境为例子。<br>在这个项目的web层中，有这么一个接口<strong>Get请求</strong>的接口：<code>/user/page/&#123;pageNum&#125;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;page/&#123;pageNum&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Page&lt;User&gt;&gt; <span class="title function_">findByPage</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable(&quot;pageNum&quot;)</span> Integer pageNum,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;5&quot;)</span> Integer pageSize)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(userService.findByPage(pageNum,pageSize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接启动项目，访问一下这个接口。<br><img src="/images/2020/01/20200223113154298.png" alt="在这里插入图片描述"><br>我们发现使用浏览器访问这个API没有任何问题，那么我们现在把这个API的请求方式改为POST，看看会发生什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;page/&#123;pageNum&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Page&lt;User&gt;&gt; <span class="title function_">findByPage</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@PathVariable(&quot;pageNum&quot;)</span> Integer pageNum,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(defaultValue = &quot;5&quot;)</span> Integer pageSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(userService.findByPage(pageNum,pageSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重启这个项目，再次使用浏览器访问这个API。<br><img src="/images/2020/01/20200223113638247.png" alt="在这里插入图片描述"></p>
<p><img src="/images/2020/01/20200223113835412.png" alt="在这里插入图片描述"></p>
<p>无论是页面，还是程序控制台，都爆出了不支持GET请求的错误，这个时候，我们使用浏览器就无法测试这个POST请求的API是否能够正常工作了。</p>
<ul>
<li><strong>而Postman这个工具，就能够解决这个问题。</strong></li>
</ul>
<h2 id="Postman的下载、安装与使用"><a href="#Postman的下载、安装与使用" class="headerlink" title="Postman的下载、安装与使用"></a>Postman的下载、安装与使用</h2><p>Postman下载官网地址：<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p>
<p><img src="/images/2020/01/20200223114315178.png" alt="在这里插入图片描述"></p>
<p>我们根据上图选择合适的版本进行下载，下载完整之后，直接点击运行，就可以安装完成。<br>我们运行Postman后，就会打开下面的界面，我们可以通过Postman来模拟发送其他各种类型的请求。</p>
<p><img src="/images/2020/01/202002231147543.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Postman</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇博客教会你怎么安装Docker</title>
    <url>/2020/04/16/tool/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%95%99%E4%BC%9A%E4%BD%A0%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h1 id="一、什么是Docker"><a href="#一、什么是Docker" class="headerlink" title="一、什么是Docker?"></a>一、什么是Docker?</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<span id="more"></span>
<p>Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用，所以今天我们在CentOS系统上安装Docker。</p>
<h1 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h1><p>本次的安装在CentOS8的系统环境下安装，如果不会安装CentOS系统的，可以参考我的博客：<br><a href="/2020/04/19/linux/一篇博客教会你怎么安装CentOS系统/">一篇博客教会你怎么安装CentOS系统</a></p>
<h2 id="1、更新yum源为最新"><a href="#1、更新yum源为最新" class="headerlink" title="1、更新yum源为最新"></a>1、更新yum源为最新</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>
<h2 id="2、安装需要的软件包"><a href="#2、安装需要的软件包" class="headerlink" title="2、安装需要的软件包"></a>2、安装需要的软件包</h2><p>yum-utils提供yum-config-manager功能，另外两个是devicemapper驱动依赖</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo yum install <span class="literal">-y</span> yum<span class="literal">-utils</span> device<span class="literal">-mapper-persistent-data</span> lvm2</span><br></pre></td></tr></table></figure>

<h2 id="3、设置yum源为阿里云"><a href="#3、设置yum源为阿里云" class="headerlink" title="3、设置yum源为阿里云"></a>3、设置yum源为阿里云</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo yum<span class="literal">-config-manager</span> <span class="literal">--add-repo</span> http://mirrors.aliyun.com/docker<span class="literal">-ce</span>/linux/centos/docker<span class="literal">-ce</span>.repo</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>yum repolist</code>命令查看是否已有<code>docker-ce-stable</code>仓库。</p>
<h2 id="4、安装docker"><a href="#4、安装docker" class="headerlink" title="4、安装docker"></a>4、安装docker</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker<span class="literal">-ce</span> <span class="literal">--nobest</span></span><br></pre></td></tr></table></figure>
<h2 id="5、查看安装版本"><a href="#5、查看安装版本" class="headerlink" title="5、查看安装版本"></a>5、查看安装版本</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dovker <span class="literal">-v</span></span><br></pre></td></tr></table></figure>
<p>安装成功后，可以使用<code>docker -v</code>命令来查看docker版本。</p>
<h1 id="三、设置Docker的国内镜像"><a href="#三、设置Docker的国内镜像" class="headerlink" title="三、设置Docker的国内镜像"></a>三、设置Docker的国内镜像</h1><p>如果使用Docker提供的国外镜像，下载或者说拉取文件的时候速度会非常慢，所以我们直接修改Docker的镜像为国内镜像，这样拉取文件的速度就会非常快。</p>
<h2 id="1、编辑文件"><a href="#1、编辑文件" class="headerlink" title="1、编辑文件"></a>1、编辑文件</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<h2 id="2、在该文件中输入如下内容"><a href="#2、在该文件中输入如下内容" class="headerlink" title="2、在该文件中输入如下内容"></a>2、在该文件中输入如下内容</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="四、启动Docker服务"><a href="#四、启动Docker服务" class="headerlink" title="四、启动Docker服务"></a>四、启动Docker服务</h1><h2 id="1、启动Docker服务"><a href="#1、启动Docker服务" class="headerlink" title="1、启动Docker服务"></a>1、启动Docker服务</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">start</span> docker</span><br></pre></td></tr></table></figure>
<h2 id="2、查看Docker服务状态"><a href="#2、查看Docker服务状态" class="headerlink" title="2、查看Docker服务状态"></a>2、查看Docker服务状态</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<h2 id="3、停止Docker服务"><a href="#3、停止Docker服务" class="headerlink" title="3、停止Docker服务"></a>3、停止Docker服务</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<h2 id="4、重启Docker服务"><a href="#4、重启Docker服务" class="headerlink" title="4、重启Docker服务"></a>4、重启Docker服务</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="5、设置Docker服务开机自启"><a href="#5、设置Docker服务开机自启" class="headerlink" title="5、设置Docker服务开机自启"></a>5、设置Docker服务开机自启</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h1 id="五、Docker常用命令"><a href="#五、Docker常用命令" class="headerlink" title="五、Docker常用命令"></a>五、Docker常用命令</h1><h2 id="1、Docker在线帮助文档"><a href="#1、Docker在线帮助文档" class="headerlink" title="1、Docker在线帮助文档"></a>1、Docker在线帮助文档</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="literal">--help</span></span><br></pre></td></tr></table></figure>
<h2 id="2、查看Docker概要信息"><a href="#2、查看Docker概要信息" class="headerlink" title="2、查看Docker概要信息"></a>2、查看Docker概要信息</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h2 id="3、镜像相关命令"><a href="#3、镜像相关命令" class="headerlink" title="3、镜像相关命令"></a>3、镜像相关命令</h2><h3 id="3-1、查看本地已有镜像"><a href="#3-1、查看本地已有镜像" class="headerlink" title="3.1、查看本地已有镜像"></a>3.1、查看本地已有镜像</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>REPOSITORY</th>
<th>TAG</th>
<th>IMAGE ID</th>
<th>CREATED</th>
<th>SIZE</th>
</tr>
</thead>
<tbody><tr>
<td>镜像名称</td>
<td>标签</td>
<td>镜像ID（唯一）</td>
<td>镜像创建时间</td>
<td>镜像占用大小</td>
</tr>
</tbody></table>
<h3 id="3-2、搜索镜像"><a href="#3-2、搜索镜像" class="headerlink" title="3.2、搜索镜像"></a>3.2、搜索镜像</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker search [镜像名称]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>NAME</th>
<th>DESCRIPTION</th>
<th>STARS</th>
<th>OFFICIAL</th>
<th>AUTOMATED</th>
</tr>
</thead>
<tbody><tr>
<td>镜像名称</td>
<td>描述</td>
<td>星（代表好评）</td>
<td>是否官方提供</td>
<td>是否由DockerHub自动构建</td>
</tr>
</tbody></table>
<h3 id="3-3、拉取镜像"><a href="#3-3、拉取镜像" class="headerlink" title="3.3、拉取镜像"></a>3.3、拉取镜像</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull [镜像名称]</span><br></pre></td></tr></table></figure>

<h3 id="3-4、删除镜像"><a href="#3-4、删除镜像" class="headerlink" title="3.4、删除镜像"></a>3.4、删除镜像</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按镜像名称删除镜像</span></span><br><span class="line">docker rmi [镜像名称]</span><br><span class="line"><span class="comment">#按镜像ID删除镜像</span></span><br><span class="line">docker rmi [镜像<span class="type">ID</span>]</span><br><span class="line"><span class="comment">#删除所有镜像</span></span><br><span class="line">docker rmi `docker images <span class="literal">-q</span>`</span><br></pre></td></tr></table></figure>

<h2 id="4、容器相关命令"><a href="#4、容器相关命令" class="headerlink" title="4、容器相关命令"></a>4、容器相关命令</h2><h3 id="4-1、查看运行中容器"><a href="#4-1、查看运行中容器" class="headerlink" title="4.1、查看运行中容器"></a>4.1、查看运行中容器</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment">#查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span></span><br><span class="line"><span class="comment">#查看最后一次运行的容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-l</span></span><br><span class="line"><span class="comment">#查看停止的容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="operator">-f</span> status=exited</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>CONTAINER ID</th>
<th>IMAGE</th>
<th>COMMAND</th>
<th>CREATED</th>
<th>STATUS</th>
<th>PORTS</th>
<th>NAMES</th>
</tr>
</thead>
<tbody><tr>
<td>容器ID</td>
<td>镜像名称</td>
<td>运行命令</td>
<td>创建时间</td>
<td>状态</td>
<td>端口映射关系</td>
<td>容器名称</td>
</tr>
</tbody></table>
<h3 id="4-2、创建容器"><a href="#4-2、创建容器" class="headerlink" title="4.2、创建容器"></a>4.2、创建容器</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run</span><br><span class="line"><span class="comment">#表示运行容器</span></span><br><span class="line"><span class="literal">-i</span></span><br><span class="line"><span class="comment">#表示运行容器后进入其命令行</span></span><br><span class="line"><span class="literal">-t</span></span><br><span class="line"><span class="comment">#表示为创建容器命名</span></span><br><span class="line"><span class="literal">--name</span></span><br><span class="line"><span class="comment">#表示目录映射关系</span></span><br><span class="line"><span class="literal">-v</span></span><br><span class="line"><span class="comment">#表示创建一个守护式容器在后台运行</span></span><br><span class="line"><span class="literal">-d</span></span><br><span class="line"><span class="comment">#表示端口映射，前者是宿主机端口，后者是容器内映射端口</span></span><br><span class="line"><span class="literal">-p</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3、退出容器"><a href="#4-3、退出容器" class="headerlink" title="4.3、退出容器"></a>4.3、退出容器</h3><p>在容器内执行命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>


<h3 id="4-4、停止容器"><a href="#4-4、停止容器" class="headerlink" title="4.4、停止容器"></a>4.4、停止容器</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按容器名称停止容器</span></span><br><span class="line">docker stop [容器名称]</span><br><span class="line"><span class="comment">#按容器ID停止容器</span></span><br><span class="line">docker stop [容器<span class="type">ID</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-5、运行容器"><a href="#4-5、运行容器" class="headerlink" title="4.5、运行容器"></a>4.5、运行容器</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按容器名称启动容器</span></span><br><span class="line">docker <span class="built_in">start</span> [容器名称]</span><br><span class="line"><span class="comment">#按容器ID启动容器</span></span><br><span class="line">docker <span class="built_in">start</span> [容器<span class="type">ID</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-6、文件拷贝"><a href="#4-6、文件拷贝" class="headerlink" title="4.6、文件拷贝"></a>4.6、文件拷贝</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把宿主机文件拷贝到容器内</span></span><br><span class="line">docker <span class="built_in">cp</span> [文件名称] [容器名称]:/[目录<span class="number">1</span>]/[目录<span class="number">2</span>]</span><br><span class="line"><span class="comment">#把容器内文件拷贝到宿主机中</span></span><br><span class="line">docker <span class="built_in">cp</span> [容器名称]:/[目录<span class="number">1</span>]/[文件名称] /[目录<span class="number">1</span>]/[目录<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-7、目录挂载"><a href="#4-7、目录挂载" class="headerlink" title="4.7、目录挂载"></a>4.7、目录挂载</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把宿主机文件拷贝到容器内</span></span><br><span class="line">docker run <span class="literal">-di</span> <span class="literal">-v</span> /[目录]/[文件名称]:/[目录]/[文件名称] <span class="literal">--name</span>=[容器名称]</span><br></pre></td></tr></table></figure>

<h3 id="4-8、查看容器IP地址"><a href="#4-8、查看容器IP地址" class="headerlink" title="4.8、查看容器IP地址"></a>4.8、查看容器IP地址</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker inspect <span class="literal">--format</span>=<span class="string">&#x27;&#123;&#123;.NetworkSetings.IpAddress&#125;&#125;&#x27;</span> [容器名称]</span><br></pre></td></tr></table></figure>

<h3 id="4-9、删除容器"><a href="#4-9、删除容器" class="headerlink" title="4.9、删除容器"></a>4.9、删除容器</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [容器名称]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
